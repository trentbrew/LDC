import { createRequire } from "node:module";
import { randomUUID } from "node:crypto";
import { URL as URL$1 } from "url";
import http from "http";

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i$3 = 0, n = keys.length, key$1; i$3 < n; i$3++) {
		key$1 = keys[i$3];
		if (!__hasOwnProp.call(to, key$1) && key$1 !== except) __defProp(to, key$1, {
			get: ((k) => from[k]).bind(null, key$1),
			enumerable: !(desc = __getOwnPropDesc(from, key$1)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region src/authentication.ts
var AuthenticationMiddleware = class {
	constructor(config = {}) {
		this.config = config;
	}
	getUnauthorizedResponse() {
		const headers = { "Content-Type": "application/json" };
		if (this.config.oauth?.protectedResource?.resource) headers["WWW-Authenticate"] = `Bearer resource_metadata="${this.config.oauth.protectedResource.resource}/.well-known/oauth-protected-resource"`;
		return {
			body: JSON.stringify({
				error: {
					code: 401,
					message: "Unauthorized: Invalid or missing API key"
				},
				id: null,
				jsonrpc: "2.0"
			}),
			headers
		};
	}
	validateRequest(req) {
		if (!this.config.apiKey) return true;
		const apiKey = req.headers["x-api-key"];
		if (!apiKey || typeof apiKey !== "string") return false;
		return apiKey === this.config.apiKey;
	}
};

//#endregion
//#region src/InMemoryEventStore.ts
/**
* Simple in-memory implementation of the EventStore interface for resumability
* This is primarily intended for examples and testing, not for production use
* where a persistent storage solution would be more appropriate.
*/
var InMemoryEventStore = class {
	events = /* @__PURE__ */ new Map();
	/**
	* Replays events that occurred after a specific event ID
	* Implements EventStore.replayEventsAfter
	*/
	async replayEventsAfter(lastEventId, { send }) {
		if (!lastEventId || !this.events.has(lastEventId)) return "";
		const streamId = this.getStreamIdFromEventId(lastEventId);
		if (!streamId) return "";
		let foundLastEvent = false;
		const sortedEvents = [...this.events.entries()].sort((a, b) => a[0].localeCompare(b[0]));
		for (const [eventId, { message, streamId: eventStreamId }] of sortedEvents) {
			if (eventStreamId !== streamId) continue;
			if (eventId === lastEventId) {
				foundLastEvent = true;
				continue;
			}
			if (foundLastEvent) await send(eventId, message);
		}
		return streamId;
	}
	/**
	* Stores an event with a generated event ID
	* Implements EventStore.storeEvent
	*/
	async storeEvent(streamId, message) {
		const eventId = this.generateEventId(streamId);
		this.events.set(eventId, {
			message,
			streamId
		});
		return eventId;
	}
	/**
	* Generates a unique event ID for a given stream ID
	*/
	generateEventId(streamId) {
		return `${streamId}_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
	}
	/**
	* Extracts the stream ID from an event ID
	*/
	getStreamIdFromEventId(eventId) {
		const parts = eventId.split("_");
		return parts.length > 0 ? parts[0] : "";
	}
};

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js
var util$6;
(function(util$7) {
	util$7.assertEqual = (_) => {};
	function assertIs(_arg) {}
	util$7.assertIs = assertIs;
	function assertNever(_x) {
		throw new Error();
	}
	util$7.assertNever = assertNever;
	util$7.arrayToEnum = (items) => {
		const obj = {};
		for (const item of items) obj[item] = item;
		return obj;
	};
	util$7.getValidEnumValues = (obj) => {
		const validKeys = util$7.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
		const filtered = {};
		for (const k of validKeys) filtered[k] = obj[k];
		return util$7.objectValues(filtered);
	};
	util$7.objectValues = (obj) => {
		return util$7.objectKeys(obj).map(function(e) {
			return obj[e];
		});
	};
	util$7.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
		const keys = [];
		for (const key$1 in object) if (Object.prototype.hasOwnProperty.call(object, key$1)) keys.push(key$1);
		return keys;
	};
	util$7.find = (arr, checker) => {
		for (const item of arr) if (checker(item)) return item;
	};
	util$7.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
	function joinValues(array, separator = " | ") {
		return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
	}
	util$7.joinValues = joinValues;
	util$7.jsonStringifyReplacer = (_, value) => {
		if (typeof value === "bigint") return value.toString();
		return value;
	};
})(util$6 || (util$6 = {}));
var objectUtil;
(function(objectUtil$1) {
	objectUtil$1.mergeShapes = (first, second) => {
		return {
			...first,
			...second
		};
	};
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$6.arrayToEnum([
	"string",
	"nan",
	"number",
	"integer",
	"float",
	"boolean",
	"date",
	"bigint",
	"symbol",
	"function",
	"undefined",
	"null",
	"array",
	"object",
	"unknown",
	"promise",
	"void",
	"never",
	"map",
	"set"
]);
const getParsedType = (data) => {
	switch (typeof data) {
		case "undefined": return ZodParsedType.undefined;
		case "string": return ZodParsedType.string;
		case "number": return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
		case "boolean": return ZodParsedType.boolean;
		case "function": return ZodParsedType.function;
		case "bigint": return ZodParsedType.bigint;
		case "symbol": return ZodParsedType.symbol;
		case "object":
			if (Array.isArray(data)) return ZodParsedType.array;
			if (data === null) return ZodParsedType.null;
			if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") return ZodParsedType.promise;
			if (typeof Map !== "undefined" && data instanceof Map) return ZodParsedType.map;
			if (typeof Set !== "undefined" && data instanceof Set) return ZodParsedType.set;
			if (typeof Date !== "undefined" && data instanceof Date) return ZodParsedType.date;
			return ZodParsedType.object;
		default: return ZodParsedType.unknown;
	}
};

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js
const ZodIssueCode = util$6.arrayToEnum([
	"invalid_type",
	"invalid_literal",
	"custom",
	"invalid_union",
	"invalid_union_discriminator",
	"invalid_enum_value",
	"unrecognized_keys",
	"invalid_arguments",
	"invalid_return_type",
	"invalid_date",
	"invalid_string",
	"too_small",
	"too_big",
	"invalid_intersection_types",
	"not_multiple_of",
	"not_finite"
]);
var ZodError = class ZodError extends Error {
	get errors() {
		return this.issues;
	}
	constructor(issues) {
		super();
		this.issues = [];
		this.addIssue = (sub) => {
			this.issues = [...this.issues, sub];
		};
		this.addIssues = (subs = []) => {
			this.issues = [...this.issues, ...subs];
		};
		const actualProto = new.target.prototype;
		if (Object.setPrototypeOf) Object.setPrototypeOf(this, actualProto);
		else this.__proto__ = actualProto;
		this.name = "ZodError";
		this.issues = issues;
	}
	format(_mapper) {
		const mapper = _mapper || function(issue) {
			return issue.message;
		};
		const fieldErrors = { _errors: [] };
		const processError = (error) => {
			for (const issue of error.issues) if (issue.code === "invalid_union") issue.unionErrors.map(processError);
			else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
			else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
			else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
			else {
				let curr = fieldErrors;
				let i$3 = 0;
				while (i$3 < issue.path.length) {
					const el = issue.path[i$3];
					if (!(i$3 === issue.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
					else {
						curr[el] = curr[el] || { _errors: [] };
						curr[el]._errors.push(mapper(issue));
					}
					curr = curr[el];
					i$3++;
				}
			}
		};
		processError(this);
		return fieldErrors;
	}
	static assert(value) {
		if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util$6.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue) => issue.message) {
		const fieldErrors = {};
		const formErrors = [];
		for (const sub of this.issues) if (sub.path.length > 0) {
			const firstEl = sub.path[0];
			fieldErrors[firstEl] = fieldErrors[firstEl] || [];
			fieldErrors[firstEl].push(mapper(sub));
		} else formErrors.push(mapper(sub));
		return {
			formErrors,
			fieldErrors
		};
	}
	get formErrors() {
		return this.flatten();
	}
};
ZodError.create = (issues) => {
	return new ZodError(issues);
};

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js
const errorMap = (issue, _ctx) => {
	let message;
	switch (issue.code) {
		case ZodIssueCode.invalid_type:
			if (issue.received === ZodParsedType.undefined) message = "Required";
			else message = `Expected ${issue.expected}, received ${issue.received}`;
			break;
		case ZodIssueCode.invalid_literal:
			message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$6.jsonStringifyReplacer)}`;
			break;
		case ZodIssueCode.unrecognized_keys:
			message = `Unrecognized key(s) in object: ${util$6.joinValues(issue.keys, ", ")}`;
			break;
		case ZodIssueCode.invalid_union:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_union_discriminator:
			message = `Invalid discriminator value. Expected ${util$6.joinValues(issue.options)}`;
			break;
		case ZodIssueCode.invalid_enum_value:
			message = `Invalid enum value. Expected ${util$6.joinValues(issue.options)}, received '${issue.received}'`;
			break;
		case ZodIssueCode.invalid_arguments:
			message = `Invalid function arguments`;
			break;
		case ZodIssueCode.invalid_return_type:
			message = `Invalid function return type`;
			break;
		case ZodIssueCode.invalid_date:
			message = `Invalid date`;
			break;
		case ZodIssueCode.invalid_string:
			if (typeof issue.validation === "object") if ("includes" in issue.validation) {
				message = `Invalid input: must include "${issue.validation.includes}"`;
				if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
			} else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
			else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
			else util$6.assertNever(issue.validation);
			else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
			else message = "Invalid";
			break;
		case ZodIssueCode.too_small:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
			else if (issue.type === "bigint") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.too_big:
			if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
			else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
			else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
			else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.custom:
			message = `Invalid input`;
			break;
		case ZodIssueCode.invalid_intersection_types:
			message = `Intersection results could not be merged`;
			break;
		case ZodIssueCode.not_multiple_of:
			message = `Number must be a multiple of ${issue.multipleOf}`;
			break;
		case ZodIssueCode.not_finite:
			message = "Number must be finite";
			break;
		default:
			message = _ctx.defaultError;
			util$6.assertNever(issue);
	}
	return { message };
};
var en_default = errorMap;

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js
let overrideErrorMap = en_default;
function getErrorMap() {
	return overrideErrorMap;
}

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js
const makeIssue = (params) => {
	const { data, path, errorMaps, issueData } = params;
	const fullPath = [...path, ...issueData.path || []];
	const fullIssue = {
		...issueData,
		path: fullPath
	};
	if (issueData.message !== void 0) return {
		...issueData,
		path: fullPath,
		message: issueData.message
	};
	let errorMessage = "";
	const maps = errorMaps.filter((m) => !!m).slice().reverse();
	for (const map$1 of maps) errorMessage = map$1(fullIssue, {
		data,
		defaultError: errorMessage
	}).message;
	return {
		...issueData,
		path: fullPath,
		message: errorMessage
	};
};
function addIssueToContext(ctx, issueData) {
	const overrideMap = getErrorMap();
	const issue = makeIssue({
		issueData,
		data: ctx.data,
		path: ctx.path,
		errorMaps: [
			ctx.common.contextualErrorMap,
			ctx.schemaErrorMap,
			overrideMap,
			overrideMap === en_default ? void 0 : en_default
		].filter((x) => !!x)
	});
	ctx.common.issues.push(issue);
}
var ParseStatus = class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status$1, results) {
		const arrayValue = [];
		for (const s of results) {
			if (s.status === "aborted") return INVALID;
			if (s.status === "dirty") status$1.dirty();
			arrayValue.push(s.value);
		}
		return {
			status: status$1.value,
			value: arrayValue
		};
	}
	static async mergeObjectAsync(status$1, pairs) {
		const syncPairs = [];
		for (const pair of pairs) {
			const key$1 = await pair.key;
			const value = await pair.value;
			syncPairs.push({
				key: key$1,
				value
			});
		}
		return ParseStatus.mergeObjectSync(status$1, syncPairs);
	}
	static mergeObjectSync(status$1, pairs) {
		const finalObject = {};
		for (const pair of pairs) {
			const { key: key$1, value } = pair;
			if (key$1.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key$1.status === "dirty") status$1.dirty();
			if (value.status === "dirty") status$1.dirty();
			if (key$1.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) finalObject[key$1.value] = value.value;
		}
		return {
			status: status$1.value,
			value: finalObject
		};
	}
};
const INVALID = Object.freeze({ status: "aborted" });
const DIRTY = (value) => ({
	status: "dirty",
	value
});
const OK = (value) => ({
	status: "valid",
	value
});
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil$1) {
	errorUtil$1.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	errorUtil$1.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

//#endregion
//#region node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
	constructor(parent, value, path, key$1) {
		this._cachedPath = [];
		this.parent = parent;
		this.data = value;
		this._path = path;
		this._key = key$1;
	}
	get path() {
		if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
		else this._cachedPath.push(...this._path, this._key);
		return this._cachedPath;
	}
};
const handleResult = (ctx, result) => {
	if (isValid(result)) return {
		success: true,
		data: result.value
	};
	else {
		if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
		return {
			success: false,
			get error() {
				if (this._error) return this._error;
				this._error = new ZodError(ctx.common.issues);
				return this._error;
			}
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	const { errorMap: errorMap$1, invalid_type_error, required_error, description } = params;
	if (errorMap$1 && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	if (errorMap$1) return {
		errorMap: errorMap$1,
		description
	};
	const customMap = (iss, ctx) => {
		const { message } = params;
		if (iss.code === "invalid_enum_value") return { message: message ?? ctx.defaultError };
		if (typeof ctx.data === "undefined") return { message: message ?? required_error ?? ctx.defaultError };
		if (iss.code !== "invalid_type") return { message: ctx.defaultError };
		return { message: message ?? invalid_type_error ?? ctx.defaultError };
	};
	return {
		errorMap: customMap,
		description
	};
}
var ZodType = class {
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return ctx || {
			common: input.parent.common,
			data: input.data,
			parsedType: getParsedType(input.data),
			schemaErrorMap: this._def.errorMap,
			path: input.path,
			parent: input.parent
		};
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent
			}
		};
	}
	_parseSync(input) {
		const result = this._parse(input);
		if (isAsync(result)) throw new Error("Synchronous parse encountered promise.");
		return result;
	}
	_parseAsync(input) {
		const result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data, params) {
		const result = this.safeParse(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data, params) {
		const ctx = {
			common: {
				issues: [],
				async: params?.async ?? false,
				contextualErrorMap: params?.errorMap
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		const result = this._parseSync({
			data,
			path: ctx.path,
			parent: ctx
		});
		return handleResult(ctx, result);
	}
	"~validate"(data) {
		const ctx = {
			common: {
				issues: [],
				async: !!this["~standard"].async
			},
			path: [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		if (!this["~standard"].async) try {
			const result = this._parseSync({
				data,
				path: [],
				parent: ctx
			});
			return isValid(result) ? { value: result.value } : { issues: ctx.common.issues };
		} catch (err) {
			if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
			ctx.common = {
				issues: [],
				async: true
			};
		}
		return this._parseAsync({
			data,
			path: [],
			parent: ctx
		}).then((result) => isValid(result) ? { value: result.value } : { issues: ctx.common.issues });
	}
	async parseAsync(data, params) {
		const result = await this.safeParseAsync(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data, params) {
		const ctx = {
			common: {
				issues: [],
				contextualErrorMap: params?.errorMap,
				async: true
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data)
		};
		const maybeAsyncResult = this._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
		const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
		return handleResult(ctx, result);
	}
	refine(check, message) {
		const getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined") return { message };
			else if (typeof message === "function") return message(val);
			else return message;
		};
		return this._refinement((val, ctx) => {
			const result = check(val);
			const setError = () => ctx.addIssue({
				code: ZodIssueCode.custom,
				...getIssueProperties(val)
			});
			if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data) => {
				if (!data) {
					setError();
					return false;
				} else return true;
			});
			if (!result) {
				setError();
				return false;
			} else return true;
		});
	}
	refinement(check, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check(val)) {
				ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
				return false;
			} else return true;
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "refinement",
				refinement
			}
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	constructor(def) {
		/** Alias of safeParseAsync */
		this.spa = this.safeParseAsync;
		this._def = def;
		this.parse = this.parse.bind(this);
		this.safeParse = this.safeParse.bind(this);
		this.parseAsync = this.parseAsync.bind(this);
		this.safeParseAsync = this.safeParseAsync.bind(this);
		this.spa = this.spa.bind(this);
		this.refine = this.refine.bind(this);
		this.refinement = this.refinement.bind(this);
		this.superRefine = this.superRefine.bind(this);
		this.optional = this.optional.bind(this);
		this.nullable = this.nullable.bind(this);
		this.nullish = this.nullish.bind(this);
		this.array = this.array.bind(this);
		this.promise = this.promise.bind(this);
		this.or = this.or.bind(this);
		this.and = this.and.bind(this);
		this.transform = this.transform.bind(this);
		this.brand = this.brand.bind(this);
		this.default = this.default.bind(this);
		this.catch = this.catch.bind(this);
		this.describe = this.describe.bind(this);
		this.pipe = this.pipe.bind(this);
		this.readonly = this.readonly.bind(this);
		this.isNullable = this.isNullable.bind(this);
		this.isOptional = this.isOptional.bind(this);
		this["~standard"] = {
			version: 1,
			vendor: "zod",
			validate: (data) => this["~validate"](data)
		};
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: {
				type: "transform",
				transform
			}
		});
	}
	default(def) {
		const defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def)
		});
	}
	catch(def) {
		const catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch
		});
	}
	describe(description) {
		const This = this.constructor;
		return new This({
			...this._def,
			description
		});
	}
	pipe(target) {
		return ZodPipeline.create(this, target);
	}
	readonly() {
		return ZodReadonly.create(this);
	}
	isOptional() {
		return this.safeParse(void 0).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
};
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex$1 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = /* @__PURE__ */ new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
	let secondsRegexSource = `[0-5]\\d`;
	if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
	else if (args.precision == null) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
	const secondsQuantifier = args.precision ? "+" : "?";
	return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
	return /* @__PURE__ */ new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
	let regex$1 = `${dateRegexSource}T${timeRegexSource(args)}`;
	const opts = [];
	opts.push(args.local ? `Z?` : `Z`);
	if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
	regex$1 = `${regex$1}(${opts.join("|")})`;
	return /* @__PURE__ */ new RegExp(`^${regex$1}$`);
}
function isValidIP(ip, version) {
	if ((version === "v4" || !version) && ipv4Regex.test(ip)) return true;
	if ((version === "v6" || !version) && ipv6Regex.test(ip)) return true;
	return false;
}
function isValidJWT(jwt, alg) {
	if (!jwtRegex.test(jwt)) return false;
	try {
		const [header] = jwt.split(".");
		if (!header) return false;
		const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
		const decoded = JSON.parse(atob(base64));
		if (typeof decoded !== "object" || decoded === null) return false;
		if ("typ" in decoded && decoded?.typ !== "JWT") return false;
		if (!decoded.alg) return false;
		if (alg && decoded.alg !== alg) return false;
		return true;
	} catch {
		return false;
	}
}
function isValidCidr(ip, version) {
	if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) return true;
	if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) return true;
	return false;
}
var ZodString = class ZodString extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = String(input.data);
		if (this._getType(input) !== ZodParsedType.string) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.string,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const status$1 = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.length < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.length > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: false,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "length") {
			const tooBig = input.data.length > check.value;
			const tooSmall = input.data.length < check.value;
			if (tooBig || tooSmall) {
				ctx = this._getOrReturnCtx(input, ctx);
				if (tooBig) addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				else if (tooSmall) addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "string",
					inclusive: true,
					exact: true,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "email") {
			if (!emailRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "email",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "emoji") {
			if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
			if (!emojiRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "emoji",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "uuid") {
			if (!uuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "uuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "nanoid") {
			if (!nanoidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "nanoid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "cuid") {
			if (!cuidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "cuid2") {
			if (!cuid2Regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cuid2",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "ulid") {
			if (!ulidRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ulid",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "url") try {
			new URL(input.data);
		} catch {
			ctx = this._getOrReturnCtx(input, ctx);
			addIssueToContext(ctx, {
				validation: "url",
				code: ZodIssueCode.invalid_string,
				message: check.message
			});
			status$1.dirty();
		}
		else if (check.kind === "regex") {
			check.regex.lastIndex = 0;
			if (!check.regex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "regex",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "trim") input.data = input.data.trim();
		else if (check.kind === "includes") {
			if (!input.data.includes(check.value, check.position)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: {
						includes: check.value,
						position: check.position
					},
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
		else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
		else if (check.kind === "startsWith") {
			if (!input.data.startsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { startsWith: check.value },
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "endsWith") {
			if (!input.data.endsWith(check.value)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: { endsWith: check.value },
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "datetime") {
			if (!datetimeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "datetime",
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "date") {
			if (!dateRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "date",
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "time") {
			if (!timeRegex(check).test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_string,
					validation: "time",
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "duration") {
			if (!durationRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "duration",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "ip") {
			if (!isValidIP(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "ip",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "jwt") {
			if (!isValidJWT(input.data, check.alg)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "jwt",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "cidr") {
			if (!isValidCidr(input.data, check.version)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "cidr",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "base64") {
			if (!base64Regex$1.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "base64",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "base64url") {
			if (!base64urlRegex.test(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					validation: "base64url",
					code: ZodIssueCode.invalid_string,
					message: check.message
				});
				status$1.dirty();
			}
		} else util$6.assertNever(check);
		return {
			status: status$1.value,
			value: input.data
		};
	}
	_regex(regex$1, validation, message) {
		return this.refinement((data) => regex$1.test(data), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message)
		});
	}
	_addCheck(check) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	email(message) {
		return this._addCheck({
			kind: "email",
			...errorUtil.errToObj(message)
		});
	}
	url(message) {
		return this._addCheck({
			kind: "url",
			...errorUtil.errToObj(message)
		});
	}
	emoji(message) {
		return this._addCheck({
			kind: "emoji",
			...errorUtil.errToObj(message)
		});
	}
	uuid(message) {
		return this._addCheck({
			kind: "uuid",
			...errorUtil.errToObj(message)
		});
	}
	nanoid(message) {
		return this._addCheck({
			kind: "nanoid",
			...errorUtil.errToObj(message)
		});
	}
	cuid(message) {
		return this._addCheck({
			kind: "cuid",
			...errorUtil.errToObj(message)
		});
	}
	cuid2(message) {
		return this._addCheck({
			kind: "cuid2",
			...errorUtil.errToObj(message)
		});
	}
	ulid(message) {
		return this._addCheck({
			kind: "ulid",
			...errorUtil.errToObj(message)
		});
	}
	base64(message) {
		return this._addCheck({
			kind: "base64",
			...errorUtil.errToObj(message)
		});
	}
	base64url(message) {
		return this._addCheck({
			kind: "base64url",
			...errorUtil.errToObj(message)
		});
	}
	jwt(options) {
		return this._addCheck({
			kind: "jwt",
			...errorUtil.errToObj(options)
		});
	}
	ip(options) {
		return this._addCheck({
			kind: "ip",
			...errorUtil.errToObj(options)
		});
	}
	cidr(options) {
		return this._addCheck({
			kind: "cidr",
			...errorUtil.errToObj(options)
		});
	}
	datetime(options) {
		if (typeof options === "string") return this._addCheck({
			kind: "datetime",
			precision: null,
			offset: false,
			local: false,
			message: options
		});
		return this._addCheck({
			kind: "datetime",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			offset: options?.offset ?? false,
			local: options?.local ?? false,
			...errorUtil.errToObj(options?.message)
		});
	}
	date(message) {
		return this._addCheck({
			kind: "date",
			message
		});
	}
	time(options) {
		if (typeof options === "string") return this._addCheck({
			kind: "time",
			precision: null,
			message: options
		});
		return this._addCheck({
			kind: "time",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			...errorUtil.errToObj(options?.message)
		});
	}
	duration(message) {
		return this._addCheck({
			kind: "duration",
			...errorUtil.errToObj(message)
		});
	}
	regex(regex$1, message) {
		return this._addCheck({
			kind: "regex",
			regex: regex$1,
			...errorUtil.errToObj(message)
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position: options?.position,
			...errorUtil.errToObj(options?.message)
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message)
		});
	}
	min(minLength, message) {
		return this._addCheck({
			kind: "min",
			value: minLength,
			...errorUtil.errToObj(message)
		});
	}
	max(maxLength, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength,
			...errorUtil.errToObj(message)
		});
	}
	length(len, message) {
		return this._addCheck({
			kind: "length",
			value: len,
			...errorUtil.errToObj(message)
		});
	}
	/**
	* Equivalent to `.min(1)`
	*/
	nonempty(message) {
		return this.min(1, errorUtil.errToObj(message));
	}
	trim() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }]
		});
	}
	toLowerCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }]
		});
	}
	toUpperCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }]
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isDate() {
		return !!this._def.checks.find((ch) => ch.kind === "date");
	}
	get isTime() {
		return !!this._def.checks.find((ch) => ch.kind === "time");
	}
	get isDuration() {
		return !!this._def.checks.find((ch) => ch.kind === "duration");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isNANOID() {
		return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get isCIDR() {
		return !!this._def.checks.find((ch) => ch.kind === "cidr");
	}
	get isBase64() {
		return !!this._def.checks.find((ch) => ch.kind === "base64");
	}
	get isBase64url() {
		return !!this._def.checks.find((ch) => ch.kind === "base64url");
	}
	get minLength() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxLength() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodString.create = (params) => {
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
	const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
	return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
		this.step = this.multipleOf;
	}
	_parse(input) {
		if (this._def.coerce) input.data = Number(input.data);
		if (this._getType(input) !== ZodParsedType.number) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.number,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		let ctx = void 0;
		const status$1 = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "int") {
			if (!util$6.isInteger(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_type,
					expected: "integer",
					received: "float",
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: check.value,
					type: "number",
					inclusive: check.inclusive,
					exact: false,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (floatSafeRemainder(input.data, check.value) !== 0) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "finite") {
			if (!Number.isFinite(input.data)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_finite,
					message: check.message
				});
				status$1.dirty();
			}
		} else util$6.assertNever(check);
		return {
			status: status$1.value,
			value: input.data
		};
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message)
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message)
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: true,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message)
		})._addCheck({
			kind: "max",
			inclusive: true,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
	get isInt() {
		return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util$6.isInteger(ch.value));
	}
	get isFinite() {
		let max = null;
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
		else if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		} else if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return Number.isFinite(min) && Number.isFinite(max);
	}
};
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodBigInt = class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
	}
	_parse(input) {
		if (this._def.coerce) try {
			input.data = BigInt(input.data);
		} catch {
			return this._getInvalidInput(input);
		}
		if (this._getType(input) !== ZodParsedType.bigint) return this._getInvalidInput(input);
		let ctx = void 0;
		const status$1 = new ParseStatus();
		for (const check of this._def.checks) if (check.kind === "min") {
			if (check.inclusive ? input.data < check.value : input.data <= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					type: "bigint",
					minimum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "max") {
			if (check.inclusive ? input.data > check.value : input.data >= check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					type: "bigint",
					maximum: check.value,
					inclusive: check.inclusive,
					message: check.message
				});
				status$1.dirty();
			}
		} else if (check.kind === "multipleOf") {
			if (input.data % check.value !== BigInt(0)) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.not_multiple_of,
					multipleOf: check.value,
					message: check.message
				});
				status$1.dirty();
			}
		} else util$6.assertNever(check);
		return {
			status: status$1.value,
			value: input.data
		};
	}
	_getInvalidInput(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.bigint,
			received: ctx.parsedType
		});
		return INVALID;
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, {
				kind,
				value,
				inclusive,
				message: errorUtil.toString(message)
			}]
		});
	}
	_addCheck(check) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message)
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message)
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message)
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max;
	}
};
ZodBigInt.create = (params) => {
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce: params?.coerce ?? false,
		...processCreateParams(params)
	});
};
var ZodBoolean = class extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = Boolean(input.data);
		if (this._getType(input) !== ZodParsedType.boolean) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.boolean,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce: params?.coerce || false,
		...processCreateParams(params)
	});
};
var ZodDate = class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) input.data = new Date(input.data);
		if (this._getType(input) !== ZodParsedType.date) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.date,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		if (Number.isNaN(input.data.getTime())) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, { code: ZodIssueCode.invalid_date });
			return INVALID;
		}
		const status$1 = new ParseStatus();
		let ctx = void 0;
		for (const check of this._def.checks) if (check.kind === "min") {
			if (input.data.getTime() < check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					message: check.message,
					inclusive: true,
					exact: false,
					minimum: check.value,
					type: "date"
				});
				status$1.dirty();
			}
		} else if (check.kind === "max") {
			if (input.data.getTime() > check.value) {
				ctx = this._getOrReturnCtx(input, ctx);
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					message: check.message,
					inclusive: true,
					exact: false,
					maximum: check.value,
					type: "date"
				});
				status$1.dirty();
			}
		} else util$6.assertNever(check);
		return {
			status: status$1.value,
			value: new Date(input.data.getTime())
		};
	}
	_addCheck(check) {
		return new ZodDate({
			...this._def,
			checks: [...this._def.checks, check]
		});
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message)
		});
	}
	get minDate() {
		let min = null;
		for (const ch of this._def.checks) if (ch.kind === "min") {
			if (min === null || ch.value > min) min = ch.value;
		}
		return min != null ? new Date(min) : null;
	}
	get maxDate() {
		let max = null;
		for (const ch of this._def.checks) if (ch.kind === "max") {
			if (max === null || ch.value < max) max = ch.value;
		}
		return max != null ? new Date(max) : null;
	}
};
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce: params?.coerce || false,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params)
	});
};
var ZodSymbol = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.symbol) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.symbol,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params)
	});
};
var ZodUndefined = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.undefined,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params)
	});
};
var ZodNull = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.null) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.null,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params)
	});
};
var ZodAny = class extends ZodType {
	constructor() {
		super(...arguments);
		this._any = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params)
	});
};
var ZodUnknown = class extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = true;
	}
	_parse(input) {
		return OK(input.data);
	}
};
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params)
	});
};
var ZodNever = class extends ZodType {
	_parse(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.never,
			received: ctx.parsedType
		});
		return INVALID;
	}
};
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params)
	});
};
var ZodVoid = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.void,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return OK(input.data);
	}
};
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params)
	});
};
var ZodArray = class ZodArray extends ZodType {
	_parse(input) {
		const { ctx, status: status$1 } = this._processInputParams(input);
		const def = this._def;
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (def.exactLength !== null) {
			const tooBig = ctx.data.length > def.exactLength.value;
			const tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall) {
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : void 0,
					maximum: tooBig ? def.exactLength.value : void 0,
					type: "array",
					inclusive: true,
					exact: true,
					message: def.exactLength.message
				});
				status$1.dirty();
			}
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.minLength.message
				});
				status$1.dirty();
			}
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.maxLength.message
				});
				status$1.dirty();
			}
		}
		if (ctx.common.async) return Promise.all([...ctx.data].map((item, i$3) => {
			return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i$3));
		})).then((result$1) => {
			return ParseStatus.mergeArray(status$1, result$1);
		});
		const result = [...ctx.data].map((item, i$3) => {
			return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i$3));
		});
		return ParseStatus.mergeArray(status$1, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength, message) {
		return new ZodArray({
			...this._def,
			minLength: {
				value: minLength,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxLength, message) {
		return new ZodArray({
			...this._def,
			maxLength: {
				value: maxLength,
				message: errorUtil.toString(message)
			}
		});
	}
	length(len, message) {
		return new ZodArray({
			...this._def,
			exactLength: {
				value: len,
				message: errorUtil.toString(message)
			}
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params)
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		const newShape = {};
		for (const key$1 in schema.shape) {
			const fieldSchema = schema.shape[key$1];
			newShape[key$1] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({
			...schema._def,
			shape: () => newShape
		});
	} else if (schema instanceof ZodArray) return new ZodArray({
		...schema._def,
		type: deepPartialify(schema.element)
	});
	else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
	else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	else return schema;
}
var ZodObject = class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		this._cached = null;
		/**
		* @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
		* If you want to pass through unknown properties, use `.passthrough()` instead.
		*/
		this.nonstrict = this.passthrough;
		/**
		* @deprecated Use `.extend` instead
		*  */
		this.augment = this.extend;
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		const shape = this._def.shape();
		const keys = util$6.objectKeys(shape);
		this._cached = {
			shape,
			keys
		};
		return this._cached;
	}
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.object) {
			const ctx$1 = this._getOrReturnCtx(input);
			addIssueToContext(ctx$1, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx$1.parsedType
			});
			return INVALID;
		}
		const { status: status$1, ctx } = this._processInputParams(input);
		const { shape, keys: shapeKeys } = this._getCached();
		const extraKeys = [];
		if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
			for (const key$1 in ctx.data) if (!shapeKeys.includes(key$1)) extraKeys.push(key$1);
		}
		const pairs = [];
		for (const key$1 of shapeKeys) {
			const keyValidator = shape[key$1];
			const value = ctx.data[key$1];
			pairs.push({
				key: {
					status: "valid",
					value: key$1
				},
				value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key$1)),
				alwaysSet: key$1 in ctx.data
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			const unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough") for (const key$1 of extraKeys) pairs.push({
				key: {
					status: "valid",
					value: key$1
				},
				value: {
					status: "valid",
					value: ctx.data[key$1]
				}
			});
			else if (unknownKeys === "strict") {
				if (extraKeys.length > 0) {
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys
					});
					status$1.dirty();
				}
			} else if (unknownKeys === "strip") {} else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
		} else {
			const catchall = this._def.catchall;
			for (const key$1 of extraKeys) {
				const value = ctx.data[key$1];
				pairs.push({
					key: {
						status: "valid",
						value: key$1
					},
					value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key$1)),
					alwaysSet: key$1 in ctx.data
				});
			}
		}
		if (ctx.common.async) return Promise.resolve().then(async () => {
			const syncPairs = [];
			for (const pair of pairs) {
				const key$1 = await pair.key;
				const value = await pair.value;
				syncPairs.push({
					key: key$1,
					value,
					alwaysSet: pair.alwaysSet
				});
			}
			return syncPairs;
		}).then((syncPairs) => {
			return ParseStatus.mergeObjectSync(status$1, syncPairs);
		});
		else return ParseStatus.mergeObjectSync(status$1, pairs);
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		errorUtil.errToObj;
		return new ZodObject({
			...this._def,
			unknownKeys: "strict",
			...message !== void 0 ? { errorMap: (issue, ctx) => {
				const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
				if (issue.code === "unrecognized_keys") return { message: errorUtil.errToObj(message).message ?? defaultError };
				return { message: defaultError };
			} } : {}
		});
	}
	strip() {
		return new ZodObject({
			...this._def,
			unknownKeys: "strip"
		});
	}
	passthrough() {
		return new ZodObject({
			...this._def,
			unknownKeys: "passthrough"
		});
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({
				...this._def.shape(),
				...augmentation
			})
		});
	}
	/**
	* Prior to zod@1.0.12 there was a bug in the
	* inferred type of merged objects. Please
	* upgrade if you are experiencing issues.
	*/
	merge(merging) {
		return new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({
				...this._def.shape(),
				...merging._def.shape()
			}),
			typeName: ZodFirstPartyTypeKind.ZodObject
		});
	}
	setKey(key$1, schema) {
		return this.augment({ [key$1]: schema });
	}
	catchall(index) {
		return new ZodObject({
			...this._def,
			catchall: index
		});
	}
	pick(mask) {
		const shape = {};
		for (const key$1 of util$6.objectKeys(mask)) if (mask[key$1] && this.shape[key$1]) shape[key$1] = this.shape[key$1];
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	omit(mask) {
		const shape = {};
		for (const key$1 of util$6.objectKeys(this.shape)) if (!mask[key$1]) shape[key$1] = this.shape[key$1];
		return new ZodObject({
			...this._def,
			shape: () => shape
		});
	}
	/**
	* @deprecated
	*/
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask) {
		const newShape = {};
		for (const key$1 of util$6.objectKeys(this.shape)) {
			const fieldSchema = this.shape[key$1];
			if (mask && !mask[key$1]) newShape[key$1] = fieldSchema;
			else newShape[key$1] = fieldSchema.optional();
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	required(mask) {
		const newShape = {};
		for (const key$1 of util$6.objectKeys(this.shape)) if (mask && !mask[key$1]) newShape[key$1] = this.shape[key$1];
		else {
			let newField = this.shape[key$1];
			while (newField instanceof ZodOptional) newField = newField._def.innerType;
			newShape[key$1] = newField;
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape
		});
	}
	keyof() {
		return createZodEnum(util$6.objectKeys(this.shape));
	}
};
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params)
	});
};
var ZodUnion = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const options = this._def.options;
		function handleResults(results) {
			for (const result of results) if (result.result.status === "valid") return result.result;
			for (const result of results) if (result.result.status === "dirty") {
				ctx.common.issues.push(...result.ctx.common.issues);
				return result.result;
			}
			const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
		if (ctx.common.async) return Promise.all(options.map(async (option) => {
			const childCtx = {
				...ctx,
				common: {
					...ctx.common,
					issues: []
				},
				parent: null
			};
			return {
				result: await option._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				}),
				ctx: childCtx
			};
		})).then(handleResults);
		else {
			let dirty = void 0;
			const issues = [];
			for (const option of options) {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: []
					},
					parent: null
				};
				const result = option._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx
				});
				if (result.status === "valid") return result;
				else if (result.status === "dirty" && !dirty) dirty = {
					result,
					ctx: childCtx
				};
				if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
			}
			if (dirty) {
				ctx.common.issues.push(...dirty.ctx.common.issues);
				return dirty.result;
			}
			const unionErrors = issues.map((issues$1) => new ZodError(issues$1));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors
			});
			return INVALID;
		}
	}
	get options() {
		return this._def.options;
	}
};
ZodUnion.create = (types, params) => {
	return new ZodUnion({
		options: types,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params)
	});
};
const getDiscriminator = (type) => {
	if (type instanceof ZodLazy) return getDiscriminator(type.schema);
	else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
	else if (type instanceof ZodLiteral) return [type.value];
	else if (type instanceof ZodEnum) return type.options;
	else if (type instanceof ZodNativeEnum) return util$6.objectValues(type.enum);
	else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
	else if (type instanceof ZodUndefined) return [void 0];
	else if (type instanceof ZodNull) return [null];
	else if (type instanceof ZodOptional) return [void 0, ...getDiscriminator(type.unwrap())];
	else if (type instanceof ZodNullable) return [null, ...getDiscriminator(type.unwrap())];
	else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
	else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
	else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
	else return [];
};
var ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const discriminator = this.discriminator;
		const discriminatorValue = ctx.data[discriminator];
		const option = this.optionsMap.get(discriminatorValue);
		if (!option) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union_discriminator,
				options: Array.from(this.optionsMap.keys()),
				path: [discriminator]
			});
			return INVALID;
		}
		if (ctx.common.async) return option._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
		else return option._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	/**
	* The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	* However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	* have a different value for each object in the union.
	* @param discriminator the name of the discriminator property
	* @param types an array of object schemas
	* @param params
	*/
	static create(discriminator, options, params) {
		const optionsMap = /* @__PURE__ */ new Map();
		for (const type of options) {
			const discriminatorValues = getDiscriminator(type.shape[discriminator]);
			if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
			for (const value of discriminatorValues) {
				if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
				optionsMap.set(value, type);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params)
		});
	}
};
function mergeValues(a, b) {
	const aType = getParsedType(a);
	const bType = getParsedType(b);
	if (a === b) return {
		valid: true,
		data: a
	};
	else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		const bKeys = util$6.objectKeys(b);
		const sharedKeys = util$6.objectKeys(a).filter((key$1) => bKeys.indexOf(key$1) !== -1);
		const newObj = {
			...a,
			...b
		};
		for (const key$1 of sharedKeys) {
			const sharedValue = mergeValues(a[key$1], b[key$1]);
			if (!sharedValue.valid) return { valid: false };
			newObj[key$1] = sharedValue.data;
		}
		return {
			valid: true,
			data: newObj
		};
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a.length !== b.length) return { valid: false };
		const newArray = [];
		for (let index = 0; index < a.length; index++) {
			const itemA = a[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) return { valid: false };
			newArray.push(sharedValue.data);
		}
		return {
			valid: true,
			data: newArray
		};
	} else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) return {
		valid: true,
		data: a
	};
	else return { valid: false };
}
var ZodIntersection = class extends ZodType {
	_parse(input) {
		const { status: status$1, ctx } = this._processInputParams(input);
		const handleParsed = (parsedLeft, parsedRight) => {
			if (isAborted(parsedLeft) || isAborted(parsedRight)) return INVALID;
			const merged = mergeValues(parsedLeft.value, parsedRight.value);
			if (!merged.valid) {
				addIssueToContext(ctx, { code: ZodIssueCode.invalid_intersection_types });
				return INVALID;
			}
			if (isDirty(parsedLeft) || isDirty(parsedRight)) status$1.dirty();
			return {
				status: status$1.value,
				value: merged.data
			};
		};
		if (ctx.common.async) return Promise.all([this._def.left._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		})]).then(([left, right]) => handleParsed(left, right));
		else return handleParsed(this._def.left._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}), this._def.right._parseSync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}));
	}
};
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params)
	});
};
var ZodTuple = class ZodTuple extends ZodType {
	_parse(input) {
		const { status: status$1, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType
			});
			return INVALID;
		}
		if (ctx.data.length < this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_small,
				minimum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			return INVALID;
		}
		if (!this._def.rest && ctx.data.length > this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array"
			});
			status$1.dirty();
		}
		const items = [...ctx.data].map((item, itemIndex) => {
			const schema = this._def.items[itemIndex] || this._def.rest;
			if (!schema) return null;
			return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
		}).filter((x) => !!x);
		if (ctx.common.async) return Promise.all(items).then((results) => {
			return ParseStatus.mergeArray(status$1, results);
		});
		else return ParseStatus.mergeArray(status$1, items);
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({
			...this._def,
			rest
		});
	}
};
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params)
	});
};
var ZodRecord = class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status: status$1, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const pairs = [];
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		for (const key$1 in ctx.data) pairs.push({
			key: keyType._parse(new ParseInputLazyPath(ctx, key$1, ctx.path, key$1)),
			value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key$1], ctx.path, key$1)),
			alwaysSet: key$1 in ctx.data
		});
		if (ctx.common.async) return ParseStatus.mergeObjectAsync(status$1, pairs);
		else return ParseStatus.mergeObjectSync(status$1, pairs);
	}
	get element() {
		return this._def.valueType;
	}
	static create(first, second, third) {
		if (second instanceof ZodType) return new ZodRecord({
			keyType: first,
			valueType: second,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(third)
		});
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second)
		});
	}
};
var ZodMap = class extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status: status$1, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.map,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		const pairs = [...ctx.data.entries()].map(([key$1, value], index) => {
			return {
				key: keyType._parse(new ParseInputLazyPath(ctx, key$1, ctx.path, [index, "key"])),
				value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
			};
		});
		if (ctx.common.async) {
			const finalMap = /* @__PURE__ */ new Map();
			return Promise.resolve().then(async () => {
				for (const pair of pairs) {
					const key$1 = await pair.key;
					const value = await pair.value;
					if (key$1.status === "aborted" || value.status === "aborted") return INVALID;
					if (key$1.status === "dirty" || value.status === "dirty") status$1.dirty();
					finalMap.set(key$1.value, value.value);
				}
				return {
					status: status$1.value,
					value: finalMap
				};
			});
		} else {
			const finalMap = /* @__PURE__ */ new Map();
			for (const pair of pairs) {
				const key$1 = pair.key;
				const value = pair.value;
				if (key$1.status === "aborted" || value.status === "aborted") return INVALID;
				if (key$1.status === "dirty" || value.status === "dirty") status$1.dirty();
				finalMap.set(key$1.value, value.value);
			}
			return {
				status: status$1.value,
				value: finalMap
			};
		}
	}
};
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params)
	});
};
var ZodSet = class ZodSet extends ZodType {
	_parse(input) {
		const { status: status$1, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.set,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.minSize.message
				});
				status$1.dirty();
			}
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.maxSize.message
				});
				status$1.dirty();
			}
		}
		const valueType = this._def.valueType;
		function finalizeSet(elements$1) {
			const parsedSet = /* @__PURE__ */ new Set();
			for (const element of elements$1) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status$1.dirty();
				parsedSet.add(element.value);
			}
			return {
				status: status$1.value,
				value: parsedSet
			};
		}
		const elements = [...ctx.data.values()].map((item, i$3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i$3)));
		if (ctx.common.async) return Promise.all(elements).then((elements$1) => finalizeSet(elements$1));
		else return finalizeSet(elements);
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: {
				value: minSize,
				message: errorUtil.toString(message)
			}
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: {
				value: maxSize,
				message: errorUtil.toString(message)
			}
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
};
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params)
	});
};
var ZodFunction = class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.function,
				received: ctx.parsedType
			});
			return INVALID;
		}
		function makeArgsIssue(args, error) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error
				}
			});
		}
		function makeReturnsIssue(returns, error) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error
				}
			});
		}
		const params = { errorMap: ctx.common.contextualErrorMap };
		const fn = ctx.data;
		if (this._def.returns instanceof ZodPromise) {
			const me = this;
			return OK(async function(...args) {
				const error = new ZodError([]);
				const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
					error.addIssue(makeArgsIssue(args, e));
					throw error;
				});
				const result = await Reflect.apply(fn, this, parsedArgs);
				return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
					error.addIssue(makeReturnsIssue(result, e));
					throw error;
				});
			});
		} else {
			const me = this;
			return OK(function(...args) {
				const parsedArgs = me._def.args.safeParse(args, params);
				if (!parsedArgs.success) throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
				const result = Reflect.apply(fn, this, parsedArgs.data);
				const parsedReturns = me._def.returns.safeParse(result, params);
				if (!parsedReturns.success) throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
				return parsedReturns.data;
			});
		}
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create())
		});
	}
	returns(returnType) {
		return new ZodFunction({
			...this._def,
			returns: returnType
		});
	}
	implement(func) {
		return this.parse(func);
	}
	strictImplement(func) {
		return this.parse(func);
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params)
		});
	}
};
var ZodLazy = class extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		return this._def.getter()._parse({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		});
	}
};
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params)
	});
};
var ZodLiteral = class extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_literal,
				expected: this._def.value
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
	get value() {
		return this._def.value;
	}
};
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params)
	});
};
function createZodEnum(values, params) {
	return new ZodEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params)
	});
}
var ZodEnum = class ZodEnum extends ZodType {
	_parse(input) {
		if (typeof input.data !== "string") {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				expected: util$6.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) this._cache = new Set(this._def.values);
		if (!this._cache.has(input.data)) {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Values() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	get Enum() {
		const enumValues = {};
		for (const val of this._def.values) enumValues[val] = val;
		return enumValues;
	}
	extract(values, newDef = this._def) {
		return ZodEnum.create(values, {
			...this._def,
			...newDef
		});
	}
	exclude(values, newDef = this._def) {
		return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
			...this._def,
			...newDef
		});
	}
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
	_parse(input) {
		const nativeEnumValues = util$6.getValidEnumValues(this._def.values);
		const ctx = this._getOrReturnCtx(input);
		if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
			const expectedValues = util$6.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				expected: util$6.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type
			});
			return INVALID;
		}
		if (!this._cache) this._cache = new Set(util$6.getValidEnumValues(this._def.values));
		if (!this._cache.has(input.data)) {
			const expectedValues = util$6.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
};
ZodNativeEnum.create = (values, params) => {
	return new ZodNativeEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params)
	});
};
var ZodPromise = class extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.promise,
				received: ctx.parsedType
			});
			return INVALID;
		}
		const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
		return OK(promisified.then((data) => {
			return this._def.type.parseAsync(data, {
				path: ctx.path,
				errorMap: ctx.common.contextualErrorMap
			});
		}));
	}
};
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params)
	});
};
var ZodEffects = class extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
	}
	_parse(input) {
		const { status: status$1, ctx } = this._processInputParams(input);
		const effect = this._def.effect || null;
		const checkCtx = {
			addIssue: (arg) => {
				addIssueToContext(ctx, arg);
				if (arg.fatal) status$1.abort();
				else status$1.dirty();
			},
			get path() {
				return ctx.path;
			}
		};
		checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
		if (effect.type === "preprocess") {
			const processed = effect.transform(ctx.data, checkCtx);
			if (ctx.common.async) return Promise.resolve(processed).then(async (processed$1) => {
				if (status$1.value === "aborted") return INVALID;
				const result = await this._def.schema._parseAsync({
					data: processed$1,
					path: ctx.path,
					parent: ctx
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status$1.value === "dirty") return DIRTY(result.value);
				return result;
			});
			else {
				if (status$1.value === "aborted") return INVALID;
				const result = this._def.schema._parseSync({
					data: processed,
					path: ctx.path,
					parent: ctx
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status$1.value === "dirty") return DIRTY(result.value);
				return result;
			}
		}
		if (effect.type === "refinement") {
			const executeRefinement = (acc) => {
				const result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) return Promise.resolve(result);
				if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
				return acc;
			};
			if (ctx.common.async === false) {
				const inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status$1.dirty();
				executeRefinement(inner.value);
				return {
					status: status$1.value,
					value: inner.value
				};
			} else return this._def.schema._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			}).then((inner) => {
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status$1.dirty();
				return executeRefinement(inner.value).then(() => {
					return {
						status: status$1.value,
						value: inner.value
					};
				});
			});
		}
		if (effect.type === "transform") if (ctx.common.async === false) {
			const base = this._def.schema._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (!isValid(base)) return INVALID;
			const result = effect.transform(base.value, checkCtx);
			if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
			return {
				status: status$1.value,
				value: result
			};
		} else return this._def.schema._parseAsync({
			data: ctx.data,
			path: ctx.path,
			parent: ctx
		}).then((base) => {
			if (!isValid(base)) return INVALID;
			return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
				status: status$1.value,
				value: result
			}));
		});
		util$6.assertNever(effect);
	}
};
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params)
	});
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	return new ZodEffects({
		schema,
		effect: {
			type: "preprocess",
			transform: preprocess
		},
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params)
	});
};
var ZodOptional = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.undefined) return OK(void 0);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodOptional.create = (type, params) => {
	return new ZodOptional({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params)
	});
};
var ZodNullable = class extends ZodType {
	_parse(input) {
		if (this._getType(input) === ZodParsedType.null) return OK(null);
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodNullable.create = (type, params) => {
	return new ZodNullable({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params)
	});
};
var ZodDefault = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		let data = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined) data = this._def.defaultValue();
		return this._def.innerType._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	removeDefault() {
		return this._def.innerType;
	}
};
ZodDefault.create = (type, params) => {
	return new ZodDefault({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue: typeof params.default === "function" ? params.default : () => params.default,
		...processCreateParams(params)
	});
};
var ZodCatch = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const newCtx = {
			...ctx,
			common: {
				...ctx.common,
				issues: []
			}
		};
		const result = this._def.innerType._parse({
			data: newCtx.data,
			path: newCtx.path,
			parent: { ...newCtx }
		});
		if (isAsync(result)) return result.then((result$1) => {
			return {
				status: "valid",
				value: result$1.status === "valid" ? result$1.value : this._def.catchValue({
					get error() {
						return new ZodError(newCtx.common.issues);
					},
					input: newCtx.data
				})
			};
		});
		else return {
			status: "valid",
			value: result.status === "valid" ? result.value : this._def.catchValue({
				get error() {
					return new ZodError(newCtx.common.issues);
				},
				input: newCtx.data
			})
		};
	}
	removeCatch() {
		return this._def.innerType;
	}
};
ZodCatch.create = (type, params) => {
	return new ZodCatch({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params)
	});
};
var ZodNaN = class extends ZodType {
	_parse(input) {
		if (this._getType(input) !== ZodParsedType.nan) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.nan,
				received: ctx.parsedType
			});
			return INVALID;
		}
		return {
			status: "valid",
			value: input.data
		};
	}
};
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params)
	});
};
const BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const data = ctx.data;
		return this._def.type._parse({
			data,
			path: ctx.path,
			parent: ctx
		});
	}
	unwrap() {
		return this._def.type;
	}
};
var ZodPipeline = class ZodPipeline extends ZodType {
	_parse(input) {
		const { status: status$1, ctx } = this._processInputParams(input);
		if (ctx.common.async) {
			const handleAsync = async () => {
				const inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty") {
					status$1.dirty();
					return DIRTY(inResult.value);
				} else return this._def.out._parseAsync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx
				});
			};
			return handleAsync();
		} else {
			const inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty") {
				status$1.dirty();
				return {
					status: "dirty",
					value: inResult.value
				};
			} else return this._def.out._parseSync({
				data: inResult.value,
				path: ctx.path,
				parent: ctx
			});
		}
	}
	static create(a, b) {
		return new ZodPipeline({
			in: a,
			out: b,
			typeName: ZodFirstPartyTypeKind.ZodPipeline
		});
	}
};
var ZodReadonly = class extends ZodType {
	_parse(input) {
		const result = this._def.innerType._parse(input);
		const freeze = (data) => {
			if (isValid(data)) data.value = Object.freeze(data.value);
			return data;
		};
		return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
	}
	unwrap() {
		return this._def.innerType;
	}
};
ZodReadonly.create = (type, params) => {
	return new ZodReadonly({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodReadonly,
		...processCreateParams(params)
	});
};
const late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind$1) {
	ZodFirstPartyTypeKind$1["ZodString"] = "ZodString";
	ZodFirstPartyTypeKind$1["ZodNumber"] = "ZodNumber";
	ZodFirstPartyTypeKind$1["ZodNaN"] = "ZodNaN";
	ZodFirstPartyTypeKind$1["ZodBigInt"] = "ZodBigInt";
	ZodFirstPartyTypeKind$1["ZodBoolean"] = "ZodBoolean";
	ZodFirstPartyTypeKind$1["ZodDate"] = "ZodDate";
	ZodFirstPartyTypeKind$1["ZodSymbol"] = "ZodSymbol";
	ZodFirstPartyTypeKind$1["ZodUndefined"] = "ZodUndefined";
	ZodFirstPartyTypeKind$1["ZodNull"] = "ZodNull";
	ZodFirstPartyTypeKind$1["ZodAny"] = "ZodAny";
	ZodFirstPartyTypeKind$1["ZodUnknown"] = "ZodUnknown";
	ZodFirstPartyTypeKind$1["ZodNever"] = "ZodNever";
	ZodFirstPartyTypeKind$1["ZodVoid"] = "ZodVoid";
	ZodFirstPartyTypeKind$1["ZodArray"] = "ZodArray";
	ZodFirstPartyTypeKind$1["ZodObject"] = "ZodObject";
	ZodFirstPartyTypeKind$1["ZodUnion"] = "ZodUnion";
	ZodFirstPartyTypeKind$1["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	ZodFirstPartyTypeKind$1["ZodIntersection"] = "ZodIntersection";
	ZodFirstPartyTypeKind$1["ZodTuple"] = "ZodTuple";
	ZodFirstPartyTypeKind$1["ZodRecord"] = "ZodRecord";
	ZodFirstPartyTypeKind$1["ZodMap"] = "ZodMap";
	ZodFirstPartyTypeKind$1["ZodSet"] = "ZodSet";
	ZodFirstPartyTypeKind$1["ZodFunction"] = "ZodFunction";
	ZodFirstPartyTypeKind$1["ZodLazy"] = "ZodLazy";
	ZodFirstPartyTypeKind$1["ZodLiteral"] = "ZodLiteral";
	ZodFirstPartyTypeKind$1["ZodEnum"] = "ZodEnum";
	ZodFirstPartyTypeKind$1["ZodEffects"] = "ZodEffects";
	ZodFirstPartyTypeKind$1["ZodNativeEnum"] = "ZodNativeEnum";
	ZodFirstPartyTypeKind$1["ZodOptional"] = "ZodOptional";
	ZodFirstPartyTypeKind$1["ZodNullable"] = "ZodNullable";
	ZodFirstPartyTypeKind$1["ZodDefault"] = "ZodDefault";
	ZodFirstPartyTypeKind$1["ZodCatch"] = "ZodCatch";
	ZodFirstPartyTypeKind$1["ZodPromise"] = "ZodPromise";
	ZodFirstPartyTypeKind$1["ZodBranded"] = "ZodBranded";
	ZodFirstPartyTypeKind$1["ZodPipeline"] = "ZodPipeline";
	ZodFirstPartyTypeKind$1["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const NEVER = INVALID;

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.18.1/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
const LATEST_PROTOCOL_VERSION = "2025-06-18";
const DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
const SUPPORTED_PROTOCOL_VERSIONS = [
	LATEST_PROTOCOL_VERSION,
	"2025-03-26",
	"2024-11-05",
	"2024-10-07"
];
const JSONRPC_VERSION = "2.0";
/**
* A progress token, used to associate progress notifications with the original request.
*/
const ProgressTokenSchema = unionType([stringType(), numberType().int()]);
/**
* An opaque token used to represent a cursor for pagination.
*/
const CursorSchema = stringType();
const RequestMetaSchema = objectType({ progressToken: optionalType(ProgressTokenSchema) }).passthrough();
const BaseRequestParamsSchema = objectType({ _meta: optionalType(RequestMetaSchema) }).passthrough();
const RequestSchema = objectType({
	method: stringType(),
	params: optionalType(BaseRequestParamsSchema)
});
const BaseNotificationParamsSchema = objectType({ _meta: optionalType(objectType({}).passthrough()) }).passthrough();
const NotificationSchema = objectType({
	method: stringType(),
	params: optionalType(BaseNotificationParamsSchema)
});
const ResultSchema = objectType({ _meta: optionalType(objectType({}).passthrough()) }).passthrough();
/**
* A uniquely identifying ID for a request in JSON-RPC.
*/
const RequestIdSchema = unionType([stringType(), numberType().int()]);
/**
* A request that expects a response.
*/
const JSONRPCRequestSchema = objectType({
	jsonrpc: literalType(JSONRPC_VERSION),
	id: RequestIdSchema
}).merge(RequestSchema).strict();
const isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
/**
* A notification which does not expect a response.
*/
const JSONRPCNotificationSchema = objectType({ jsonrpc: literalType(JSONRPC_VERSION) }).merge(NotificationSchema).strict();
const isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
/**
* A successful (non-error) response to a request.
*/
const JSONRPCResponseSchema = objectType({
	jsonrpc: literalType(JSONRPC_VERSION),
	id: RequestIdSchema,
	result: ResultSchema
}).strict();
const isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;
/**
* Error codes defined by the JSON-RPC specification.
*/
var ErrorCode;
(function(ErrorCode$1) {
	ErrorCode$1[ErrorCode$1["ConnectionClosed"] = -32e3] = "ConnectionClosed";
	ErrorCode$1[ErrorCode$1["RequestTimeout"] = -32001] = "RequestTimeout";
	ErrorCode$1[ErrorCode$1["ParseError"] = -32700] = "ParseError";
	ErrorCode$1[ErrorCode$1["InvalidRequest"] = -32600] = "InvalidRequest";
	ErrorCode$1[ErrorCode$1["MethodNotFound"] = -32601] = "MethodNotFound";
	ErrorCode$1[ErrorCode$1["InvalidParams"] = -32602] = "InvalidParams";
	ErrorCode$1[ErrorCode$1["InternalError"] = -32603] = "InternalError";
})(ErrorCode || (ErrorCode = {}));
/**
* A response to a request that indicates an error occurred.
*/
const JSONRPCErrorSchema = objectType({
	jsonrpc: literalType(JSONRPC_VERSION),
	id: RequestIdSchema,
	error: objectType({
		code: numberType().int(),
		message: stringType(),
		data: optionalType(unknownType())
	})
}).strict();
const isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;
const JSONRPCMessageSchema = unionType([
	JSONRPCRequestSchema,
	JSONRPCNotificationSchema,
	JSONRPCResponseSchema,
	JSONRPCErrorSchema
]);
/**
* A response that indicates success but carries no data.
*/
const EmptyResultSchema = ResultSchema.strict();
/**
* This notification can be sent by either side to indicate that it is cancelling a previously-issued request.
*
* The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.
*
* This notification indicates that the result will be unused, so any associated processing SHOULD cease.
*
* A client MUST NOT attempt to cancel its `initialize` request.
*/
const CancelledNotificationSchema = NotificationSchema.extend({
	method: literalType("notifications/cancelled"),
	params: BaseNotificationParamsSchema.extend({
		requestId: RequestIdSchema,
		reason: stringType().optional()
	})
});
/**
* Icon schema for use in tools, prompts, resources, and implementations.
*/
const IconSchema = objectType({
	src: stringType(),
	mimeType: optionalType(stringType()),
	sizes: optionalType(stringType())
}).passthrough();
/**
* Base metadata interface for common properties across resources, tools, prompts, and implementations.
*/
const BaseMetadataSchema = objectType({
	name: stringType(),
	title: optionalType(stringType())
}).passthrough();
/**
* Describes the name and version of an MCP implementation.
*/
const ImplementationSchema = BaseMetadataSchema.extend({
	version: stringType(),
	websiteUrl: optionalType(stringType()),
	icons: optionalType(arrayType(IconSchema))
});
/**
* Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.
*/
const ClientCapabilitiesSchema = objectType({
	experimental: optionalType(objectType({}).passthrough()),
	sampling: optionalType(objectType({}).passthrough()),
	elicitation: optionalType(objectType({}).passthrough()),
	roots: optionalType(objectType({ listChanged: optionalType(booleanType()) }).passthrough())
}).passthrough();
/**
* This request is sent from the client to the server when it first connects, asking it to begin initialization.
*/
const InitializeRequestSchema = RequestSchema.extend({
	method: literalType("initialize"),
	params: BaseRequestParamsSchema.extend({
		protocolVersion: stringType(),
		capabilities: ClientCapabilitiesSchema,
		clientInfo: ImplementationSchema
	})
});
const isInitializeRequest = (value) => InitializeRequestSchema.safeParse(value).success;
/**
* Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.
*/
const ServerCapabilitiesSchema = objectType({
	experimental: optionalType(objectType({}).passthrough()),
	logging: optionalType(objectType({}).passthrough()),
	completions: optionalType(objectType({}).passthrough()),
	prompts: optionalType(objectType({ listChanged: optionalType(booleanType()) }).passthrough()),
	resources: optionalType(objectType({
		subscribe: optionalType(booleanType()),
		listChanged: optionalType(booleanType())
	}).passthrough()),
	tools: optionalType(objectType({ listChanged: optionalType(booleanType()) }).passthrough())
}).passthrough();
/**
* After receiving an initialize request from the client, the server sends this response.
*/
const InitializeResultSchema = ResultSchema.extend({
	protocolVersion: stringType(),
	capabilities: ServerCapabilitiesSchema,
	serverInfo: ImplementationSchema,
	instructions: optionalType(stringType())
});
/**
* This notification is sent from the client to the server after initialization has finished.
*/
const InitializedNotificationSchema = NotificationSchema.extend({ method: literalType("notifications/initialized") });
const isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
/**
* A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.
*/
const PingRequestSchema = RequestSchema.extend({ method: literalType("ping") });
const ProgressSchema = objectType({
	progress: numberType(),
	total: optionalType(numberType()),
	message: optionalType(stringType())
}).passthrough();
/**
* An out-of-band notification used to inform the receiver of a progress update for a long-running request.
*/
const ProgressNotificationSchema = NotificationSchema.extend({
	method: literalType("notifications/progress"),
	params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({ progressToken: ProgressTokenSchema })
});
const PaginatedRequestSchema = RequestSchema.extend({ params: BaseRequestParamsSchema.extend({ cursor: optionalType(CursorSchema) }).optional() });
const PaginatedResultSchema = ResultSchema.extend({ nextCursor: optionalType(CursorSchema) });
/**
* The contents of a specific resource or sub-resource.
*/
const ResourceContentsSchema = objectType({
	uri: stringType(),
	mimeType: optionalType(stringType()),
	_meta: optionalType(objectType({}).passthrough())
}).passthrough();
const TextResourceContentsSchema = ResourceContentsSchema.extend({ text: stringType() });
/**
* A Zod schema for validating Base64 strings that is more performant and
* robust for very large inputs than the default regex-based check. It avoids
* stack overflows by using the native `atob` function for validation.
*/
const Base64Schema = stringType().refine((val) => {
	try {
		atob(val);
		return true;
	} catch (_a) {
		return false;
	}
}, { message: "Invalid Base64 string" });
const BlobResourceContentsSchema = ResourceContentsSchema.extend({ blob: Base64Schema });
/**
* A known resource that the server is capable of reading.
*/
const ResourceSchema = BaseMetadataSchema.extend({
	uri: stringType(),
	description: optionalType(stringType()),
	mimeType: optionalType(stringType()),
	icons: optionalType(arrayType(IconSchema)),
	_meta: optionalType(objectType({}).passthrough())
});
/**
* A template description for resources available on the server.
*/
const ResourceTemplateSchema = BaseMetadataSchema.extend({
	uriTemplate: stringType(),
	description: optionalType(stringType()),
	mimeType: optionalType(stringType()),
	_meta: optionalType(objectType({}).passthrough())
});
/**
* Sent from the client to request a list of resources the server has.
*/
const ListResourcesRequestSchema = PaginatedRequestSchema.extend({ method: literalType("resources/list") });
/**
* The server's response to a resources/list request from the client.
*/
const ListResourcesResultSchema = PaginatedResultSchema.extend({ resources: arrayType(ResourceSchema) });
/**
* Sent from the client to request a list of resource templates the server has.
*/
const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({ method: literalType("resources/templates/list") });
/**
* The server's response to a resources/templates/list request from the client.
*/
const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({ resourceTemplates: arrayType(ResourceTemplateSchema) });
/**
* Sent from the client to the server, to read a specific resource URI.
*/
const ReadResourceRequestSchema = RequestSchema.extend({
	method: literalType("resources/read"),
	params: BaseRequestParamsSchema.extend({ uri: stringType() })
});
/**
* The server's response to a resources/read request from the client.
*/
const ReadResourceResultSchema = ResultSchema.extend({ contents: arrayType(unionType([TextResourceContentsSchema, BlobResourceContentsSchema])) });
/**
* An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.
*/
const ResourceListChangedNotificationSchema = NotificationSchema.extend({ method: literalType("notifications/resources/list_changed") });
/**
* Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.
*/
const SubscribeRequestSchema = RequestSchema.extend({
	method: literalType("resources/subscribe"),
	params: BaseRequestParamsSchema.extend({ uri: stringType() })
});
/**
* Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.
*/
const UnsubscribeRequestSchema = RequestSchema.extend({
	method: literalType("resources/unsubscribe"),
	params: BaseRequestParamsSchema.extend({ uri: stringType() })
});
/**
* A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.
*/
const ResourceUpdatedNotificationSchema = NotificationSchema.extend({
	method: literalType("notifications/resources/updated"),
	params: BaseNotificationParamsSchema.extend({ uri: stringType() })
});
/**
* Describes an argument that a prompt can accept.
*/
const PromptArgumentSchema = objectType({
	name: stringType(),
	description: optionalType(stringType()),
	required: optionalType(booleanType())
}).passthrough();
/**
* A prompt or prompt template that the server offers.
*/
const PromptSchema = BaseMetadataSchema.extend({
	description: optionalType(stringType()),
	arguments: optionalType(arrayType(PromptArgumentSchema)),
	icons: optionalType(arrayType(IconSchema)),
	_meta: optionalType(objectType({}).passthrough())
});
/**
* Sent from the client to request a list of prompts and prompt templates the server has.
*/
const ListPromptsRequestSchema = PaginatedRequestSchema.extend({ method: literalType("prompts/list") });
/**
* The server's response to a prompts/list request from the client.
*/
const ListPromptsResultSchema = PaginatedResultSchema.extend({ prompts: arrayType(PromptSchema) });
/**
* Used by the client to get a prompt provided by the server.
*/
const GetPromptRequestSchema = RequestSchema.extend({
	method: literalType("prompts/get"),
	params: BaseRequestParamsSchema.extend({
		name: stringType(),
		arguments: optionalType(recordType(stringType()))
	})
});
/**
* Text provided to or from an LLM.
*/
const TextContentSchema = objectType({
	type: literalType("text"),
	text: stringType(),
	_meta: optionalType(objectType({}).passthrough())
}).passthrough();
/**
* An image provided to or from an LLM.
*/
const ImageContentSchema = objectType({
	type: literalType("image"),
	data: Base64Schema,
	mimeType: stringType(),
	_meta: optionalType(objectType({}).passthrough())
}).passthrough();
/**
* An Audio provided to or from an LLM.
*/
const AudioContentSchema = objectType({
	type: literalType("audio"),
	data: Base64Schema,
	mimeType: stringType(),
	_meta: optionalType(objectType({}).passthrough())
}).passthrough();
/**
* The contents of a resource, embedded into a prompt or tool call result.
*/
const EmbeddedResourceSchema = objectType({
	type: literalType("resource"),
	resource: unionType([TextResourceContentsSchema, BlobResourceContentsSchema]),
	_meta: optionalType(objectType({}).passthrough())
}).passthrough();
/**
* A resource that the server is capable of reading, included in a prompt or tool call result.
*
* Note: resource links returned by tools are not guaranteed to appear in the results of `resources/list` requests.
*/
const ResourceLinkSchema = ResourceSchema.extend({ type: literalType("resource_link") });
/**
* A content block that can be used in prompts and tool results.
*/
const ContentBlockSchema = unionType([
	TextContentSchema,
	ImageContentSchema,
	AudioContentSchema,
	ResourceLinkSchema,
	EmbeddedResourceSchema
]);
/**
* Describes a message returned as part of a prompt.
*/
const PromptMessageSchema = objectType({
	role: enumType(["user", "assistant"]),
	content: ContentBlockSchema
}).passthrough();
/**
* The server's response to a prompts/get request from the client.
*/
const GetPromptResultSchema = ResultSchema.extend({
	description: optionalType(stringType()),
	messages: arrayType(PromptMessageSchema)
});
/**
* An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.
*/
const PromptListChangedNotificationSchema = NotificationSchema.extend({ method: literalType("notifications/prompts/list_changed") });
/**
* Additional properties describing a Tool to clients.
*
* NOTE: all properties in ToolAnnotations are **hints**.
* They are not guaranteed to provide a faithful description of
* tool behavior (including descriptive properties like `title`).
*
* Clients should never make tool use decisions based on ToolAnnotations
* received from untrusted servers.
*/
const ToolAnnotationsSchema = objectType({
	title: optionalType(stringType()),
	readOnlyHint: optionalType(booleanType()),
	destructiveHint: optionalType(booleanType()),
	idempotentHint: optionalType(booleanType()),
	openWorldHint: optionalType(booleanType())
}).passthrough();
/**
* Definition for a tool the client can call.
*/
const ToolSchema = BaseMetadataSchema.extend({
	description: optionalType(stringType()),
	inputSchema: objectType({
		type: literalType("object"),
		properties: optionalType(objectType({}).passthrough()),
		required: optionalType(arrayType(stringType()))
	}).passthrough(),
	outputSchema: optionalType(objectType({
		type: literalType("object"),
		properties: optionalType(objectType({}).passthrough()),
		required: optionalType(arrayType(stringType()))
	}).passthrough()),
	annotations: optionalType(ToolAnnotationsSchema),
	icons: optionalType(arrayType(IconSchema)),
	_meta: optionalType(objectType({}).passthrough())
});
/**
* Sent from the client to request a list of tools the server has.
*/
const ListToolsRequestSchema = PaginatedRequestSchema.extend({ method: literalType("tools/list") });
/**
* The server's response to a tools/list request from the client.
*/
const ListToolsResultSchema = PaginatedResultSchema.extend({ tools: arrayType(ToolSchema) });
/**
* The server's response to a tool call.
*/
const CallToolResultSchema = ResultSchema.extend({
	content: arrayType(ContentBlockSchema).default([]),
	structuredContent: objectType({}).passthrough().optional(),
	isError: optionalType(booleanType())
});
/**
* CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.
*/
const CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({ toolResult: unknownType() }));
/**
* Used by the client to invoke a tool provided by the server.
*/
const CallToolRequestSchema = RequestSchema.extend({
	method: literalType("tools/call"),
	params: BaseRequestParamsSchema.extend({
		name: stringType(),
		arguments: optionalType(recordType(unknownType()))
	})
});
/**
* An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.
*/
const ToolListChangedNotificationSchema = NotificationSchema.extend({ method: literalType("notifications/tools/list_changed") });
/**
* The severity of a log message.
*/
const LoggingLevelSchema = enumType([
	"debug",
	"info",
	"notice",
	"warning",
	"error",
	"critical",
	"alert",
	"emergency"
]);
/**
* A request from the client to the server, to enable or adjust logging.
*/
const SetLevelRequestSchema = RequestSchema.extend({
	method: literalType("logging/setLevel"),
	params: BaseRequestParamsSchema.extend({ level: LoggingLevelSchema })
});
/**
* Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.
*/
const LoggingMessageNotificationSchema = NotificationSchema.extend({
	method: literalType("notifications/message"),
	params: BaseNotificationParamsSchema.extend({
		level: LoggingLevelSchema,
		logger: optionalType(stringType()),
		data: unknownType()
	})
});
/**
* Hints to use for model selection.
*/
const ModelHintSchema = objectType({ name: stringType().optional() }).passthrough();
/**
* The server's preferences for model selection, requested of the client during sampling.
*/
const ModelPreferencesSchema = objectType({
	hints: optionalType(arrayType(ModelHintSchema)),
	costPriority: optionalType(numberType().min(0).max(1)),
	speedPriority: optionalType(numberType().min(0).max(1)),
	intelligencePriority: optionalType(numberType().min(0).max(1))
}).passthrough();
/**
* Describes a message issued to or received from an LLM API.
*/
const SamplingMessageSchema = objectType({
	role: enumType(["user", "assistant"]),
	content: unionType([
		TextContentSchema,
		ImageContentSchema,
		AudioContentSchema
	])
}).passthrough();
/**
* A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.
*/
const CreateMessageRequestSchema = RequestSchema.extend({
	method: literalType("sampling/createMessage"),
	params: BaseRequestParamsSchema.extend({
		messages: arrayType(SamplingMessageSchema),
		systemPrompt: optionalType(stringType()),
		includeContext: optionalType(enumType([
			"none",
			"thisServer",
			"allServers"
		])),
		temperature: optionalType(numberType()),
		maxTokens: numberType().int(),
		stopSequences: optionalType(arrayType(stringType())),
		metadata: optionalType(objectType({}).passthrough()),
		modelPreferences: optionalType(ModelPreferencesSchema)
	})
});
/**
* The client's response to a sampling/create_message request from the server. The client should inform the user before returning the sampled message, to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.
*/
const CreateMessageResultSchema = ResultSchema.extend({
	model: stringType(),
	stopReason: optionalType(enumType([
		"endTurn",
		"stopSequence",
		"maxTokens"
	]).or(stringType())),
	role: enumType(["user", "assistant"]),
	content: discriminatedUnionType("type", [
		TextContentSchema,
		ImageContentSchema,
		AudioContentSchema
	])
});
/**
* Primitive schema definition for boolean fields.
*/
const BooleanSchemaSchema = objectType({
	type: literalType("boolean"),
	title: optionalType(stringType()),
	description: optionalType(stringType()),
	default: optionalType(booleanType())
}).passthrough();
/**
* Primitive schema definition for string fields.
*/
const StringSchemaSchema = objectType({
	type: literalType("string"),
	title: optionalType(stringType()),
	description: optionalType(stringType()),
	minLength: optionalType(numberType()),
	maxLength: optionalType(numberType()),
	format: optionalType(enumType([
		"email",
		"uri",
		"date",
		"date-time"
	]))
}).passthrough();
/**
* Primitive schema definition for number fields.
*/
const NumberSchemaSchema = objectType({
	type: enumType(["number", "integer"]),
	title: optionalType(stringType()),
	description: optionalType(stringType()),
	minimum: optionalType(numberType()),
	maximum: optionalType(numberType())
}).passthrough();
/**
* Primitive schema definition for enum fields.
*/
const EnumSchemaSchema = objectType({
	type: literalType("string"),
	title: optionalType(stringType()),
	description: optionalType(stringType()),
	enum: arrayType(stringType()),
	enumNames: optionalType(arrayType(stringType()))
}).passthrough();
/**
* Union of all primitive schema definitions.
*/
const PrimitiveSchemaDefinitionSchema = unionType([
	BooleanSchemaSchema,
	StringSchemaSchema,
	NumberSchemaSchema,
	EnumSchemaSchema
]);
/**
* A request from the server to elicit user input via the client.
* The client should present the message and form fields to the user.
*/
const ElicitRequestSchema = RequestSchema.extend({
	method: literalType("elicitation/create"),
	params: BaseRequestParamsSchema.extend({
		message: stringType(),
		requestedSchema: objectType({
			type: literalType("object"),
			properties: recordType(stringType(), PrimitiveSchemaDefinitionSchema),
			required: optionalType(arrayType(stringType()))
		}).passthrough()
	})
});
/**
* The client's response to an elicitation/create request from the server.
*/
const ElicitResultSchema = ResultSchema.extend({
	action: enumType([
		"accept",
		"decline",
		"cancel"
	]),
	content: optionalType(recordType(stringType(), unknownType()))
});
/**
* A reference to a resource or resource template definition.
*/
const ResourceTemplateReferenceSchema = objectType({
	type: literalType("ref/resource"),
	uri: stringType()
}).passthrough();
/**
* Identifies a prompt.
*/
const PromptReferenceSchema = objectType({
	type: literalType("ref/prompt"),
	name: stringType()
}).passthrough();
/**
* A request from the client to the server, to ask for completion options.
*/
const CompleteRequestSchema = RequestSchema.extend({
	method: literalType("completion/complete"),
	params: BaseRequestParamsSchema.extend({
		ref: unionType([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
		argument: objectType({
			name: stringType(),
			value: stringType()
		}).passthrough(),
		context: optionalType(objectType({ arguments: optionalType(recordType(stringType(), stringType())) }))
	})
});
/**
* The server's response to a completion/complete request
*/
const CompleteResultSchema = ResultSchema.extend({ completion: objectType({
	values: arrayType(stringType()).max(100),
	total: optionalType(numberType().int()),
	hasMore: optionalType(booleanType())
}).passthrough() });
/**
* Represents a root directory or file that the server can operate on.
*/
const RootSchema = objectType({
	uri: stringType().startsWith("file://"),
	name: optionalType(stringType()),
	_meta: optionalType(objectType({}).passthrough())
}).passthrough();
/**
* Sent from the server to request a list of root URIs from the client.
*/
const ListRootsRequestSchema = RequestSchema.extend({ method: literalType("roots/list") });
/**
* The client's response to a roots/list request from the server.
*/
const ListRootsResultSchema = ResultSchema.extend({ roots: arrayType(RootSchema) });
/**
* A notification from the client to the server, informing it that the list of roots has changed.
*/
const RootsListChangedNotificationSchema = NotificationSchema.extend({ method: literalType("notifications/roots/list_changed") });
const ClientRequestSchema = unionType([
	PingRequestSchema,
	InitializeRequestSchema,
	CompleteRequestSchema,
	SetLevelRequestSchema,
	GetPromptRequestSchema,
	ListPromptsRequestSchema,
	ListResourcesRequestSchema,
	ListResourceTemplatesRequestSchema,
	ReadResourceRequestSchema,
	SubscribeRequestSchema,
	UnsubscribeRequestSchema,
	CallToolRequestSchema,
	ListToolsRequestSchema
]);
const ClientNotificationSchema = unionType([
	CancelledNotificationSchema,
	ProgressNotificationSchema,
	InitializedNotificationSchema,
	RootsListChangedNotificationSchema
]);
const ClientResultSchema = unionType([
	EmptyResultSchema,
	CreateMessageResultSchema,
	ElicitResultSchema,
	ListRootsResultSchema
]);
const ServerRequestSchema = unionType([
	PingRequestSchema,
	CreateMessageRequestSchema,
	ElicitRequestSchema,
	ListRootsRequestSchema
]);
const ServerNotificationSchema = unionType([
	CancelledNotificationSchema,
	ProgressNotificationSchema,
	LoggingMessageNotificationSchema,
	ResourceUpdatedNotificationSchema,
	ResourceListChangedNotificationSchema,
	ToolListChangedNotificationSchema,
	PromptListChangedNotificationSchema
]);
const ServerResultSchema = unionType([
	EmptyResultSchema,
	InitializeResultSchema,
	CompleteResultSchema,
	GetPromptResultSchema,
	ListPromptsResultSchema,
	ListResourcesResultSchema,
	ListResourceTemplatesResultSchema,
	ReadResourceResultSchema,
	CallToolResultSchema,
	ListToolsResultSchema
]);
var McpError = class extends Error {
	constructor(code, message, data) {
		super(`MCP error ${code}: ${message}`);
		this.code = code;
		this.data = data;
		this.name = "McpError";
	}
};

//#endregion
//#region src/proxyServer.ts
const proxyServer = async ({ client, requestTimeout, server, serverCapabilities }) => {
	if (serverCapabilities?.logging) {
		server.setNotificationHandler(LoggingMessageNotificationSchema, async (args) => {
			return client.notification(args);
		});
		client.setNotificationHandler(LoggingMessageNotificationSchema, async (args) => {
			return server.notification(args);
		});
	}
	if (serverCapabilities?.prompts) {
		server.setRequestHandler(GetPromptRequestSchema, async (args) => {
			return client.getPrompt(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ListPromptsRequestSchema, async (args) => {
			return client.listPrompts(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
	}
	if (serverCapabilities?.resources) {
		server.setRequestHandler(ListResourcesRequestSchema, async (args) => {
			return client.listResources(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ListResourceTemplatesRequestSchema, async (args) => {
			return client.listResourceTemplates(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ReadResourceRequestSchema, async (args) => {
			return client.readResource(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		if (serverCapabilities?.resources.subscribe) {
			server.setNotificationHandler(ResourceUpdatedNotificationSchema, async (args) => {
				return client.notification(args);
			});
			server.setRequestHandler(SubscribeRequestSchema, async (args) => {
				return client.subscribeResource(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
			});
			server.setRequestHandler(UnsubscribeRequestSchema, async (args) => {
				return client.unsubscribeResource(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
			});
		}
	}
	if (serverCapabilities?.tools) {
		server.setRequestHandler(CallToolRequestSchema, async (args) => {
			return client.callTool(args.params, void 0, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
		server.setRequestHandler(ListToolsRequestSchema, async (args) => {
			return client.listTools(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
		});
	}
	server.setRequestHandler(CompleteRequestSchema, async (args) => {
		return client.complete(args.params, requestTimeout ? { timeout: requestTimeout } : void 0);
	});
};

//#endregion
//#region node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js
var require_bytes = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = bytes$1;
	module.exports.format = format;
	module.exports.parse = parse$1;
	/**
	* Module variables.
	* @private
	*/
	var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
	var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
	var map = {
		b: 1,
		kb: 1024,
		mb: 1 << 20,
		gb: 1 << 30,
		tb: Math.pow(1024, 4),
		pb: Math.pow(1024, 5)
	};
	var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
	/**
	* Convert the given value in bytes into a string or parse to string to an integer in bytes.
	*
	* @param {string|number} value
	* @param {{
	*  case: [string],
	*  decimalPlaces: [number]
	*  fixedDecimals: [boolean]
	*  thousandsSeparator: [string]
	*  unitSeparator: [string]
	*  }} [options] bytes options.
	*
	* @returns {string|number|null}
	*/
	function bytes$1(value, options) {
		if (typeof value === "string") return parse$1(value);
		if (typeof value === "number") return format(value, options);
		return null;
	}
	/**
	* Format the given value in bytes into a string.
	*
	* If the value is negative, it is kept as such. If it is a float,
	* it is rounded.
	*
	* @param {number} value
	* @param {object} [options]
	* @param {number} [options.decimalPlaces=2]
	* @param {number} [options.fixedDecimals=false]
	* @param {string} [options.thousandsSeparator=]
	* @param {string} [options.unit=]
	* @param {string} [options.unitSeparator=]
	*
	* @returns {string|null}
	* @public
	*/
	function format(value, options) {
		if (!Number.isFinite(value)) return null;
		var mag = Math.abs(value);
		var thousandsSeparator = options && options.thousandsSeparator || "";
		var unitSeparator = options && options.unitSeparator || "";
		var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
		var fixedDecimals = Boolean(options && options.fixedDecimals);
		var unit = options && options.unit || "";
		if (!unit || !map[unit.toLowerCase()]) if (mag >= map.pb) unit = "PB";
		else if (mag >= map.tb) unit = "TB";
		else if (mag >= map.gb) unit = "GB";
		else if (mag >= map.mb) unit = "MB";
		else if (mag >= map.kb) unit = "KB";
		else unit = "B";
		var str = (value / map[unit.toLowerCase()]).toFixed(decimalPlaces);
		if (!fixedDecimals) str = str.replace(formatDecimalsRegExp, "$1");
		if (thousandsSeparator) str = str.split(".").map(function(s, i$3) {
			return i$3 === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
		}).join(".");
		return str + unitSeparator + unit;
	}
	/**
	* Parse the string value into an integer in bytes.
	*
	* If no unit is given, it is assumed the value is in bytes.
	*
	* @param {number|string} val
	*
	* @returns {number|null}
	* @public
	*/
	function parse$1(val) {
		if (typeof val === "number" && !isNaN(val)) return val;
		if (typeof val !== "string") return null;
		var results = parseRegExp.exec(val);
		var floatValue;
		var unit = "b";
		if (!results) {
			floatValue = parseInt(val, 10);
			unit = "b";
		} else {
			floatValue = parseFloat(results[1]);
			unit = results[4].toLowerCase();
		}
		if (isNaN(floatValue)) return null;
		return Math.floor(map[unit] * floatValue);
	}
}) });

//#endregion
//#region node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js
var require_depd = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js": ((exports, module) => {
	/*!
	* depd
	* Copyright(c) 2014-2018 Douglas Christopher Wilson
	* MIT Licensed
	*/
	/**
	* Module dependencies.
	*/
	var relative = __require("path").relative;
	/**
	* Module exports.
	*/
	module.exports = depd;
	/**
	* Get the path to base files on.
	*/
	var basePath = process.cwd();
	/**
	* Determine if namespace is contained in the string.
	*/
	function containsNamespace(str, namespace) {
		var vals = str.split(/[ ,]+/);
		var ns = String(namespace).toLowerCase();
		for (var i$3 = 0; i$3 < vals.length; i$3++) {
			var val = vals[i$3];
			if (val && (val === "*" || val.toLowerCase() === ns)) return true;
		}
		return false;
	}
	/**
	* Convert a data descriptor to accessor descriptor.
	*/
	function convertDataDescriptorToAccessor(obj, prop, message) {
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		var value = descriptor.value;
		descriptor.get = function getter() {
			return value;
		};
		if (descriptor.writable) descriptor.set = function setter(val) {
			return value = val;
		};
		delete descriptor.value;
		delete descriptor.writable;
		Object.defineProperty(obj, prop, descriptor);
		return descriptor;
	}
	/**
	* Create arguments string to keep arity.
	*/
	function createArgumentsString(arity) {
		var str = "";
		for (var i$3 = 0; i$3 < arity; i$3++) str += ", arg" + i$3;
		return str.substr(2);
	}
	/**
	* Create stack string from stack.
	*/
	function createStackString(stack) {
		var str = this.name + ": " + this.namespace;
		if (this.message) str += " deprecated " + this.message;
		for (var i$3 = 0; i$3 < stack.length; i$3++) str += "\n    at " + stack[i$3].toString();
		return str;
	}
	/**
	* Create deprecate for namespace in caller.
	*/
	function depd(namespace) {
		if (!namespace) throw new TypeError("argument namespace is required");
		var stack = getStack();
		var file = callSiteLocation(stack[1])[0];
		function deprecate$1(message) {
			log.call(deprecate$1, message);
		}
		deprecate$1._file = file;
		deprecate$1._ignored = isignored(namespace);
		deprecate$1._namespace = namespace;
		deprecate$1._traced = istraced(namespace);
		deprecate$1._warned = Object.create(null);
		deprecate$1.function = wrapfunction;
		deprecate$1.property = wrapproperty;
		return deprecate$1;
	}
	/**
	* Determine if event emitter has listeners of a given type.
	*
	* The way to do this check is done three different ways in Node.js >= 0.8
	* so this consolidates them into a minimal set using instance methods.
	*
	* @param {EventEmitter} emitter
	* @param {string} type
	* @returns {boolean}
	* @private
	*/
	function eehaslisteners(emitter, type) {
		return (typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type)) > 0;
	}
	/**
	* Determine if namespace is ignored.
	*/
	function isignored(namespace) {
		if (process.noDeprecation) return true;
		var str = process.env.NO_DEPRECATION || "";
		return containsNamespace(str, namespace);
	}
	/**
	* Determine if namespace is traced.
	*/
	function istraced(namespace) {
		if (process.traceDeprecation) return true;
		var str = process.env.TRACE_DEPRECATION || "";
		return containsNamespace(str, namespace);
	}
	/**
	* Display deprecation message.
	*/
	function log(message, site) {
		var haslisteners = eehaslisteners(process, "deprecation");
		if (!haslisteners && this._ignored) return;
		var caller;
		var callFile;
		var callSite;
		var depSite;
		var i$3 = 0;
		var seen = false;
		var stack = getStack();
		var file = this._file;
		if (site) {
			depSite = site;
			callSite = callSiteLocation(stack[1]);
			callSite.name = depSite.name;
			file = callSite[0];
		} else {
			i$3 = 2;
			depSite = callSiteLocation(stack[i$3]);
			callSite = depSite;
		}
		for (; i$3 < stack.length; i$3++) {
			caller = callSiteLocation(stack[i$3]);
			callFile = caller[0];
			if (callFile === file) seen = true;
			else if (callFile === this._file) file = this._file;
			else if (seen) break;
		}
		var key$1 = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
		if (key$1 !== void 0 && key$1 in this._warned) return;
		this._warned[key$1] = true;
		var msg = message;
		if (!msg) msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
		if (haslisteners) {
			var err = DeprecationError(this._namespace, msg, stack.slice(i$3));
			process.emit("deprecation", err);
			return;
		}
		var output = (process.stderr.isTTY ? formatColor : formatPlain).call(this, msg, caller, stack.slice(i$3));
		process.stderr.write(output + "\n", "utf8");
	}
	/**
	* Get call site location as array.
	*/
	function callSiteLocation(callSite) {
		var file = callSite.getFileName() || "<anonymous>";
		var line = callSite.getLineNumber();
		var colm = callSite.getColumnNumber();
		if (callSite.isEval()) file = callSite.getEvalOrigin() + ", " + file;
		var site = [
			file,
			line,
			colm
		];
		site.callSite = callSite;
		site.name = callSite.getFunctionName();
		return site;
	}
	/**
	* Generate a default message from the site.
	*/
	function defaultMessage(site) {
		var callSite = site.callSite;
		var funcName = site.name;
		if (!funcName) funcName = "<anonymous@" + formatLocation(site) + ">";
		var context = callSite.getThis();
		var typeName = context && callSite.getTypeName();
		if (typeName === "Object") typeName = void 0;
		if (typeName === "Function") typeName = context.name || typeName;
		return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
	}
	/**
	* Format deprecation message without color.
	*/
	function formatPlain(msg, caller, stack) {
		var formatted = (/* @__PURE__ */ new Date()).toUTCString() + " " + this._namespace + " deprecated " + msg;
		if (this._traced) {
			for (var i$3 = 0; i$3 < stack.length; i$3++) formatted += "\n    at " + stack[i$3].toString();
			return formatted;
		}
		if (caller) formatted += " at " + formatLocation(caller);
		return formatted;
	}
	/**
	* Format deprecation message with color.
	*/
	function formatColor(msg, caller, stack) {
		var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
		if (this._traced) {
			for (var i$3 = 0; i$3 < stack.length; i$3++) formatted += "\n    \x1B[36mat " + stack[i$3].toString() + "\x1B[39m";
			return formatted;
		}
		if (caller) formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
		return formatted;
	}
	/**
	* Format call site location.
	*/
	function formatLocation(callSite) {
		return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
	}
	/**
	* Get the stack as array of call sites.
	*/
	function getStack() {
		var limit = Error.stackTraceLimit;
		var obj = {};
		var prep = Error.prepareStackTrace;
		Error.prepareStackTrace = prepareObjectStackTrace;
		Error.stackTraceLimit = Math.max(10, limit);
		Error.captureStackTrace(obj);
		var stack = obj.stack.slice(1);
		Error.prepareStackTrace = prep;
		Error.stackTraceLimit = limit;
		return stack;
	}
	/**
	* Capture call site stack from v8.
	*/
	function prepareObjectStackTrace(obj, stack) {
		return stack;
	}
	/**
	* Return a wrapped function in a deprecation message.
	*/
	function wrapfunction(fn, message) {
		if (typeof fn !== "function") throw new TypeError("argument fn must be a function");
		var args = createArgumentsString(fn.length);
		var stack = getStack();
		var site = callSiteLocation(stack[1]);
		site.name = fn.name;
		return new Function("fn", "log", "deprecate", "message", "site", "\"use strict\"\nreturn function (" + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}")(fn, log, this, message, site);
	}
	/**
	* Wrap property in a deprecation message.
	*/
	function wrapproperty(obj, prop, message) {
		if (!obj || typeof obj !== "object" && typeof obj !== "function") throw new TypeError("argument obj must be object");
		var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
		if (!descriptor) throw new TypeError("must call property on owner object");
		if (!descriptor.configurable) throw new TypeError("property must be configurable");
		var deprecate$1 = this;
		var stack = getStack();
		var site = callSiteLocation(stack[1]);
		site.name = prop;
		if ("value" in descriptor) descriptor = convertDataDescriptorToAccessor(obj, prop, message);
		var get = descriptor.get;
		var set = descriptor.set;
		if (typeof get === "function") descriptor.get = function getter() {
			log.call(deprecate$1, message, site);
			return get.apply(this, arguments);
		};
		if (typeof set === "function") descriptor.set = function setter() {
			log.call(deprecate$1, message, site);
			return set.apply(this, arguments);
		};
		Object.defineProperty(obj, prop, descriptor);
	}
	/**
	* Create DeprecationError for deprecation
	*/
	function DeprecationError(namespace, message, stack) {
		var error = /* @__PURE__ */ new Error();
		var stackString;
		Object.defineProperty(error, "constructor", { value: DeprecationError });
		Object.defineProperty(error, "message", {
			configurable: true,
			enumerable: false,
			value: message,
			writable: true
		});
		Object.defineProperty(error, "name", {
			enumerable: false,
			configurable: true,
			value: "DeprecationError",
			writable: true
		});
		Object.defineProperty(error, "namespace", {
			configurable: true,
			enumerable: false,
			value: namespace,
			writable: true
		});
		Object.defineProperty(error, "stack", {
			configurable: true,
			enumerable: false,
			get: function() {
				if (stackString !== void 0) return stackString;
				return stackString = createStackString.call(this, stack);
			},
			set: function setter(val) {
				stackString = val;
			}
		});
		return error;
	}
}) });

//#endregion
//#region node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js
var require_setprototypeof = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/setprototypeof@1.2.0/node_modules/setprototypeof/index.js": ((exports, module) => {
	module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
	function setProtoOf(obj, proto) {
		obj.__proto__ = proto;
		return obj;
	}
	function mixinProperties(obj, proto) {
		for (var prop in proto) if (!Object.prototype.hasOwnProperty.call(obj, prop)) obj[prop] = proto[prop];
		return obj;
	}
}) });

//#endregion
//#region node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json
var require_codes = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/codes.json": ((exports, module) => {
	module.exports = {
		"100": "Continue",
		"101": "Switching Protocols",
		"102": "Processing",
		"103": "Early Hints",
		"200": "OK",
		"201": "Created",
		"202": "Accepted",
		"203": "Non-Authoritative Information",
		"204": "No Content",
		"205": "Reset Content",
		"206": "Partial Content",
		"207": "Multi-Status",
		"208": "Already Reported",
		"226": "IM Used",
		"300": "Multiple Choices",
		"301": "Moved Permanently",
		"302": "Found",
		"303": "See Other",
		"304": "Not Modified",
		"305": "Use Proxy",
		"307": "Temporary Redirect",
		"308": "Permanent Redirect",
		"400": "Bad Request",
		"401": "Unauthorized",
		"402": "Payment Required",
		"403": "Forbidden",
		"404": "Not Found",
		"405": "Method Not Allowed",
		"406": "Not Acceptable",
		"407": "Proxy Authentication Required",
		"408": "Request Timeout",
		"409": "Conflict",
		"410": "Gone",
		"411": "Length Required",
		"412": "Precondition Failed",
		"413": "Payload Too Large",
		"414": "URI Too Long",
		"415": "Unsupported Media Type",
		"416": "Range Not Satisfiable",
		"417": "Expectation Failed",
		"418": "I'm a Teapot",
		"421": "Misdirected Request",
		"422": "Unprocessable Entity",
		"423": "Locked",
		"424": "Failed Dependency",
		"425": "Too Early",
		"426": "Upgrade Required",
		"428": "Precondition Required",
		"429": "Too Many Requests",
		"431": "Request Header Fields Too Large",
		"451": "Unavailable For Legal Reasons",
		"500": "Internal Server Error",
		"501": "Not Implemented",
		"502": "Bad Gateway",
		"503": "Service Unavailable",
		"504": "Gateway Timeout",
		"505": "HTTP Version Not Supported",
		"506": "Variant Also Negotiates",
		"507": "Insufficient Storage",
		"508": "Loop Detected",
		"509": "Bandwidth Limit Exceeded",
		"510": "Not Extended",
		"511": "Network Authentication Required"
	};
}) });

//#endregion
//#region node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js
var require_statuses = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/statuses@2.0.1/node_modules/statuses/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var codes = require_codes();
	/**
	* Module exports.
	* @public
	*/
	module.exports = status;
	status.message = codes;
	status.code = createMessageToStatusCodeMap(codes);
	status.codes = createStatusCodeList(codes);
	status.redirect = {
		300: true,
		301: true,
		302: true,
		303: true,
		305: true,
		307: true,
		308: true
	};
	status.empty = {
		204: true,
		205: true,
		304: true
	};
	status.retry = {
		502: true,
		503: true,
		504: true
	};
	/**
	* Create a map of message to status code.
	* @private
	*/
	function createMessageToStatusCodeMap(codes$1) {
		var map$1 = {};
		Object.keys(codes$1).forEach(function forEachCode(code) {
			var message = codes$1[code];
			var status$1 = Number(code);
			map$1[message.toLowerCase()] = status$1;
		});
		return map$1;
	}
	/**
	* Create a list of all status codes.
	* @private
	*/
	function createStatusCodeList(codes$1) {
		return Object.keys(codes$1).map(function mapCode(code) {
			return Number(code);
		});
	}
	/**
	* Get the status code for given message.
	* @private
	*/
	function getStatusCode(message) {
		var msg = message.toLowerCase();
		if (!Object.prototype.hasOwnProperty.call(status.code, msg)) throw new Error("invalid status message: \"" + message + "\"");
		return status.code[msg];
	}
	/**
	* Get the status message for given code.
	* @private
	*/
	function getStatusMessage(code) {
		if (!Object.prototype.hasOwnProperty.call(status.message, code)) throw new Error("invalid status code: " + code);
		return status.message[code];
	}
	/**
	* Get the status code.
	*
	* Given a number, this will throw if it is not a known status
	* code, otherwise the code will be returned. Given a string,
	* the string will be parsed for a number and return the code
	* if valid, otherwise will lookup the code assuming this is
	* the status message.
	*
	* @param {string|number} code
	* @returns {number}
	* @public
	*/
	function status(code) {
		if (typeof code === "number") return getStatusMessage(code);
		if (typeof code !== "string") throw new TypeError("code must be a number or string");
		var n = parseInt(code, 10);
		if (!isNaN(n)) return getStatusMessage(n);
		return getStatusCode(code);
	}
}) });

//#endregion
//#region node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js": ((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits$1(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits$1(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}) });

//#endregion
//#region node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js": ((exports, module) => {
	try {
		var util$5 = __require("util");
		/* istanbul ignore next */
		if (typeof util$5.inherits !== "function") throw "";
		module.exports = util$5.inherits;
	} catch (e) {
		/* istanbul ignore next */
		module.exports = require_inherits_browser();
	}
}) });

//#endregion
//#region node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js
var require_toidentifier = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/toidentifier@1.0.1/node_modules/toidentifier/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = toIdentifier$1;
	/**
	* Trasform the given string into a JavaScript identifier
	*
	* @param {string} str
	* @returns {string}
	* @public
	*/
	function toIdentifier$1(str) {
		return str.split(" ").map(function(token) {
			return token.slice(0, 1).toUpperCase() + token.slice(1);
		}).join("").replace(/[^ _0-9a-z]/gi, "");
	}
}) });

//#endregion
//#region node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js
var require_http_errors = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/http-errors@2.0.0/node_modules/http-errors/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var deprecate = require_depd()("http-errors");
	var setPrototypeOf = require_setprototypeof();
	var statuses = require_statuses();
	var inherits = require_inherits();
	var toIdentifier = require_toidentifier();
	/**
	* Module exports.
	* @public
	*/
	module.exports = createError$1;
	module.exports.HttpError = createHttpErrorConstructor();
	module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
	populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
	/**
	* Get the code class of a status code.
	* @private
	*/
	function codeClass(status$1) {
		return Number(String(status$1).charAt(0) + "00");
	}
	/**
	* Create a new HTTP Error.
	*
	* @returns {Error}
	* @public
	*/
	function createError$1() {
		var err;
		var msg;
		var status$1 = 500;
		var props = {};
		for (var i$3 = 0; i$3 < arguments.length; i$3++) {
			var arg = arguments[i$3];
			var type = typeof arg;
			if (type === "object" && arg instanceof Error) {
				err = arg;
				status$1 = err.status || err.statusCode || status$1;
			} else if (type === "number" && i$3 === 0) status$1 = arg;
			else if (type === "string") msg = arg;
			else if (type === "object") props = arg;
			else throw new TypeError("argument #" + (i$3 + 1) + " unsupported type " + type);
		}
		if (typeof status$1 === "number" && (status$1 < 400 || status$1 >= 600)) deprecate("non-error status code; use only 4xx or 5xx status codes");
		if (typeof status$1 !== "number" || !statuses.message[status$1] && (status$1 < 400 || status$1 >= 600)) status$1 = 500;
		var HttpError = createError$1[status$1] || createError$1[codeClass(status$1)];
		if (!err) {
			err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status$1]);
			Error.captureStackTrace(err, createError$1);
		}
		if (!HttpError || !(err instanceof HttpError) || err.status !== status$1) {
			err.expose = status$1 < 500;
			err.status = err.statusCode = status$1;
		}
		for (var key$1 in props) if (key$1 !== "status" && key$1 !== "statusCode") err[key$1] = props[key$1];
		return err;
	}
	/**
	* Create HTTP error abstract base class.
	* @private
	*/
	function createHttpErrorConstructor() {
		function HttpError() {
			throw new TypeError("cannot construct abstract class");
		}
		inherits(HttpError, Error);
		return HttpError;
	}
	/**
	* Create a constructor for a client error.
	* @private
	*/
	function createClientErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ClientError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ClientError);
			setPrototypeOf(err, ClientError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ClientError, HttpError);
		nameFunc(ClientError, className);
		ClientError.prototype.status = code;
		ClientError.prototype.statusCode = code;
		ClientError.prototype.expose = true;
		return ClientError;
	}
	/**
	* Create function to test is a value is a HttpError.
	* @private
	*/
	function createIsHttpErrorFunction(HttpError) {
		return function isHttpError(val) {
			if (!val || typeof val !== "object") return false;
			if (val instanceof HttpError) return true;
			return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
		};
	}
	/**
	* Create a constructor for a server error.
	* @private
	*/
	function createServerErrorConstructor(HttpError, name, code) {
		var className = toClassName(name);
		function ServerError(message) {
			var msg = message != null ? message : statuses.message[code];
			var err = new Error(msg);
			Error.captureStackTrace(err, ServerError);
			setPrototypeOf(err, ServerError.prototype);
			Object.defineProperty(err, "message", {
				enumerable: true,
				configurable: true,
				value: msg,
				writable: true
			});
			Object.defineProperty(err, "name", {
				enumerable: false,
				configurable: true,
				value: className,
				writable: true
			});
			return err;
		}
		inherits(ServerError, HttpError);
		nameFunc(ServerError, className);
		ServerError.prototype.status = code;
		ServerError.prototype.statusCode = code;
		ServerError.prototype.expose = false;
		return ServerError;
	}
	/**
	* Set the name of a function, if possible.
	* @private
	*/
	function nameFunc(func, name) {
		var desc = Object.getOwnPropertyDescriptor(func, "name");
		if (desc && desc.configurable) {
			desc.value = name;
			Object.defineProperty(func, "name", desc);
		}
	}
	/**
	* Populate the exports object with constructors for every error class.
	* @private
	*/
	function populateConstructorExports(exports$1, codes$1, HttpError) {
		codes$1.forEach(function forEachCode(code) {
			var CodeError;
			var name = toIdentifier(statuses.message[code]);
			switch (codeClass(code)) {
				case 400:
					CodeError = createClientErrorConstructor(HttpError, name, code);
					break;
				case 500:
					CodeError = createServerErrorConstructor(HttpError, name, code);
					break;
			}
			if (CodeError) {
				exports$1[code] = CodeError;
				exports$1[name] = CodeError;
			}
		});
	}
	/**
	* Get a class name from a name identifier.
	* @private
	*/
	function toClassName(name) {
		return name.substr(-5) !== "Error" ? name + "Error" : name;
	}
}) });

//#endregion
//#region node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js": ((exports, module) => {
	var buffer = __require("buffer");
	var Buffer$9 = buffer.Buffer;
	var safer = {};
	var key;
	for (key in buffer) {
		if (!buffer.hasOwnProperty(key)) continue;
		if (key === "SlowBuffer" || key === "Buffer") continue;
		safer[key] = buffer[key];
	}
	var Safer = safer.Buffer = {};
	for (key in Buffer$9) {
		if (!Buffer$9.hasOwnProperty(key)) continue;
		if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
		Safer[key] = Buffer$9[key];
	}
	safer.Buffer.prototype = Buffer$9.prototype;
	if (!Safer.from || Safer.from === Uint8Array.from) Safer.from = function(value, encodingOrOffset, length) {
		if (typeof value === "number") throw new TypeError("The \"value\" argument must not be of type number. Received type " + typeof value);
		if (value && typeof value.length === "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
		return Buffer$9(value, encodingOrOffset, length);
	};
	if (!Safer.alloc) Safer.alloc = function(size, fill, encoding) {
		if (typeof size !== "number") throw new TypeError("The \"size\" argument must be of type number. Received type " + typeof size);
		if (size < 0 || size >= 2 * (1 << 30)) throw new RangeError("The value \"" + size + "\" is invalid for option \"size\"");
		var buf = Buffer$9(size);
		if (!fill || fill.length === 0) buf.fill(0);
		else if (typeof encoding === "string") buf.fill(fill, encoding);
		else buf.fill(fill);
		return buf;
	};
	if (!safer.kStringMaxLength) try {
		safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
	} catch (e) {}
	if (!safer.constants) {
		safer.constants = { MAX_LENGTH: safer.kMaxLength };
		if (safer.kStringMaxLength) safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	}
	module.exports = safer;
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/bom-handling.js": ((exports) => {
	var BOMChar = "";
	exports.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
		this.encoder = encoder;
		this.addBOM = true;
	}
	PrependBOMWrapper.prototype.write = function(str) {
		if (this.addBOM) {
			str = BOMChar + str;
			this.addBOM = false;
		}
		return this.encoder.write(str);
	};
	PrependBOMWrapper.prototype.end = function() {
		return this.encoder.end();
	};
	exports.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
		this.decoder = decoder;
		this.pass = false;
		this.options = options || {};
	}
	StripBOMWrapper.prototype.write = function(buf) {
		var res = this.decoder.write(buf);
		if (this.pass || !res) return res;
		if (res[0] === BOMChar) {
			res = res.slice(1);
			if (typeof this.options.stripBOM === "function") this.options.stripBOM();
		}
		this.pass = true;
		return res;
	};
	StripBOMWrapper.prototype.end = function() {
		return this.decoder.end();
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js
var require_merge_exports = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/helpers/merge-exports.js": ((exports, module) => {
	var hasOwn = typeof Object.hasOwn === "undefined" ? Function.call.bind(Object.prototype.hasOwnProperty) : Object.hasOwn;
	function mergeModules$2(target, module$2) {
		for (var key$1 in module$2) if (hasOwn(module$2, key$1)) target[key$1] = module$2[key$1];
	}
	module.exports = mergeModules$2;
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/internal.js
var require_internal = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/internal.js": ((exports, module) => {
	var Buffer$8 = require_safer().Buffer;
	module.exports = {
		utf8: {
			type: "_internal",
			bomAware: true
		},
		cesu8: {
			type: "_internal",
			bomAware: true
		},
		unicode11utf8: "utf8",
		ucs2: {
			type: "_internal",
			bomAware: true
		},
		utf16le: "ucs2",
		binary: { type: "_internal" },
		base64: { type: "_internal" },
		hex: { type: "_internal" },
		_internal: InternalCodec
	};
	function InternalCodec(codecOptions, iconv$2) {
		this.enc = codecOptions.encodingName;
		this.bomAware = codecOptions.bomAware;
		if (this.enc === "base64") this.encoder = InternalEncoderBase64;
		else if (this.enc === "utf8") this.encoder = InternalEncoderUtf8;
		else if (this.enc === "cesu8") {
			this.enc = "utf8";
			this.encoder = InternalEncoderCesu8;
			if (Buffer$8.from("eda0bdedb2a9", "hex").toString() !== "") {
				this.decoder = InternalDecoderCesu8;
				this.defaultCharUnicode = iconv$2.defaultCharUnicode;
			}
		}
	}
	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;
	var StringDecoder = __require("string_decoder").StringDecoder;
	function InternalDecoder(options, codec) {
		this.decoder = new StringDecoder(codec.enc);
	}
	InternalDecoder.prototype.write = function(buf) {
		if (!Buffer$8.isBuffer(buf)) buf = Buffer$8.from(buf);
		return this.decoder.write(buf);
	};
	InternalDecoder.prototype.end = function() {
		return this.decoder.end();
	};
	function InternalEncoder(options, codec) {
		this.enc = codec.enc;
	}
	InternalEncoder.prototype.write = function(str) {
		return Buffer$8.from(str, this.enc);
	};
	InternalEncoder.prototype.end = function() {};
	function InternalEncoderBase64(options, codec) {
		this.prevStr = "";
	}
	InternalEncoderBase64.prototype.write = function(str) {
		str = this.prevStr + str;
		var completeQuads = str.length - str.length % 4;
		this.prevStr = str.slice(completeQuads);
		str = str.slice(0, completeQuads);
		return Buffer$8.from(str, "base64");
	};
	InternalEncoderBase64.prototype.end = function() {
		return Buffer$8.from(this.prevStr, "base64");
	};
	function InternalEncoderCesu8(options, codec) {}
	InternalEncoderCesu8.prototype.write = function(str) {
		var buf = Buffer$8.alloc(str.length * 3);
		var bufIdx = 0;
		for (var i$3 = 0; i$3 < str.length; i$3++) {
			var charCode = str.charCodeAt(i$3);
			if (charCode < 128) buf[bufIdx++] = charCode;
			else if (charCode < 2048) {
				buf[bufIdx++] = 192 + (charCode >>> 6);
				buf[bufIdx++] = 128 + (charCode & 63);
			} else {
				buf[bufIdx++] = 224 + (charCode >>> 12);
				buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
				buf[bufIdx++] = 128 + (charCode & 63);
			}
		}
		return buf.slice(0, bufIdx);
	};
	InternalEncoderCesu8.prototype.end = function() {};
	function InternalDecoderCesu8(options, codec) {
		this.acc = 0;
		this.contBytes = 0;
		this.accBytes = 0;
		this.defaultCharUnicode = codec.defaultCharUnicode;
	}
	InternalDecoderCesu8.prototype.write = function(buf) {
		var acc = this.acc;
		var contBytes = this.contBytes;
		var accBytes = this.accBytes;
		var res = "";
		for (var i$3 = 0; i$3 < buf.length; i$3++) {
			var curByte = buf[i$3];
			if ((curByte & 192) !== 128) {
				if (contBytes > 0) {
					res += this.defaultCharUnicode;
					contBytes = 0;
				}
				if (curByte < 128) res += String.fromCharCode(curByte);
				else if (curByte < 224) {
					acc = curByte & 31;
					contBytes = 1;
					accBytes = 1;
				} else if (curByte < 240) {
					acc = curByte & 15;
					contBytes = 2;
					accBytes = 1;
				} else res += this.defaultCharUnicode;
			} else if (contBytes > 0) {
				acc = acc << 6 | curByte & 63;
				contBytes--;
				accBytes++;
				if (contBytes === 0) if (accBytes === 2 && acc < 128 && acc > 0) res += this.defaultCharUnicode;
				else if (accBytes === 3 && acc < 2048) res += this.defaultCharUnicode;
				else res += String.fromCharCode(acc);
			} else res += this.defaultCharUnicode;
		}
		this.acc = acc;
		this.contBytes = contBytes;
		this.accBytes = accBytes;
		return res;
	};
	InternalDecoderCesu8.prototype.end = function() {
		var res = 0;
		if (this.contBytes > 0) res += this.defaultCharUnicode;
		return res;
	};
	function InternalEncoderUtf8(options, codec) {
		this.highSurrogate = "";
	}
	InternalEncoderUtf8.prototype.write = function(str) {
		if (this.highSurrogate) {
			str = this.highSurrogate + str;
			this.highSurrogate = "";
		}
		if (str.length > 0) {
			var charCode = str.charCodeAt(str.length - 1);
			if (charCode >= 55296 && charCode < 56320) {
				this.highSurrogate = str[str.length - 1];
				str = str.slice(0, str.length - 1);
			}
		}
		return Buffer$8.from(str, this.enc);
	};
	InternalEncoderUtf8.prototype.end = function() {
		if (this.highSurrogate) {
			var str = this.highSurrogate;
			this.highSurrogate = "";
			return Buffer$8.from(str, this.enc);
		}
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf32.js": ((exports) => {
	var Buffer$7 = require_safer().Buffer;
	exports._utf32 = Utf32Codec;
	function Utf32Codec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
		this.bomAware = true;
		this.isLE = codecOptions.isLE;
	}
	exports.utf32le = {
		type: "_utf32",
		isLE: true
	};
	exports.utf32be = {
		type: "_utf32",
		isLE: false
	};
	exports.ucs4le = "utf32le";
	exports.ucs4be = "utf32be";
	Utf32Codec.prototype.encoder = Utf32Encoder;
	Utf32Codec.prototype.decoder = Utf32Decoder;
	function Utf32Encoder(options, codec) {
		this.isLE = codec.isLE;
		this.highSurrogate = 0;
	}
	Utf32Encoder.prototype.write = function(str) {
		var src = Buffer$7.from(str, "ucs2");
		var dst = Buffer$7.alloc(src.length * 2);
		var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
		var offset = 0;
		for (var i$3 = 0; i$3 < src.length; i$3 += 2) {
			var code = src.readUInt16LE(i$3);
			var isHighSurrogate = code >= 55296 && code < 56320;
			var isLowSurrogate = code >= 56320 && code < 57344;
			if (this.highSurrogate) if (isHighSurrogate || !isLowSurrogate) {
				write32.call(dst, this.highSurrogate, offset);
				offset += 4;
			} else {
				var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
				write32.call(dst, codepoint, offset);
				offset += 4;
				this.highSurrogate = 0;
				continue;
			}
			if (isHighSurrogate) this.highSurrogate = code;
			else {
				write32.call(dst, code, offset);
				offset += 4;
				this.highSurrogate = 0;
			}
		}
		if (offset < dst.length) dst = dst.slice(0, offset);
		return dst;
	};
	Utf32Encoder.prototype.end = function() {
		if (!this.highSurrogate) return;
		var buf = Buffer$7.alloc(4);
		if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
		else buf.writeUInt32BE(this.highSurrogate, 0);
		this.highSurrogate = 0;
		return buf;
	};
	function Utf32Decoder(options, codec) {
		this.isLE = codec.isLE;
		this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
		this.overflow = [];
	}
	Utf32Decoder.prototype.write = function(src) {
		if (src.length === 0) return "";
		var i$3 = 0;
		var codepoint = 0;
		var dst = Buffer$7.alloc(src.length + 4);
		var offset = 0;
		var isLE = this.isLE;
		var overflow = this.overflow;
		var badChar = this.badChar;
		if (overflow.length > 0) {
			for (; i$3 < src.length && overflow.length < 4; i$3++) overflow.push(src[i$3]);
			if (overflow.length === 4) {
				if (isLE) codepoint = overflow[i$3] | overflow[i$3 + 1] << 8 | overflow[i$3 + 2] << 16 | overflow[i$3 + 3] << 24;
				else codepoint = overflow[i$3 + 3] | overflow[i$3 + 2] << 8 | overflow[i$3 + 1] << 16 | overflow[i$3] << 24;
				overflow.length = 0;
				offset = _writeCodepoint(dst, offset, codepoint, badChar);
			}
		}
		for (; i$3 < src.length - 3; i$3 += 4) {
			if (isLE) codepoint = src[i$3] | src[i$3 + 1] << 8 | src[i$3 + 2] << 16 | src[i$3 + 3] << 24;
			else codepoint = src[i$3 + 3] | src[i$3 + 2] << 8 | src[i$3 + 1] << 16 | src[i$3] << 24;
			offset = _writeCodepoint(dst, offset, codepoint, badChar);
		}
		for (; i$3 < src.length; i$3++) overflow.push(src[i$3]);
		return dst.slice(0, offset).toString("ucs2");
	};
	function _writeCodepoint(dst, offset, codepoint, badChar) {
		if (codepoint < 0 || codepoint > 1114111) codepoint = badChar;
		if (codepoint >= 65536) {
			codepoint -= 65536;
			var high = 55296 | codepoint >> 10;
			dst[offset++] = high & 255;
			dst[offset++] = high >> 8;
			var codepoint = 56320 | codepoint & 1023;
		}
		dst[offset++] = codepoint & 255;
		dst[offset++] = codepoint >> 8;
		return offset;
	}
	Utf32Decoder.prototype.end = function() {
		this.overflow.length = 0;
	};
	exports.utf32 = Utf32AutoCodec;
	exports.ucs4 = "utf32";
	function Utf32AutoCodec(options, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
	Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
	function Utf32AutoEncoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
	}
	Utf32AutoEncoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf32AutoEncoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf32AutoDecoder(options, codec) {
		this.decoder = null;
		this.initialBufs = [];
		this.initialBufsLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf32AutoDecoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBufs.push(buf);
			this.initialBufsLen += buf.length;
			if (this.initialBufsLen < 32) return "";
			var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.write(buf);
	};
	Utf32AutoDecoder.prototype.end = function() {
		if (!this.decoder) {
			var encoding = detectEncoding$1(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			var trail = this.decoder.end();
			if (trail) resStr += trail;
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.end();
	};
	function detectEncoding$1(bufs, defaultEncoding) {
		var b = [];
		var charsProcessed = 0;
		var invalidLE = 0;
		var invalidBE = 0;
		var bmpCharsLE = 0;
		var bmpCharsBE = 0;
		outerLoop: for (var i$3 = 0; i$3 < bufs.length; i$3++) {
			var buf = bufs[i$3];
			for (var j = 0; j < buf.length; j++) {
				b.push(buf[j]);
				if (b.length === 4) {
					if (charsProcessed === 0) {
						if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) return "utf-32le";
						if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) return "utf-32be";
					}
					if (b[0] !== 0 || b[1] > 16) invalidBE++;
					if (b[3] !== 0 || b[2] > 16) invalidLE++;
					if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
					if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
					b.length = 0;
					charsProcessed++;
					if (charsProcessed >= 100) break outerLoop;
				}
			}
		}
		if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
		if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
		return defaultEncoding || "utf-32le";
	}
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf16.js": ((exports) => {
	var Buffer$6 = require_safer().Buffer;
	exports.utf16be = Utf16BECodec;
	function Utf16BECodec() {}
	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;
	function Utf16BEEncoder() {}
	Utf16BEEncoder.prototype.write = function(str) {
		var buf = Buffer$6.from(str, "ucs2");
		for (var i$3 = 0; i$3 < buf.length; i$3 += 2) {
			var tmp = buf[i$3];
			buf[i$3] = buf[i$3 + 1];
			buf[i$3 + 1] = tmp;
		}
		return buf;
	};
	Utf16BEEncoder.prototype.end = function() {};
	function Utf16BEDecoder() {
		this.overflowByte = -1;
	}
	Utf16BEDecoder.prototype.write = function(buf) {
		if (buf.length == 0) return "";
		var buf2 = Buffer$6.alloc(buf.length + 1);
		var i$3 = 0;
		var j = 0;
		if (this.overflowByte !== -1) {
			buf2[0] = buf[0];
			buf2[1] = this.overflowByte;
			i$3 = 1;
			j = 2;
		}
		for (; i$3 < buf.length - 1; i$3 += 2, j += 2) {
			buf2[j] = buf[i$3 + 1];
			buf2[j + 1] = buf[i$3];
		}
		this.overflowByte = i$3 == buf.length - 1 ? buf[buf.length - 1] : -1;
		return buf2.slice(0, j).toString("ucs2");
	};
	Utf16BEDecoder.prototype.end = function() {
		this.overflowByte = -1;
	};
	exports.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;
	function Utf16Encoder(options, codec) {
		options = options || {};
		if (options.addBOM === void 0) options.addBOM = true;
		this.encoder = codec.iconv.getEncoder("utf-16le", options);
	}
	Utf16Encoder.prototype.write = function(str) {
		return this.encoder.write(str);
	};
	Utf16Encoder.prototype.end = function() {
		return this.encoder.end();
	};
	function Utf16Decoder(options, codec) {
		this.decoder = null;
		this.initialBufs = [];
		this.initialBufsLen = 0;
		this.options = options || {};
		this.iconv = codec.iconv;
	}
	Utf16Decoder.prototype.write = function(buf) {
		if (!this.decoder) {
			this.initialBufs.push(buf);
			this.initialBufsLen += buf.length;
			if (this.initialBufsLen < 16) return "";
			var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.write(buf);
	};
	Utf16Decoder.prototype.end = function() {
		if (!this.decoder) {
			var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
			this.decoder = this.iconv.getDecoder(encoding, this.options);
			var resStr = "";
			for (var i$3 = 0; i$3 < this.initialBufs.length; i$3++) resStr += this.decoder.write(this.initialBufs[i$3]);
			var trail = this.decoder.end();
			if (trail) resStr += trail;
			this.initialBufs.length = this.initialBufsLen = 0;
			return resStr;
		}
		return this.decoder.end();
	};
	function detectEncoding(bufs, defaultEncoding) {
		var b = [];
		var charsProcessed = 0;
		var asciiCharsLE = 0;
		var asciiCharsBE = 0;
		outerLoop: for (var i$3 = 0; i$3 < bufs.length; i$3++) {
			var buf = bufs[i$3];
			for (var j = 0; j < buf.length; j++) {
				b.push(buf[j]);
				if (b.length === 2) {
					if (charsProcessed === 0) {
						if (b[0] === 255 && b[1] === 254) return "utf-16le";
						if (b[0] === 254 && b[1] === 255) return "utf-16be";
					}
					if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
					if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
					b.length = 0;
					charsProcessed++;
					if (charsProcessed >= 100) break outerLoop;
				}
			}
		}
		if (asciiCharsBE > asciiCharsLE) return "utf-16be";
		if (asciiCharsBE < asciiCharsLE) return "utf-16le";
		return defaultEncoding || "utf-16le";
	}
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/utf7.js": ((exports) => {
	var Buffer$5 = require_safer().Buffer;
	exports.utf7 = Utf7Codec;
	exports.unicode11utf7 = "utf7";
	function Utf7Codec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;
	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
	function Utf7Encoder(options, codec) {
		this.iconv = codec.iconv;
	}
	Utf7Encoder.prototype.write = function(str) {
		return Buffer$5.from(str.replace(nonDirectChars, function(chunk) {
			return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
		}.bind(this)));
	};
	Utf7Encoder.prototype.end = function() {};
	function Utf7Decoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i$2 = 0; i$2 < 256; i$2++) base64Chars[i$2] = base64Regex.test(String.fromCharCode(i$2));
	var plusChar = "+".charCodeAt(0);
	var minusChar = "-".charCodeAt(0);
	var andChar = "&".charCodeAt(0);
	Utf7Decoder.prototype.write = function(buf) {
		var res = "";
		var lastI = 0;
		var inBase64 = this.inBase64;
		var base64Accum = this.base64Accum;
		for (var i$3 = 0; i$3 < buf.length; i$3++) if (!inBase64) {
			if (buf[i$3] == plusChar) {
				res += this.iconv.decode(buf.slice(lastI, i$3), "ascii");
				lastI = i$3 + 1;
				inBase64 = true;
			}
		} else if (!base64Chars[buf[i$3]]) {
			if (i$3 == lastI && buf[i$3] == minusChar) res += "+";
			else {
				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i$3), "ascii");
				res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i$3] != minusChar) i$3--;
			lastI = i$3 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7Decoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$5.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
	exports.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv$2) {
		this.iconv = iconv$2;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;
	function Utf7IMAPEncoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = Buffer$5.alloc(6);
		this.base64AccumIdx = 0;
	}
	Utf7IMAPEncoder.prototype.write = function(str) {
		var inBase64 = this.inBase64;
		var base64Accum = this.base64Accum;
		var base64AccumIdx = this.base64AccumIdx;
		var buf = Buffer$5.alloc(str.length * 5 + 10);
		var bufIdx = 0;
		for (var i$3 = 0; i$3 < str.length; i$3++) {
			var uChar = str.charCodeAt(i$3);
			if (uChar >= 32 && uChar <= 126) {
				if (inBase64) {
					if (base64AccumIdx > 0) {
						bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
						base64AccumIdx = 0;
					}
					buf[bufIdx++] = minusChar;
					inBase64 = false;
				}
				if (!inBase64) {
					buf[bufIdx++] = uChar;
					if (uChar === andChar) buf[bufIdx++] = minusChar;
				}
			} else {
				if (!inBase64) {
					buf[bufIdx++] = andChar;
					inBase64 = true;
				}
				if (inBase64) {
					base64Accum[base64AccumIdx++] = uChar >> 8;
					base64Accum[base64AccumIdx++] = uChar & 255;
					if (base64AccumIdx == base64Accum.length) {
						bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
						base64AccumIdx = 0;
					}
				}
			}
		}
		this.inBase64 = inBase64;
		this.base64AccumIdx = base64AccumIdx;
		return buf.slice(0, bufIdx);
	};
	Utf7IMAPEncoder.prototype.end = function() {
		var buf = Buffer$5.alloc(10);
		var bufIdx = 0;
		if (this.inBase64) {
			if (this.base64AccumIdx > 0) {
				bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
				this.base64AccumIdx = 0;
			}
			buf[bufIdx++] = minusChar;
			this.inBase64 = false;
		}
		return buf.slice(0, bufIdx);
	};
	function Utf7IMAPDecoder(options, codec) {
		this.iconv = codec.iconv;
		this.inBase64 = false;
		this.base64Accum = "";
	}
	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[",".charCodeAt(0)] = true;
	Utf7IMAPDecoder.prototype.write = function(buf) {
		var res = "";
		var lastI = 0;
		var inBase64 = this.inBase64;
		var base64Accum = this.base64Accum;
		for (var i$3 = 0; i$3 < buf.length; i$3++) if (!inBase64) {
			if (buf[i$3] == andChar) {
				res += this.iconv.decode(buf.slice(lastI, i$3), "ascii");
				lastI = i$3 + 1;
				inBase64 = true;
			}
		} else if (!base64IMAPChars[buf[i$3]]) {
			if (i$3 == lastI && buf[i$3] == minusChar) res += "&";
			else {
				var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i$3), "ascii").replace(/,/g, "/");
				res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
			}
			if (buf[i$3] != minusChar) i$3--;
			lastI = i$3 + 1;
			inBase64 = false;
			base64Accum = "";
		}
		if (!inBase64) res += this.iconv.decode(buf.slice(lastI), "ascii");
		else {
			var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
			var canBeDecoded = b64str.length - b64str.length % 8;
			base64Accum = b64str.slice(canBeDecoded);
			b64str = b64str.slice(0, canBeDecoded);
			res += this.iconv.decode(Buffer$5.from(b64str, "base64"), "utf16-be");
		}
		this.inBase64 = inBase64;
		this.base64Accum = base64Accum;
		return res;
	};
	Utf7IMAPDecoder.prototype.end = function() {
		var res = "";
		if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer$5.from(this.base64Accum, "base64"), "utf16-be");
		this.inBase64 = false;
		this.base64Accum = "";
		return res;
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-codec.js": ((exports) => {
	var Buffer$4 = require_safer().Buffer;
	exports._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv$2) {
		if (!codecOptions) throw new Error("SBCS codec is called without the data.");
		if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
		if (codecOptions.chars.length === 128) {
			var asciiString = "";
			for (var i$3 = 0; i$3 < 128; i$3++) asciiString += String.fromCharCode(i$3);
			codecOptions.chars = asciiString + codecOptions.chars;
		}
		this.decodeBuf = Buffer$4.from(codecOptions.chars, "ucs2");
		var encodeBuf = Buffer$4.alloc(65536, iconv$2.defaultCharSingleByte.charCodeAt(0));
		for (var i$3 = 0; i$3 < codecOptions.chars.length; i$3++) encodeBuf[codecOptions.chars.charCodeAt(i$3)] = i$3;
		this.encodeBuf = encodeBuf;
	}
	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;
	function SBCSEncoder(options, codec) {
		this.encodeBuf = codec.encodeBuf;
	}
	SBCSEncoder.prototype.write = function(str) {
		var buf = Buffer$4.alloc(str.length);
		for (var i$3 = 0; i$3 < str.length; i$3++) buf[i$3] = this.encodeBuf[str.charCodeAt(i$3)];
		return buf;
	};
	SBCSEncoder.prototype.end = function() {};
	function SBCSDecoder(options, codec) {
		this.decodeBuf = codec.decodeBuf;
	}
	SBCSDecoder.prototype.write = function(buf) {
		var decodeBuf = this.decodeBuf;
		var newBuf = Buffer$4.alloc(buf.length * 2);
		var idx1 = 0;
		var idx2 = 0;
		for (var i$3 = 0; i$3 < buf.length; i$3++) {
			idx1 = buf[i$3] * 2;
			idx2 = i$3 * 2;
			newBuf[idx2] = decodeBuf[idx1];
			newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
		}
		return newBuf.toString("ucs2");
	};
	SBCSDecoder.prototype.end = function() {};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data.js": ((exports, module) => {
	module.exports = {
		10029: "maccenteuro",
		maccenteuro: {
			type: "_sbcs",
			chars: "\xA0"
		},
		808: "cp808",
		ibm808: "cp808",
		cp808: {
			type: "_sbcs",
			chars: "\xA0"
		},
		mik: {
			type: "_sbcs",
			chars: "\xA0"
		},
		cp720: {
			type: "_sbcs",
			chars: "\xA0"
		},
		ascii8bit: "ascii",
		usascii: "ascii",
		ansix34: "ascii",
		ansix341968: "ascii",
		ansix341986: "ascii",
		csascii: "ascii",
		cp367: "ascii",
		ibm367: "ascii",
		isoir6: "ascii",
		iso646us: "ascii",
		iso646irv: "ascii",
		us: "ascii",
		latin1: "iso88591",
		latin2: "iso88592",
		latin3: "iso88593",
		latin4: "iso88594",
		latin5: "iso88599",
		latin6: "iso885910",
		latin7: "iso885913",
		latin8: "iso885914",
		latin9: "iso885915",
		latin10: "iso885916",
		csisolatin1: "iso88591",
		csisolatin2: "iso88592",
		csisolatin3: "iso88593",
		csisolatin4: "iso88594",
		csisolatincyrillic: "iso88595",
		csisolatinarabic: "iso88596",
		csisolatingreek: "iso88597",
		csisolatinhebrew: "iso88598",
		csisolatin5: "iso88599",
		csisolatin6: "iso885910",
		l1: "iso88591",
		l2: "iso88592",
		l3: "iso88593",
		l4: "iso88594",
		l5: "iso88599",
		l6: "iso885910",
		l7: "iso885913",
		l8: "iso885914",
		l9: "iso885915",
		l10: "iso885916",
		isoir14: "iso646jp",
		isoir57: "iso646cn",
		isoir100: "iso88591",
		isoir101: "iso88592",
		isoir109: "iso88593",
		isoir110: "iso88594",
		isoir144: "iso88595",
		isoir127: "iso88596",
		isoir126: "iso88597",
		isoir138: "iso88598",
		isoir148: "iso88599",
		isoir157: "iso885910",
		isoir166: "tis620",
		isoir179: "iso885913",
		isoir199: "iso885914",
		isoir203: "iso885915",
		isoir226: "iso885916",
		cp819: "iso88591",
		ibm819: "iso88591",
		cyrillic: "iso88595",
		arabic: "iso88596",
		arabic8: "iso88596",
		ecma114: "iso88596",
		asmo708: "iso88596",
		greek: "iso88597",
		greek8: "iso88597",
		ecma118: "iso88597",
		elot928: "iso88597",
		hebrew: "iso88598",
		hebrew8: "iso88598",
		turkish: "iso88599",
		turkish8: "iso88599",
		thai: "iso885911",
		thai8: "iso885911",
		celtic: "iso885914",
		celtic8: "iso885914",
		isoceltic: "iso885914",
		tis6200: "tis620",
		tis62025291: "tis620",
		tis62025330: "tis620",
		1e4: "macroman",
		10006: "macgreek",
		10007: "maccyrillic",
		10079: "maciceland",
		10081: "macturkish",
		cspc8codepage437: "cp437",
		cspc775baltic: "cp775",
		cspc850multilingual: "cp850",
		cspcp852: "cp852",
		cspc862latinhebrew: "cp862",
		cpgr: "cp869",
		msee: "cp1250",
		mscyrl: "cp1251",
		msansi: "cp1252",
		msgreek: "cp1253",
		msturk: "cp1254",
		mshebr: "cp1255",
		msarab: "cp1256",
		winbaltrim: "cp1257",
		cp20866: "koi8r",
		20866: "koi8r",
		ibm878: "koi8r",
		cskoi8r: "koi8r",
		cp21866: "koi8u",
		21866: "koi8u",
		ibm1168: "koi8u",
		strk10482002: "rk1048",
		tcvn5712: "tcvn",
		tcvn57121: "tcvn",
		gb198880: "iso646cn",
		cn: "iso646cn",
		csiso14jisc6220ro: "iso646jp",
		jisc62201969ro: "iso646jp",
		jp: "iso646jp",
		cshproman8: "hproman8",
		r8: "hproman8",
		roman8: "hproman8",
		xroman8: "hproman8",
		ibm1051: "hproman8",
		mac: "macintosh",
		csmacintosh: "macintosh"
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/sbcs-data-generated.js": ((exports, module) => {
	module.exports = {
		"437": "cp437",
		"737": "cp737",
		"775": "cp775",
		"850": "cp850",
		"852": "cp852",
		"855": "cp855",
		"856": "cp856",
		"857": "cp857",
		"858": "cp858",
		"860": "cp860",
		"861": "cp861",
		"862": "cp862",
		"863": "cp863",
		"864": "cp864",
		"865": "cp865",
		"866": "cp866",
		"869": "cp869",
		"874": "windows874",
		"922": "cp922",
		"1046": "cp1046",
		"1124": "cp1124",
		"1125": "cp1125",
		"1129": "cp1129",
		"1133": "cp1133",
		"1161": "cp1161",
		"1162": "cp1162",
		"1163": "cp1163",
		"1250": "windows1250",
		"1251": "windows1251",
		"1252": "windows1252",
		"1253": "windows1253",
		"1254": "windows1254",
		"1255": "windows1255",
		"1256": "windows1256",
		"1257": "windows1257",
		"1258": "windows1258",
		"28591": "iso88591",
		"28592": "iso88592",
		"28593": "iso88593",
		"28594": "iso88594",
		"28595": "iso88595",
		"28596": "iso88596",
		"28597": "iso88597",
		"28598": "iso88598",
		"28599": "iso88599",
		"28600": "iso885910",
		"28601": "iso885911",
		"28603": "iso885913",
		"28604": "iso885914",
		"28605": "iso885915",
		"28606": "iso885916",
		"windows874": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win874": "windows874",
		"cp874": "windows874",
		"windows1250": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1250": "windows1250",
		"cp1250": "windows1250",
		"windows1251": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1251": "windows1251",
		"cp1251": "windows1251",
		"windows1252": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1252": "windows1252",
		"cp1252": "windows1252",
		"windows1253": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1253": "windows1253",
		"cp1253": "windows1253",
		"windows1254": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1254": "windows1254",
		"cp1254": "windows1254",
		"windows1255": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1255": "windows1255",
		"cp1255": "windows1255",
		"windows1256": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1256": "windows1256",
		"cp1256": "windows1256",
		"windows1257": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1257": "windows1257",
		"cp1257": "windows1257",
		"windows1258": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"win1258": "windows1258",
		"cp1258": "windows1258",
		"iso88591": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28591": "iso88591",
		"iso88592": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28592": "iso88592",
		"iso88593": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28593": "iso88593",
		"iso88594": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28594": "iso88594",
		"iso88595": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28595": "iso88595",
		"iso88596": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28596": "iso88596",
		"iso88597": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28597": "iso88597",
		"iso88598": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28598": "iso88598",
		"iso88599": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28599": "iso88599",
		"iso885910": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28600": "iso885910",
		"iso885911": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28601": "iso885911",
		"iso885913": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28603": "iso885913",
		"iso885914": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28604": "iso885914",
		"iso885915": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28605": "iso885915",
		"iso885916": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"cp28606": "iso885916",
		"cp437": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm437": "cp437",
		"csibm437": "cp437",
		"cp737": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm737": "cp737",
		"csibm737": "cp737",
		"cp775": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm775": "cp775",
		"csibm775": "cp775",
		"cp850": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm850": "cp850",
		"csibm850": "cp850",
		"cp852": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm852": "cp852",
		"csibm852": "cp852",
		"cp855": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm855": "cp855",
		"csibm855": "cp855",
		"cp856": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm856": "cp856",
		"csibm856": "cp856",
		"cp857": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm857": "cp857",
		"csibm857": "cp857",
		"cp858": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm858": "cp858",
		"csibm858": "cp858",
		"cp860": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm860": "cp860",
		"csibm860": "cp860",
		"cp861": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm861": "cp861",
		"csibm861": "cp861",
		"cp862": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm862": "cp862",
		"csibm862": "cp862",
		"cp863": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm863": "cp863",
		"csibm863": "cp863",
		"cp864": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"ibm864": "cp864",
		"csibm864": "cp864",
		"cp865": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm865": "cp865",
		"csibm865": "cp865",
		"cp866": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm866": "cp866",
		"csibm866": "cp866",
		"cp869": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm869": "cp869",
		"csibm869": "cp869",
		"cp922": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm922": "cp922",
		"csibm922": "cp922",
		"cp1046": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1046": "cp1046",
		"csibm1046": "cp1046",
		"cp1124": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1124": "cp1124",
		"csibm1124": "cp1124",
		"cp1125": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1125": "cp1125",
		"csibm1125": "cp1125",
		"cp1129": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1129": "cp1129",
		"csibm1129": "cp1129",
		"cp1133": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1133": "cp1133",
		"csibm1133": "cp1133",
		"cp1161": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1161": "cp1161",
		"csibm1161": "cp1161",
		"cp1162": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1162": "cp1162",
		"csibm1162": "cp1162",
		"cp1163": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ibm1163": "cp1163",
		"csibm1163": "cp1163",
		"maccroatian": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maccyrillic": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macgreek": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"maciceland": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macroman": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macromania": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macthai": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macturkish": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macukraine": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8r": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8u": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8ru": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"koi8t": {
			"type": "_sbcs",
			"chars": ""
		},
		"armscii8": {
			"type": "_sbcs",
			"chars": "\xA0)(.,-"
		},
		"rk1048": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"tcvn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\xA0"
		},
		"georgianacademy": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"georgianps": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"pt154": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"viscii": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
		},
		"iso646cn": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"iso646jp": {
			"type": "_sbcs",
			"chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
		},
		"hproman8": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"macintosh": {
			"type": "_sbcs",
			"chars": "\xA0"
		},
		"ascii": {
			"type": "_sbcs",
			"chars": ""
		},
		"tis620": {
			"type": "_sbcs",
			"chars": ""
		}
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-codec.js": ((exports) => {
	var Buffer$3 = require_safer().Buffer;
	exports._dbcs = DBCSCodec;
	var UNASSIGNED = -1;
	var GB18030_CODE = -2;
	var SEQ_START = -10;
	var NODE_START = -1e3;
	var UNASSIGNED_NODE = new Array(256);
	var DEF_CHAR = -1;
	for (var i$1 = 0; i$1 < 256; i$1++) UNASSIGNED_NODE[i$1] = UNASSIGNED;
	function DBCSCodec(codecOptions, iconv$2) {
		this.encodingName = codecOptions.encodingName;
		if (!codecOptions) throw new Error("DBCS codec is called without the data.");
		if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");
		var mappingTable = codecOptions.table();
		this.decodeTables = [];
		this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
		this.decodeTableSeq = [];
		for (var i$3 = 0; i$3 < mappingTable.length; i$3++) this._addDecodeChunk(mappingTable[i$3]);
		if (typeof codecOptions.gb18030 === "function") {
			this.gb18030 = codecOptions.gb18030();
			var commonThirdByteNodeIdx = this.decodeTables.length;
			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
			var commonFourthByteNodeIdx = this.decodeTables.length;
			this.decodeTables.push(UNASSIGNED_NODE.slice(0));
			var firstByteNode = this.decodeTables[0];
			for (var i$3 = 129; i$3 <= 254; i$3++) {
				var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i$3]];
				for (var j = 48; j <= 57; j++) {
					if (secondByteNode[j] === UNASSIGNED) secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
					else if (secondByteNode[j] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 2");
					var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
					for (var k = 129; k <= 254; k++) {
						if (thirdByteNode[k] === UNASSIGNED) thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
						else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) continue;
						else if (thirdByteNode[k] > NODE_START) throw new Error("gb18030 decode tables conflict at byte 3");
						var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
						for (var l = 48; l <= 57; l++) if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;
					}
				}
			}
		}
		this.defaultCharUnicode = iconv$2.defaultCharUnicode;
		this.encodeTable = [];
		this.encodeTableSeq = [];
		var skipEncodeChars = {};
		if (codecOptions.encodeSkipVals) for (var i$3 = 0; i$3 < codecOptions.encodeSkipVals.length; i$3++) {
			var val = codecOptions.encodeSkipVals[i$3];
			if (typeof val === "number") skipEncodeChars[val] = true;
			else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
		}
		this._fillEncodeTable(0, 0, skipEncodeChars);
		if (codecOptions.encodeAdd) {
			for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
		}
		this.defCharSB = this.encodeTable[0][iconv$2.defaultCharSingleByte.charCodeAt(0)];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
		if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
	}
	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
		var bytes$2 = [];
		for (; addr > 0; addr >>>= 8) bytes$2.push(addr & 255);
		if (bytes$2.length == 0) bytes$2.push(0);
		var node = this.decodeTables[0];
		for (var i$3 = bytes$2.length - 1; i$3 > 0; i$3--) {
			var val = node[bytes$2[i$3]];
			if (val == UNASSIGNED) {
				node[bytes$2[i$3]] = NODE_START - this.decodeTables.length;
				this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
			} else if (val <= NODE_START) node = this.decodeTables[NODE_START - val];
			else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
		}
		return node;
	};
	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
		var curAddr = parseInt(chunk[0], 16);
		var writeTable = this._getDecodeTrieNode(curAddr);
		curAddr = curAddr & 255;
		for (var k = 1; k < chunk.length; k++) {
			var part = chunk[k];
			if (typeof part === "string") for (var l = 0; l < part.length;) {
				var code = part.charCodeAt(l++);
				if (code >= 55296 && code < 56320) {
					var codeTrail = part.charCodeAt(l++);
					if (codeTrail >= 56320 && codeTrail < 57344) writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
					else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
				} else if (code > 4080 && code <= 4095) {
					var len = 4095 - code + 2;
					var seq = [];
					for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
					writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
					this.decodeTableSeq.push(seq);
				} else writeTable[curAddr++] = code;
			}
			else if (typeof part === "number") {
				var charCode = writeTable[curAddr - 1] + 1;
				for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
			} else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
		}
		if (curAddr > 255) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
		var high = uCode >> 8;
		if (this.encodeTable[high] === void 0) this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
		return this.encodeTable[high];
	};
	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
		else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
	};
	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
		var uCode = seq[0];
		var bucket = this._getEncodeBucket(uCode);
		var low = uCode & 255;
		var node;
		if (bucket[low] <= SEQ_START) node = this.encodeTableSeq[SEQ_START - bucket[low]];
		else {
			node = {};
			if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
			bucket[low] = SEQ_START - this.encodeTableSeq.length;
			this.encodeTableSeq.push(node);
		}
		for (var j = 1; j < seq.length - 1; j++) {
			var oldVal = node[uCode];
			if (typeof oldVal === "object") node = oldVal;
			else {
				node = node[uCode] = {};
				if (oldVal !== void 0) node[DEF_CHAR] = oldVal;
			}
		}
		uCode = seq[seq.length - 1];
		node[uCode] = dbcsCode;
	};
	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
		var node = this.decodeTables[nodeIdx];
		var hasValues = false;
		var subNodeEmpty = {};
		for (var i$3 = 0; i$3 < 256; i$3++) {
			var uCode = node[i$3];
			var mbCode = prefix + i$3;
			if (skipEncodeChars[mbCode]) continue;
			if (uCode >= 0) {
				this._setEncodeChar(uCode, mbCode);
				hasValues = true;
			} else if (uCode <= NODE_START) {
				var subNodeIdx = NODE_START - uCode;
				if (!subNodeEmpty[subNodeIdx]) {
					var newPrefix = mbCode << 8 >>> 0;
					if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;
					else subNodeEmpty[subNodeIdx] = true;
				}
			} else if (uCode <= SEQ_START) {
				this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
				hasValues = true;
			}
		}
		return hasValues;
	};
	function DBCSEncoder(options, codec) {
		this.leadSurrogate = -1;
		this.seqObj = void 0;
		this.encodeTable = codec.encodeTable;
		this.encodeTableSeq = codec.encodeTableSeq;
		this.defaultCharSingleByte = codec.defCharSB;
		this.gb18030 = codec.gb18030;
	}
	DBCSEncoder.prototype.write = function(str) {
		var newBuf = Buffer$3.alloc(str.length * (this.gb18030 ? 4 : 3));
		var leadSurrogate = this.leadSurrogate;
		var seqObj = this.seqObj;
		var nextChar = -1;
		var i$3 = 0;
		var j = 0;
		while (true) {
			if (nextChar === -1) {
				if (i$3 == str.length) break;
				var uCode = str.charCodeAt(i$3++);
			} else {
				var uCode = nextChar;
				nextChar = -1;
			}
			if (uCode >= 55296 && uCode < 57344) if (uCode < 56320) if (leadSurrogate === -1) {
				leadSurrogate = uCode;
				continue;
			} else {
				leadSurrogate = uCode;
				uCode = UNASSIGNED;
			}
			else if (leadSurrogate !== -1) {
				uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
				leadSurrogate = -1;
			} else uCode = UNASSIGNED;
			else if (leadSurrogate !== -1) {
				nextChar = uCode;
				uCode = UNASSIGNED;
				leadSurrogate = -1;
			}
			var dbcsCode = UNASSIGNED;
			if (seqObj !== void 0 && uCode != UNASSIGNED) {
				var resCode = seqObj[uCode];
				if (typeof resCode === "object") {
					seqObj = resCode;
					continue;
				} else if (typeof resCode === "number") dbcsCode = resCode;
				else if (resCode == void 0) {
					resCode = seqObj[DEF_CHAR];
					if (resCode !== void 0) {
						dbcsCode = resCode;
						nextChar = uCode;
					}
				}
				seqObj = void 0;
			} else if (uCode >= 0) {
				var subtable = this.encodeTable[uCode >> 8];
				if (subtable !== void 0) dbcsCode = subtable[uCode & 255];
				if (dbcsCode <= SEQ_START) {
					seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
					continue;
				}
				if (dbcsCode == UNASSIGNED && this.gb18030) {
					var idx = findIdx(this.gb18030.uChars, uCode);
					if (idx != -1) {
						var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
						newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
						dbcsCode = dbcsCode % 12600;
						newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
						dbcsCode = dbcsCode % 1260;
						newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
						dbcsCode = dbcsCode % 10;
						newBuf[j++] = 48 + dbcsCode;
						continue;
					}
				}
			}
			if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
			if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else if (dbcsCode < 65536) {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			} else if (dbcsCode < 16777216) {
				newBuf[j++] = dbcsCode >> 16;
				newBuf[j++] = dbcsCode >> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			} else {
				newBuf[j++] = dbcsCode >>> 24;
				newBuf[j++] = dbcsCode >>> 16 & 255;
				newBuf[j++] = dbcsCode >>> 8 & 255;
				newBuf[j++] = dbcsCode & 255;
			}
		}
		this.seqObj = seqObj;
		this.leadSurrogate = leadSurrogate;
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.end = function() {
		if (this.leadSurrogate === -1 && this.seqObj === void 0) return;
		var newBuf = Buffer$3.alloc(10);
		var j = 0;
		if (this.seqObj) {
			var dbcsCode = this.seqObj[DEF_CHAR];
			if (dbcsCode !== void 0) if (dbcsCode < 256) newBuf[j++] = dbcsCode;
			else {
				newBuf[j++] = dbcsCode >> 8;
				newBuf[j++] = dbcsCode & 255;
			}
			this.seqObj = void 0;
		}
		if (this.leadSurrogate !== -1) {
			newBuf[j++] = this.defaultCharSingleByte;
			this.leadSurrogate = -1;
		}
		return newBuf.slice(0, j);
	};
	DBCSEncoder.prototype.findIdx = findIdx;
	function DBCSDecoder(options, codec) {
		this.nodeIdx = 0;
		this.prevBytes = [];
		this.decodeTables = codec.decodeTables;
		this.decodeTableSeq = codec.decodeTableSeq;
		this.defaultCharUnicode = codec.defaultCharUnicode;
		this.gb18030 = codec.gb18030;
	}
	DBCSDecoder.prototype.write = function(buf) {
		var newBuf = Buffer$3.alloc(buf.length * 2);
		var nodeIdx = this.nodeIdx;
		var prevBytes = this.prevBytes;
		var prevOffset = this.prevBytes.length;
		var seqStart = -this.prevBytes.length;
		var uCode;
		for (var i$3 = 0, j = 0; i$3 < buf.length; i$3++) {
			var curByte = i$3 >= 0 ? buf[i$3] : prevBytes[i$3 + prevOffset];
			var uCode = this.decodeTables[nodeIdx][curByte];
			if (uCode >= 0) {} else if (uCode === UNASSIGNED) {
				uCode = this.defaultCharUnicode.charCodeAt(0);
				i$3 = seqStart;
			} else if (uCode === GB18030_CODE) {
				if (i$3 >= 3) var ptr = (buf[i$3 - 3] - 129) * 12600 + (buf[i$3 - 2] - 48) * 1260 + (buf[i$3 - 1] - 129) * 10 + (curByte - 48);
				else var ptr = (prevBytes[i$3 - 3 + prevOffset] - 129) * 12600 + ((i$3 - 2 >= 0 ? buf[i$3 - 2] : prevBytes[i$3 - 2 + prevOffset]) - 48) * 1260 + ((i$3 - 1 >= 0 ? buf[i$3 - 1] : prevBytes[i$3 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
				var idx = findIdx(this.gb18030.gbChars, ptr);
				uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
			} else if (uCode <= NODE_START) {
				nodeIdx = NODE_START - uCode;
				continue;
			} else if (uCode <= SEQ_START) {
				var seq = this.decodeTableSeq[SEQ_START - uCode];
				for (var k = 0; k < seq.length - 1; k++) {
					uCode = seq[k];
					newBuf[j++] = uCode & 255;
					newBuf[j++] = uCode >> 8;
				}
				uCode = seq[seq.length - 1];
			} else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
			if (uCode >= 65536) {
				uCode -= 65536;
				var uCodeLead = 55296 | uCode >> 10;
				newBuf[j++] = uCodeLead & 255;
				newBuf[j++] = uCodeLead >> 8;
				uCode = 56320 | uCode & 1023;
			}
			newBuf[j++] = uCode & 255;
			newBuf[j++] = uCode >> 8;
			nodeIdx = 0;
			seqStart = i$3 + 1;
		}
		this.nodeIdx = nodeIdx;
		this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
		return newBuf.slice(0, j).toString("ucs2");
	};
	DBCSDecoder.prototype.end = function() {
		var ret = "";
		while (this.prevBytes.length > 0) {
			ret += this.defaultCharUnicode;
			var bytesArr = this.prevBytes.slice(1);
			this.prevBytes = [];
			this.nodeIdx = 0;
			if (bytesArr.length > 0) ret += this.write(bytesArr);
		}
		this.prevBytes = [];
		this.nodeIdx = 0;
		return ret;
	};
	function findIdx(table, val) {
		if (table[0] > val) return -1;
		var l = 0;
		var r = table.length;
		while (l < r - 1) {
			var mid = l + (r - l + 1 >> 1);
			if (table[mid] <= val) l = mid;
			else r = mid;
		}
		return l;
	}
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/shiftjis.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			128
		],
		[
			"a1",
			"",
			62
		],
		[
			"8140",
			"",
			9,
			""
		],
		["8180", ""],
		["81b8", ""],
		["81c8", ""],
		["81da", ""],
		["81f0", ""],
		["81fc", ""],
		[
			"824f",
			"",
			9
		],
		[
			"8260",
			"",
			25
		],
		[
			"8281",
			"",
			25
		],
		[
			"829f",
			"",
			82
		],
		[
			"8340",
			"",
			62
		],
		[
			"8380",
			"",
			22
		],
		[
			"839f",
			"",
			16,
			"",
			6
		],
		[
			"83bf",
			"",
			16,
			"",
			6
		],
		[
			"8440",
			"",
			5,
			"",
			25
		],
		[
			"8470",
			"",
			5,
			"",
			7
		],
		[
			"8480",
			"",
			17
		],
		["849f", ""],
		[
			"8740",
			"",
			19,
			"",
			9
		],
		["875f", ""],
		["877e", ""],
		[
			"8780",
			"",
			4,
			""
		],
		["889f", ""],
		["8940", ""],
		["8980", ""],
		["8a40", ""],
		["8a80", ""],
		["8b40", ""],
		["8b80", ""],
		["8c40", ""],
		["8c80", ""],
		["8d40", ""],
		["8d80", ""],
		["8e40", ""],
		["8e80", ""],
		["8f40", ""],
		["8f80", ""],
		["9040", ""],
		["9080", ""],
		["9140", ""],
		["9180", ""],
		["9240", ""],
		["9280", ""],
		["9340", ""],
		["9380", ""],
		["9440", ""],
		["9480", ""],
		["9540", ""],
		["9580", ""],
		["9640", ""],
		["9680", ""],
		["9740", ""],
		["9780", ""],
		["9840", ""],
		["989f", ""],
		["9940", ""],
		["9980", ""],
		["9a40", ""],
		["9a80", ""],
		["9b40", ""],
		["9b80", ""],
		["9c40", ""],
		["9c80", ""],
		["9d40", ""],
		["9d80", ""],
		["9e40", ""],
		["9e80", ""],
		["9f40", ""],
		["9f80", ""],
		["e040", ""],
		["e080", ""],
		["e140", ""],
		["e180", ""],
		["e240", ""],
		["e280", ""],
		["e340", ""],
		["e380", ""],
		["e440", ""],
		["e480", ""],
		["e540", ""],
		["e580", ""],
		["e640", ""],
		["e680", ""],
		["e740", ""],
		["e780", ""],
		["e840", ""],
		["e880", ""],
		["e940", ""],
		["e980", ""],
		["ea40", ""],
		["ea80", ""],
		["ed40", ""],
		["ed80", ""],
		["ee40", ""],
		["ee80", ""],
		[
			"eeef",
			"",
			9,
			""
		],
		[
			"f040",
			"",
			62
		],
		[
			"f080",
			"",
			124
		],
		[
			"f140",
			"",
			62
		],
		[
			"f180",
			"",
			124
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			124
		],
		[
			"f340",
			"",
			62
		],
		[
			"f380",
			"",
			124
		],
		[
			"f440",
			"",
			62
		],
		[
			"f480",
			"",
			124
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			124
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			124
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			124
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			124
		],
		["f940", ""],
		[
			"fa40",
			"",
			9,
			"",
			9,
			""
		],
		["fa80", ""],
		["fb40", ""],
		["fb80", ""],
		["fc40", ""]
	];
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/eucjp.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8ea1",
			"",
			62
		],
		[
			"a1a1",
			"",
			9,
			""
		],
		["a2a1", ""],
		["a2ba", ""],
		["a2ca", ""],
		["a2dc", ""],
		["a2f2", ""],
		["a2fe", ""],
		[
			"a3b0",
			"",
			9
		],
		[
			"a3c1",
			"",
			25
		],
		[
			"a3e1",
			"",
			25
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		["a8a1", ""],
		[
			"ada1",
			"",
			19,
			"",
			9
		],
		["adc0", ""],
		[
			"addf",
			"",
			4,
			""
		],
		["b0a1", ""],
		["b1a1", ""],
		["b2a1", ""],
		["b3a1", ""],
		["b4a1", ""],
		["b5a1", ""],
		["b6a1", ""],
		["b7a1", ""],
		["b8a1", ""],
		["b9a1", ""],
		["baa1", ""],
		["bba1", ""],
		["bca1", ""],
		["bda1", ""],
		["bea1", ""],
		["bfa1", ""],
		["c0a1", ""],
		["c1a1", ""],
		["c2a1", ""],
		["c3a1", ""],
		["c4a1", ""],
		["c5a1", ""],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["c9a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		["d1a1", ""],
		["d2a1", ""],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		[
			"fcf1",
			"",
			9,
			""
		],
		["8fa2af", ""],
		["8fa2c2", ""],
		["8fa2eb", ""],
		["8fa6e1", ""],
		["8fa6e7", ""],
		["8fa6e9", ""],
		["8fa6ec", ""],
		["8fa6f1", ""],
		[
			"8fa7c2",
			"",
			10,
			""
		],
		[
			"8fa7f2",
			"",
			10,
			""
		],
		["8fa9a1", ""],
		["8fa9a4", ""],
		["8fa9a6", ""],
		["8fa9a8", ""],
		["8fa9ab", ""],
		["8fa9af", ""],
		["8fa9c1", ""],
		["8faaa1", ""],
		["8faaba", ""],
		["8faba1", ""],
		["8fabbd", ""],
		["8fabc5", ""],
		["8fb0a1", ""],
		["8fb1a1", ""],
		[
			"8fb2a1",
			"",
			4,
			""
		],
		["8fb3a1", ""],
		["8fb4a1", ""],
		["8fb5a1", ""],
		[
			"8fb6a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fb7a1",
			"",
			4,
			""
		],
		["8fb8a1", ""],
		["8fb9a1", ""],
		[
			"8fbaa1",
			"",
			4,
			""
		],
		["8fbba1", ""],
		[
			"8fbca1",
			"",
			4,
			""
		],
		[
			"8fbda1",
			"",
			4,
			""
		],
		[
			"8fbea1",
			"",
			4,
			""
		],
		["8fbfa1", ""],
		["8fc0a1", ""],
		["8fc1a1", ""],
		["8fc2a1", ""],
		[
			"8fc3a1",
			"",
			4,
			""
		],
		["8fc4a1", ""],
		["8fc5a1", ""],
		["8fc6a1", ""],
		["8fc7a1", ""],
		["8fc8a1", ""],
		[
			"8fc9a1",
			"",
			4,
			"",
			4,
			""
		],
		["8fcaa1", ""],
		["8fcba1", ""],
		[
			"8fcca1",
			"",
			9,
			""
		],
		[
			"8fcda1",
			"",
			5,
			""
		],
		[
			"8fcea1",
			"",
			6,
			""
		],
		["8fcfa1", ""],
		["8fd0a1", ""],
		["8fd1a1", ""],
		[
			"8fd2a1",
			"",
			5
		],
		["8fd3a1", ""],
		[
			"8fd4a1",
			"",
			4,
			""
		],
		["8fd5a1", ""],
		["8fd6a1", ""],
		["8fd7a1", ""],
		["8fd8a1", ""],
		[
			"8fd9a1",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8fdaa1",
			"",
			4,
			""
		],
		[
			"8fdba1",
			"",
			6,
			""
		],
		[
			"8fdca1",
			"",
			4,
			""
		],
		[
			"8fdda1",
			"",
			4,
			""
		],
		[
			"8fdea1",
			"",
			4,
			""
		],
		["8fdfa1", ""],
		["8fe0a1", ""],
		[
			"8fe1a1",
			"",
			4,
			""
		],
		["8fe2a1", ""],
		[
			"8fe3a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"8fe4a1",
			"",
			4,
			""
		],
		[
			"8fe5a1",
			"",
			4,
			""
		],
		["8fe6a1", ""],
		["8fe7a1", ""],
		[
			"8fe8a1",
			"",
			4,
			""
		],
		[
			"8fe9a1",
			"",
			4
		],
		[
			"8feaa1",
			"",
			4,
			""
		],
		[
			"8feba1",
			"",
			4,
			""
		],
		["8feca1", ""],
		[
			"8feda1",
			"",
			4,
			"",
			4,
			""
		]
	];
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp936.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127,
			""
		],
		[
			"8140",
			"",
			5,
			"",
			9,
			"",
			6,
			""
		],
		[
			"8180",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8240",
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			11
		],
		[
			"8280",
			"",
			10,
			"",
			4,
			"",
			7,
			"",
			5,
			"",
			8,
			"",
			20,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8340",
			"",
			17,
			"",
			5,
			"",
			10,
			"",
			4,
			"",
			9,
			""
		],
		[
			"8380",
			"",
			5,
			"",
			13,
			"",
			28,
			"",
			4,
			"",
			4,
			"",
			5
		],
		[
			"8440",
			"",
			5,
			"",
			5,
			""
		],
		[
			"8480",
			"",
			9,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			5,
			"",
			10,
			"",
			7,
			""
		],
		[
			"8540",
			"",
			9,
			""
		],
		[
			"8580",
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			""
		],
		[
			"8640",
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"8680",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8740",
			"",
			7,
			"",
			11,
			"",
			4,
			"",
			4
		],
		[
			"8780",
			"",
			7,
			"",
			6,
			"",
			14,
			"",
			10,
			"",
			6,
			"",
			12,
			"",
			8,
			"",
			5,
			"",
			6
		],
		[
			"8840",
			"",
			9,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8880",
			"",
			4,
			"",
			6,
			"",
			8,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			7
		],
		[
			"8940",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			16,
			""
		],
		[
			"8980",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			17,
			"",
			10,
			"",
			13,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"8a40",
			"",
			4,
			"",
			12,
			""
		],
		[
			"8a80",
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			9,
			"",
			5
		],
		[
			"8b40",
			"",
			8,
			"",
			17,
			"",
			6,
			"",
			13,
			""
		],
		[
			"8b80",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			22,
			"",
			11,
			"",
			25,
			"",
			7,
			"",
			6
		],
		[
			"8c40",
			"",
			7,
			""
		],
		[
			"8c80",
			"",
			8,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			4
		],
		[
			"8d40",
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			9,
			"",
			4
		],
		[
			"8d80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			10,
			"",
			12,
			"",
			21,
			""
		],
		[
			"8e40",
			"",
			21,
			"",
			12,
			"",
			6,
			"",
			12,
			""
		],
		[
			"8e80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			4,
			"",
			6
		],
		[
			"8f40",
			"",
			5,
			"",
			11,
			"",
			8,
			""
		],
		[
			"8f80",
			"",
			6,
			"",
			14,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9040",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9080",
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			18,
			"",
			6
		],
		[
			"9140",
			"",
			6,
			"",
			6,
			"",
			18,
			"",
			4,
			""
		],
		[
			"9180",
			"",
			6,
			"",
			8,
			"",
			9,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			16,
			"",
			13,
			"",
			8,
			"",
			5,
			"",
			4,
			""
		],
		[
			"9240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9280",
			"",
			5,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9340",
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9380",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			9,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9440",
			"",
			24,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			8
		],
		[
			"9480",
			"",
			4,
			"",
			4,
			"",
			14,
			"",
			7,
			"",
			7,
			""
		],
		[
			"9540",
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"9580",
			"",
			4,
			"",
			4,
			"",
			8,
			"",
			4,
			"",
			4,
			"",
			25,
			"",
			7,
			"",
			5,
			""
		],
		[
			"9640",
			"",
			5,
			"",
			4,
			""
		],
		[
			"9680",
			"",
			7,
			"",
			9,
			"",
			7,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			5
		],
		[
			"9740",
			"",
			7,
			"",
			8,
			"",
			7,
			"",
			9,
			""
		],
		[
			"9780",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			9,
			"",
			4,
			"",
			11,
			"",
			7,
			"",
			16,
			""
		],
		[
			"9840",
			"",
			4,
			"",
			5,
			"",
			9,
			""
		],
		[
			"9880",
			"",
			7,
			"",
			5,
			"",
			11,
			"",
			9,
			"",
			9,
			"",
			11,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			7,
			"",
			6,
			""
		],
		[
			"9940",
			"",
			4,
			"",
			10,
			"",
			6,
			"",
			8,
			"",
			4,
			"",
			7,
			"",
			5
		],
		[
			"9980",
			"",
			114,
			"",
			6
		],
		[
			"9a40",
			"",
			11,
			"",
			7,
			"",
			13,
			""
		],
		[
			"9a80",
			"",
			4,
			"",
			7,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"9b40",
			"",
			4,
			""
		],
		[
			"9b80",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9c40",
			"",
			7,
			""
		],
		[
			"9c80",
			"",
			7,
			"",
			7,
			"",
			10,
			"",
			14,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"9d40",
			"",
			7,
			"",
			4,
			"",
			9,
			"",
			6,
			""
		],
		[
			"9d80",
			"",
			9,
			"",
			5,
			"",
			6,
			"",
			12,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			10,
			""
		],
		[
			"9e40",
			"",
			7,
			"",
			32,
			"",
			7,
			"",
			6,
			"",
			6
		],
		[
			"9e80",
			"",
			9,
			"",
			17,
			"",
			13,
			"",
			11,
			"",
			12,
			"",
			12,
			""
		],
		[
			"9f40",
			"",
			6,
			"",
			10,
			"",
			4,
			"",
			10,
			"",
			7,
			""
		],
		[
			"9f80",
			"",
			13,
			"",
			12,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			8,
			"",
			9,
			"",
			4
		],
		[
			"a040",
			"",
			9,
			"",
			5,
			"",
			9,
			"",
			11,
			"",
			19
		],
		[
			"a080",
			"",
			9,
			"",
			6,
			"",
			4,
			"",
			11,
			"",
			11,
			"",
			6,
			""
		],
		[
			"a1a1",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9
		],
		[
			"a2b1",
			"",
			19,
			"",
			19,
			"",
			9
		],
		[
			"a2e5",
			"",
			9
		],
		[
			"a2f1",
			"",
			11
		],
		[
			"a3a1",
			"",
			88,
			""
		],
		[
			"a4a1",
			"",
			82
		],
		[
			"a5a1",
			"",
			85
		],
		[
			"a6a1",
			"",
			16,
			"",
			6
		],
		[
			"a6c1",
			"",
			16,
			"",
			6
		],
		["a6e0", ""],
		["a6ee", ""],
		["a6f4", ""],
		[
			"a7a1",
			"",
			5,
			"",
			25
		],
		[
			"a7d1",
			"",
			5,
			"",
			25
		],
		[
			"a840",
			"",
			35,
			"",
			6
		],
		[
			"a880",
			"",
			7,
			""
		],
		["a8a1", ""],
		["a8bd", ""],
		["a8c0", ""],
		[
			"a8c5",
			"",
			36
		],
		[
			"a940",
			"",
			8,
			""
		],
		["a959", ""],
		["a95c", ""],
		[
			"a960",
			"",
			9,
			"",
			8
		],
		[
			"a980",
			"",
			4,
			""
		],
		["a996", ""],
		[
			"a9a4",
			"",
			75
		],
		[
			"aa40",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"aa80",
			"",
			7,
			"",
			10,
			""
		],
		[
			"ab40",
			"",
			11,
			"",
			4,
			"",
			5,
			"",
			4
		],
		[
			"ab80",
			"",
			6,
			"",
			4
		],
		[
			"ac40",
			"",
			10,
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11
		],
		[
			"ac80",
			"",
			6,
			"",
			12,
			"",
			4,
			""
		],
		[
			"ad40",
			"",
			10,
			"",
			7,
			"",
			15,
			"",
			12
		],
		[
			"ad80",
			"",
			9,
			"",
			8,
			"",
			6,
			""
		],
		[
			"ae40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"ae80",
			"",
			7,
			"",
			6,
			"",
			4,
			""
		],
		[
			"af40",
			"",
			4,
			""
		],
		["af80", ""],
		[
			"b040",
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			7,
			""
		],
		[
			"b080",
			"",
			7,
			"",
			8,
			"",
			9,
			""
		],
		[
			"b140",
			"",
			4,
			"",
			7,
			"",
			10,
			""
		],
		[
			"b180",
			"",
			4,
			"",
			7,
			"",
			7,
			""
		],
		[
			"b240",
			"",
			11,
			"",
			5,
			"",
			11,
			"",
			4
		],
		[
			"b280",
			"",
			12,
			"",
			8,
			"",
			4,
			""
		],
		[
			"b340",
			"",
			5,
			""
		],
		[
			"b380",
			"",
			11,
			"",
			7,
			"",
			6,
			""
		],
		[
			"b440",
			"",
			7,
			"",
			9
		],
		[
			"b480",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"b540",
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			14,
			"",
			4,
			"",
			8,
			""
		],
		[
			"b580",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b640",
			"",
			6,
			"",
			11,
			"",
			10,
			"",
			4,
			"",
			5,
			""
		],
		[
			"b680",
			"",
			6,
			"",
			4,
			""
		],
		[
			"b740",
			"",
			14,
			"",
			5,
			"",
			9,
			"",
			4,
			"",
			16
		],
		[
			"b780",
			"",
			6,
			""
		],
		[
			"b840",
			"",
			4,
			"",
			10,
			"",
			10,
			"",
			9,
			"",
			5,
			""
		],
		[
			"b880",
			"",
			4,
			""
		],
		[
			"b940",
			"",
			5,
			"",
			10,
			"",
			6,
			""
		],
		[
			"b980",
			"",
			7,
			""
		],
		[
			"ba40",
			"",
			4,
			"",
			4,
			"",
			7,
			"",
			5,
			""
		],
		[
			"ba80",
			"",
			4,
			"",
			5,
			"",
			12,
			"",
			5,
			""
		],
		[
			"bb40",
			"",
			9,
			"",
			36,
			"",
			5,
			"",
			9
		],
		[
			"bb80",
			"",
			6,
			"",
			4,
			""
		],
		[
			"bc40",
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			13,
			"",
			5
		],
		[
			"bc80",
			"",
			14,
			"",
			6,
			""
		],
		[
			"bd40",
			"",
			54,
			"",
			7
		],
		[
			"bd80",
			"",
			32,
			""
		],
		[
			"be40",
			"",
			12,
			"",
			6,
			"",
			42
		],
		[
			"be80",
			"",
			32,
			""
		],
		[
			"bf40",
			"",
			62
		],
		[
			"bf80",
			"",
			4,
			"",
			4,
			"",
			21,
			""
		],
		[
			"c040",
			"",
			35,
			"",
			23,
			""
		],
		[
			"c080",
			"",
			6,
			"",
			9,
			""
		],
		[
			"c140",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c180",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c240",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c280",
			"",
			13,
			"",
			5,
			"",
			11,
			""
		],
		[
			"c340",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"c380",
			"",
			12,
			"",
			4,
			""
		],
		[
			"c440",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"c480",
			"",
			7,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c540",
			"",
			14,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"c580",
			"",
			7,
			"",
			7,
			""
		],
		["c640", ""],
		[
			"c680",
			"",
			4,
			"",
			9,
			""
		],
		[
			"c740",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		["c780", ""],
		[
			"c840",
			"",
			4,
			"",
			5,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c880",
			"",
			6,
			"",
			4,
			"",
			4,
			""
		],
		[
			"c940",
			"",
			4,
			"",
			7,
			"",
			12,
			""
		],
		[
			"c980",
			"",
			4,
			"",
			4,
			"",
			10,
			""
		],
		[
			"ca40",
			"",
			8,
			"",
			8,
			"",
			9,
			"",
			4,
			"",
			10
		],
		[
			"ca80",
			"",
			4,
			"",
			8,
			""
		],
		[
			"cb40",
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cb80",
			"",
			5,
			"",
			6,
			"",
			14,
			""
		],
		[
			"cc40",
			"",
			4,
			"",
			10,
			"",
			15,
			"",
			13,
			""
		],
		[
			"cc80",
			"",
			11,
			"",
			4,
			"",
			7,
			""
		],
		[
			"cd40",
			"",
			6,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			4,
			""
		],
		["cd80", ""],
		[
			"ce40",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"ce80",
			"",
			4,
			"",
			6,
			"",
			4,
			""
		],
		[
			"cf40",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			9
		],
		[
			"cf80",
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"d040",
			"",
			13,
			"",
			5,
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"d080",
			"",
			4,
			"",
			4,
			"",
			5,
			""
		],
		[
			"d140",
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5
		],
		[
			"d180",
			"",
			4,
			"",
			4,
			"",
			4,
			""
		],
		[
			"d240",
			"",
			8,
			"",
			24,
			"",
			5,
			"",
			19,
			""
		],
		[
			"d280",
			"",
			26,
			""
		],
		[
			"d340",
			"",
			30,
			"",
			6
		],
		[
			"d380",
			"",
			4,
			"",
			5,
			"",
			21,
			""
		],
		[
			"d440",
			"",
			31,
			"",
			8,
			"",
			21
		],
		[
			"d480",
			"",
			25,
			"",
			6,
			""
		],
		[
			"d540",
			"",
			7,
			"",
			7,
			"",
			46
		],
		[
			"d580",
			"",
			32,
			""
		],
		[
			"d640",
			"",
			34,
			"",
			27
		],
		[
			"d680",
			"",
			30,
			""
		],
		[
			"d740",
			"",
			31,
			"",
			4,
			"",
			25
		],
		[
			"d780",
			"",
			24,
			""
		],
		[
			"d840",
			"",
			8,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			""
		],
		[
			"d880",
			"",
			6,
			"",
			20,
			""
		],
		[
			"d940",
			"",
			62
		],
		[
			"d980",
			"",
			32,
			""
		],
		[
			"da40",
			"",
			14,
			"",
			8,
			"",
			4,
			"",
			9,
			""
		],
		[
			"da80",
			"",
			12,
			""
		],
		[
			"db40",
			"",
			6,
			"",
			7,
			"",
			4,
			""
		],
		[
			"db80",
			"",
			4,
			"",
			5,
			"",
			11,
			""
		],
		[
			"dc40",
			"",
			4,
			"",
			6,
			"",
			6,
			"",
			11,
			"",
			6,
			"",
			7
		],
		[
			"dc80",
			"",
			10,
			"",
			21,
			""
		],
		[
			"dd40",
			"",
			62
		],
		[
			"dd80",
			"",
			32,
			""
		],
		[
			"de40",
			"",
			32,
			""
		],
		[
			"de80",
			"",
			4,
			""
		],
		[
			"df40",
			"",
			5,
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"df80",
			"",
			4,
			""
		],
		[
			"e040",
			"",
			19,
			""
		],
		[
			"e080",
			"",
			10,
			"",
			6,
			"",
			8,
			""
		],
		[
			"e140",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			""
		],
		[
			"e180",
			"",
			10,
			"",
			9,
			"",
			8,
			""
		],
		[
			"e240",
			"",
			62
		],
		[
			"e280",
			"",
			32,
			"",
			5,
			""
		],
		[
			"e340",
			"",
			45,
			"",
			16
		],
		[
			"e380",
			"",
			7,
			"",
			24,
			""
		],
		[
			"e440",
			"",
			5,
			"",
			24,
			"",
			31
		],
		[
			"e480",
			"",
			32,
			""
		],
		[
			"e540",
			"",
			51,
			"",
			10
		],
		[
			"e580",
			"",
			31,
			""
		],
		[
			"e640",
			"",
			34,
			"",
			27
		],
		[
			"e680",
			"",
			29,
			""
		],
		[
			"e740",
			"",
			7,
			"",
			54
		],
		[
			"e780",
			"",
			32,
			"",
			6,
			"",
			4,
			""
		],
		[
			"e840",
			"",
			14,
			"",
			43,
			""
		],
		[
			"e880",
			"",
			20,
			""
		],
		[
			"e940",
			"",
			7,
			"",
			42
		],
		[
			"e980",
			"",
			32,
			""
		],
		[
			"ea40",
			"",
			27,
			"",
			6,
			""
		],
		[
			"ea80",
			"",
			4,
			"",
			12,
			""
		],
		[
			"eb40",
			"",
			9,
			"",
			7,
			"",
			9,
			"",
			6,
			""
		],
		[
			"eb80",
			"",
			4,
			""
		],
		[
			"ec40",
			"",
			8,
			"",
			4,
			"",
			18,
			"",
			7
		],
		[
			"ec80",
			"",
			4,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ed40",
			"",
			6,
			"",
			46
		],
		[
			"ed80",
			"",
			4,
			"",
			23,
			""
		],
		[
			"ee40",
			"",
			62
		],
		[
			"ee80",
			"",
			32,
			"",
			4,
			"",
			6,
			""
		],
		[
			"ef40",
			"",
			5,
			"",
			37,
			"",
			4
		],
		[
			"ef80",
			"",
			30,
			"",
			4,
			"",
			8,
			""
		],
		[
			"f040",
			"",
			4,
			"",
			28,
			"",
			26
		],
		[
			"f080",
			"",
			9,
			"",
			12,
			"",
			4,
			"",
			6,
			""
		],
		[
			"f140",
			"",
			10,
			"",
			47
		],
		[
			"f180",
			"",
			32,
			""
		],
		[
			"f240",
			"",
			62
		],
		[
			"f280",
			"",
			32,
			""
		],
		[
			"f340",
			"",
			17,
			"",
			6,
			"",
			4,
			""
		],
		[
			"f380",
			"",
			8,
			"",
			6,
			""
		],
		[
			"f440",
			"",
			5,
			"",
			10,
			"",
			10,
			"",
			7,
			"",
			5
		],
		[
			"f480",
			"",
			32,
			""
		],
		[
			"f540",
			"",
			62
		],
		[
			"f580",
			"",
			32,
			""
		],
		[
			"f640",
			"",
			62
		],
		[
			"f680",
			"",
			32,
			"",
			5,
			"",
			5,
			"",
			4,
			"",
			7,
			""
		],
		[
			"f740",
			"",
			62
		],
		[
			"f780",
			"",
			4,
			"",
			4,
			""
		],
		[
			"f840",
			"",
			62
		],
		[
			"f880",
			"",
			32
		],
		[
			"f940",
			"",
			62
		],
		[
			"f980",
			"",
			32
		],
		[
			"fa40",
			"",
			62
		],
		[
			"fa80",
			"",
			32
		],
		[
			"fb40",
			"",
			27,
			"",
			9,
			""
		],
		[
			"fb80",
			"",
			5,
			"",
			8,
			"",
			5,
			""
		],
		[
			"fc40",
			"",
			8,
			"",
			4,
			"",
			8,
			"",
			6
		],
		[
			"fc80",
			"",
			4,
			"",
			5,
			"",
			8,
			""
		],
		[
			"fd40",
			"",
			4,
			"",
			4,
			"",
			10,
			"",
			38
		],
		[
			"fd80",
			"",
			5,
			"",
			11,
			"",
			4,
			""
		],
		["fe40", ""]
	];
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gbk-added.json": ((exports, module) => {
	module.exports = [
		[
			"a140",
			"",
			62
		],
		[
			"a180",
			"",
			32
		],
		[
			"a240",
			"",
			62
		],
		[
			"a280",
			"",
			32
		],
		[
			"a2ab",
			"",
			5
		],
		["a2e3", ""],
		["a2ef", ""],
		["a2fd", ""],
		[
			"a340",
			"",
			62
		],
		[
			"a380",
			"",
			31,
			""
		],
		[
			"a440",
			"",
			62
		],
		[
			"a480",
			"",
			32
		],
		[
			"a4f4",
			"",
			10
		],
		[
			"a540",
			"",
			62
		],
		[
			"a580",
			"",
			32
		],
		[
			"a5f7",
			"",
			7
		],
		[
			"a640",
			"",
			62
		],
		[
			"a680",
			"",
			32
		],
		[
			"a6b9",
			"",
			7
		],
		[
			"a6d9",
			"",
			6
		],
		["a6ec", ""],
		["a6f3", ""],
		[
			"a6f6",
			"",
			8
		],
		[
			"a740",
			"",
			62
		],
		[
			"a780",
			"",
			32
		],
		[
			"a7c2",
			"",
			14
		],
		[
			"a7f2",
			"",
			12
		],
		[
			"a896",
			"",
			10
		],
		["a8bc", ""],
		["a8bf", ""],
		["a8c1", ""],
		[
			"a8ea",
			"",
			20
		],
		["a958", ""],
		["a95b", ""],
		["a95d", ""],
		[
			"a989",
			"",
			11
		],
		[
			"a997",
			"",
			12
		],
		[
			"a9f0",
			"",
			14
		],
		[
			"aaa1",
			"",
			93
		],
		[
			"aba1",
			"",
			93
		],
		[
			"aca1",
			"",
			93
		],
		[
			"ada1",
			"",
			93
		],
		[
			"aea1",
			"",
			93
		],
		[
			"afa1",
			"",
			93
		],
		[
			"d7fa",
			"",
			4
		],
		[
			"f8a1",
			"",
			93
		],
		[
			"f9a1",
			"",
			93
		],
		[
			"faa1",
			"",
			93
		],
		[
			"fba1",
			"",
			93
		],
		[
			"fca1",
			"",
			93
		],
		[
			"fda1",
			"",
			93
		],
		["fe50", ""],
		[
			"fe80",
			"",
			6,
			"",
			93
		],
		["8135f437", ""]
	];
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json": ((exports, module) => {
	module.exports = {
		"uChars": [
			128,
			165,
			169,
			178,
			184,
			216,
			226,
			235,
			238,
			244,
			248,
			251,
			253,
			258,
			276,
			284,
			300,
			325,
			329,
			334,
			364,
			463,
			465,
			467,
			469,
			471,
			473,
			475,
			477,
			506,
			594,
			610,
			712,
			716,
			730,
			930,
			938,
			962,
			970,
			1026,
			1104,
			1106,
			8209,
			8215,
			8218,
			8222,
			8231,
			8241,
			8244,
			8246,
			8252,
			8365,
			8452,
			8454,
			8458,
			8471,
			8482,
			8556,
			8570,
			8596,
			8602,
			8713,
			8720,
			8722,
			8726,
			8731,
			8737,
			8740,
			8742,
			8748,
			8751,
			8760,
			8766,
			8777,
			8781,
			8787,
			8802,
			8808,
			8816,
			8854,
			8858,
			8870,
			8896,
			8979,
			9322,
			9372,
			9548,
			9588,
			9616,
			9622,
			9634,
			9652,
			9662,
			9672,
			9676,
			9680,
			9702,
			9735,
			9738,
			9793,
			9795,
			11906,
			11909,
			11913,
			11917,
			11928,
			11944,
			11947,
			11951,
			11956,
			11960,
			11964,
			11979,
			12284,
			12292,
			12312,
			12319,
			12330,
			12351,
			12436,
			12447,
			12535,
			12543,
			12586,
			12842,
			12850,
			12964,
			13200,
			13215,
			13218,
			13253,
			13263,
			13267,
			13270,
			13384,
			13428,
			13727,
			13839,
			13851,
			14617,
			14703,
			14801,
			14816,
			14964,
			15183,
			15471,
			15585,
			16471,
			16736,
			17208,
			17325,
			17330,
			17374,
			17623,
			17997,
			18018,
			18212,
			18218,
			18301,
			18318,
			18760,
			18811,
			18814,
			18820,
			18823,
			18844,
			18848,
			18872,
			19576,
			19620,
			19738,
			19887,
			40870,
			59244,
			59336,
			59367,
			59413,
			59417,
			59423,
			59431,
			59437,
			59443,
			59452,
			59460,
			59478,
			59493,
			63789,
			63866,
			63894,
			63976,
			63986,
			64016,
			64018,
			64021,
			64025,
			64034,
			64037,
			64042,
			65074,
			65093,
			65107,
			65112,
			65127,
			65132,
			65375,
			65510,
			65536
		],
		"gbChars": [
			0,
			36,
			38,
			45,
			50,
			81,
			89,
			95,
			96,
			100,
			103,
			104,
			105,
			109,
			126,
			133,
			148,
			172,
			175,
			179,
			208,
			306,
			307,
			308,
			309,
			310,
			311,
			312,
			313,
			341,
			428,
			443,
			544,
			545,
			558,
			741,
			742,
			749,
			750,
			805,
			819,
			820,
			7922,
			7924,
			7925,
			7927,
			7934,
			7943,
			7944,
			7945,
			7950,
			8062,
			8148,
			8149,
			8152,
			8164,
			8174,
			8236,
			8240,
			8262,
			8264,
			8374,
			8380,
			8381,
			8384,
			8388,
			8390,
			8392,
			8393,
			8394,
			8396,
			8401,
			8406,
			8416,
			8419,
			8424,
			8437,
			8439,
			8445,
			8482,
			8485,
			8496,
			8521,
			8603,
			8936,
			8946,
			9046,
			9050,
			9063,
			9066,
			9076,
			9092,
			9100,
			9108,
			9111,
			9113,
			9131,
			9162,
			9164,
			9218,
			9219,
			11329,
			11331,
			11334,
			11336,
			11346,
			11361,
			11363,
			11366,
			11370,
			11372,
			11375,
			11389,
			11682,
			11686,
			11687,
			11692,
			11694,
			11714,
			11716,
			11723,
			11725,
			11730,
			11736,
			11982,
			11989,
			12102,
			12336,
			12348,
			12350,
			12384,
			12393,
			12395,
			12397,
			12510,
			12553,
			12851,
			12962,
			12973,
			13738,
			13823,
			13919,
			13933,
			14080,
			14298,
			14585,
			14698,
			15583,
			15847,
			16318,
			16434,
			16438,
			16481,
			16729,
			17102,
			17122,
			17315,
			17320,
			17402,
			17418,
			17859,
			17909,
			17911,
			17915,
			17916,
			17936,
			17939,
			17961,
			18664,
			18703,
			18814,
			18962,
			19043,
			33469,
			33470,
			33471,
			33484,
			33485,
			33490,
			33497,
			33501,
			33505,
			33513,
			33520,
			33536,
			33550,
			37845,
			37921,
			37948,
			38029,
			38038,
			38064,
			38065,
			38066,
			38069,
			38075,
			38076,
			38078,
			39108,
			39109,
			39113,
			39114,
			39115,
			39116,
			39265,
			39394,
			189e3
		]
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp949.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		[
			"8141",
			"",
			4,
			"",
			6,
			""
		],
		[
			"8161",
			"",
			9,
			"",
			5,
			""
		],
		[
			"8181",
			"",
			18,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"8241",
			"",
			7,
			"",
			5
		],
		[
			"8261",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8281",
			"",
			7,
			"",
			7,
			"",
			4,
			"",
			10,
			"",
			5,
			"",
			17,
			"",
			7,
			"",
			6,
			"",
			7,
			"",
			18
		],
		[
			"8341",
			"",
			5,
			"",
			5,
			"",
			7
		],
		[
			"8361",
			"",
			18,
			""
		],
		[
			"8381",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			46,
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8441",
			"",
			5,
			"",
			8
		],
		[
			"8461",
			"",
			18
		],
		[
			"8481",
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			18,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8541",
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4
		],
		[
			"8561",
			"",
			5,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8581",
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			29,
			"",
			6,
			"",
			5,
			""
		],
		[
			"8641",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8661",
			"",
			6,
			"",
			10
		],
		[
			"8681",
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			22,
			"",
			4,
			""
		],
		[
			"8741",
			"",
			9,
			"",
			15
		],
		[
			"8761",
			"",
			18,
			""
		],
		[
			"8781",
			"",
			5,
			"",
			7,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			4
		],
		[
			"8841",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"8861",
			"",
			4,
			""
		],
		[
			"8881",
			"",
			15,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			54,
			""
		],
		[
			"8941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"8961",
			"",
			10,
			"",
			5,
			""
		],
		[
			"8981",
			"",
			21,
			"",
			18,
			"",
			18,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			15
		],
		[
			"8a41",
			"",
			10,
			"",
			6,
			""
		],
		[
			"8a61",
			"",
			4,
			"",
			18,
			""
		],
		[
			"8a81",
			"",
			4,
			"",
			19,
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			5,
			"",
			26,
			""
		],
		[
			"8b41",
			"",
			5,
			"",
			4,
			"",
			6,
			""
		],
		[
			"8b61",
			"",
			6,
			"",
			8
		],
		[
			"8b81",
			"",
			52,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			18
		],
		[
			"8c41",
			"",
			15,
			"",
			4
		],
		[
			"8c61",
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"8c81",
			"",
			12,
			"",
			26,
			"",
			50,
			"",
			5,
			"",
			16
		],
		[
			"8d41",
			"",
			16,
			"",
			8
		],
		[
			"8d61",
			"",
			17,
			""
		],
		[
			"8d81",
			"",
			4,
			"",
			33,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			9,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"8e41",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"8e61",
			"",
			4,
			"",
			19
		],
		[
			"8e81",
			"",
			13,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			11,
			"",
			7,
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"8f41",
			"",
			7,
			"",
			17
		],
		[
			"8f61",
			"",
			7,
			"",
			6,
			"",
			4
		],
		[
			"8f81",
			"",
			5,
			"",
			7,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			26,
			"",
			6,
			"",
			5
		],
		[
			"9041",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9061",
			"",
			5,
			"",
			15
		],
		[
			"9081",
			"",
			12,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			4,
			"",
			5,
			"",
			11,
			"",
			33,
			""
		],
		[
			"9141",
			"",
			6,
			"",
			5
		],
		[
			"9161",
			"",
			9,
			"",
			5
		],
		[
			"9181",
			"",
			20,
			"",
			4,
			"",
			5,
			"",
			14,
			"",
			33,
			"",
			7,
			"",
			5,
			"",
			6
		],
		[
			"9241",
			"",
			7,
			"",
			4,
			""
		],
		[
			"9261",
			"",
			7,
			"",
			7,
			"",
			4
		],
		[
			"9281",
			"",
			21,
			"",
			18,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			35,
			""
		],
		[
			"9341",
			"",
			4,
			""
		],
		[
			"9361",
			"",
			6,
			"",
			8
		],
		[
			"9381",
			"",
			37,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			22,
			""
		],
		[
			"9441",
			"",
			5,
			"",
			5,
			"",
			8
		],
		[
			"9461",
			"",
			5,
			"",
			6,
			"",
			12
		],
		[
			"9481",
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			22,
			"",
			4,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			24
		],
		[
			"9541",
			"",
			11,
			"",
			5,
			""
		],
		[
			"9561",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9581",
			"",
			6,
			"",
			35,
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			13,
			"",
			14
		],
		[
			"9641",
			"",
			23,
			""
		],
		[
			"9661",
			"",
			6,
			"",
			5,
			"",
			8
		],
		[
			"9681",
			"",
			10,
			"",
			5,
			"",
			13,
			"",
			33,
			"",
			6,
			"",
			44
		],
		[
			"9741",
			"",
			16,
			"",
			8
		],
		[
			"9761",
			"",
			17,
			"",
			7
		],
		[
			"9781",
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			89,
			""
		],
		[
			"9841",
			"",
			16,
			"",
			5,
			""
		],
		[
			"9861",
			"",
			6,
			"",
			15
		],
		[
			"9881",
			"",
			21,
			"",
			6,
			"",
			5,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9961",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9981",
			"",
			8,
			"",
			5,
			"",
			4,
			"",
			11,
			"",
			5,
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9a41",
			"",
			16
		],
		[
			"9a61",
			"",
			6,
			"",
			6,
			""
		],
		[
			"9a81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			33,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9b41",
			"",
			6,
			"",
			8
		],
		[
			"9b61",
			"",
			17,
			"",
			7
		],
		[
			"9b81",
			"",
			25,
			"",
			4,
			"",
			5,
			"",
			50,
			"",
			22,
			""
		],
		[
			"9c41",
			"",
			4,
			"",
			5,
			"",
			5
		],
		[
			"9c61",
			"",
			8,
			"",
			6,
			"",
			9
		],
		[
			"9c81",
			"",
			8,
			"",
			6,
			"",
			6,
			"",
			9,
			"",
			26,
			"",
			6,
			"",
			5,
			"",
			18,
			"",
			6,
			"",
			12
		],
		[
			"9d41",
			"",
			13,
			"",
			8
		],
		[
			"9d61",
			"",
			25
		],
		[
			"9d81",
			"",
			8,
			"",
			5,
			"",
			9,
			"",
			6,
			"",
			10,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"9e41",
			"",
			7,
			"",
			9,
			""
		],
		[
			"9e61",
			"",
			4,
			"",
			6,
			""
		],
		[
			"9e81",
			"",
			6,
			"",
			6,
			"",
			6,
			"",
			5,
			"",
			10,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			""
		],
		[
			"9f41",
			"",
			5,
			"",
			4,
			"",
			5,
			""
		],
		[
			"9f61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"9f81",
			"",
			4,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			4,
			"",
			6,
			"",
			7,
			"",
			4,
			"",
			4,
			""
		],
		[
			"a041",
			"",
			5,
			"",
			6,
			""
		],
		[
			"a061",
			"",
			5,
			"",
			13
		],
		[
			"a081",
			"",
			4,
			"",
			4,
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			6,
			"",
			5,
			"",
			26,
			"",
			4,
			"",
			5,
			"",
			7,
			""
		],
		[
			"a141",
			"",
			18,
			""
		],
		[
			"a161",
			"",
			6,
			"",
			5,
			""
		],
		[
			"a181",
			"",
			14,
			"",
			5,
			"",
			4,
			"",
			9,
			""
		],
		[
			"a241",
			"",
			5,
			"",
			18
		],
		[
			"a261",
			"",
			6,
			"",
			18
		],
		[
			"a281",
			"",
			7,
			"",
			6,
			"",
			7,
			""
		],
		[
			"a341",
			"",
			6,
			"",
			10,
			""
		],
		[
			"a361",
			"",
			6,
			"",
			16
		],
		[
			"a381",
			"",
			16,
			"",
			4,
			"",
			58,
			"",
			32,
			""
		],
		[
			"a441",
			"",
			5,
			""
		],
		[
			"a461",
			"",
			5,
			"",
			12
		],
		[
			"a481",
			"",
			28,
			"",
			93
		],
		[
			"a541",
			"",
			4,
			"",
			6,
			"",
			5,
			""
		],
		[
			"a561",
			"",
			17,
			"",
			5,
			""
		],
		[
			"a581",
			"",
			16,
			"",
			14,
			"",
			9
		],
		[
			"a5b0",
			"",
			9
		],
		[
			"a5c1",
			"",
			16,
			"",
			6
		],
		[
			"a5e1",
			"",
			16,
			"",
			6
		],
		[
			"a641",
			"",
			19,
			""
		],
		[
			"a661",
			"",
			5,
			"",
			5,
			"",
			6
		],
		[
			"a681",
			"",
			6,
			"",
			18,
			"",
			7
		],
		[
			"a741",
			"",
			4,
			"",
			6,
			"",
			7
		],
		[
			"a761",
			"",
			22,
			""
		],
		[
			"a781",
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			9,
			"",
			9,
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"a841",
			"",
			10,
			"",
			14
		],
		[
			"a861",
			"",
			18,
			"",
			6
		],
		[
			"a881",
			"",
			19,
			"",
			11,
			""
		],
		["a8a6", ""],
		["a8a8", ""],
		[
			"a8b1",
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"a941",
			"",
			14,
			"",
			10
		],
		[
			"a961",
			"",
			18
		],
		[
			"a981",
			"",
			14,
			"",
			6,
			"",
			27,
			"",
			25,
			"",
			14,
			""
		],
		[
			"aa41",
			"",
			6,
			"",
			4,
			""
		],
		[
			"aa61",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"aa81",
			"",
			29,
			"",
			82
		],
		[
			"ab41",
			"",
			6,
			"",
			5,
			""
		],
		[
			"ab61",
			"",
			6,
			"",
			5,
			"",
			5
		],
		[
			"ab81",
			"",
			8,
			"",
			6,
			"",
			12,
			"",
			85
		],
		[
			"ac41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ac61",
			"",
			11,
			"",
			4
		],
		[
			"ac81",
			"",
			28,
			"",
			5,
			"",
			25
		],
		[
			"acd1",
			"",
			5,
			"",
			25
		],
		[
			"ad41",
			"",
			6,
			"",
			5,
			"",
			7
		],
		[
			"ad61",
			"",
			6,
			"",
			10,
			""
		],
		[
			"ad81",
			"",
			5,
			"",
			18,
			""
		],
		[
			"ae41",
			"",
			5,
			"",
			16
		],
		[
			"ae61",
			"",
			5,
			"",
			6,
			"",
			4
		],
		[
			"ae81",
			"",
			6,
			"",
			5,
			""
		],
		[
			"af41",
			"",
			19
		],
		[
			"af61",
			"",
			13,
			"",
			5,
			""
		],
		[
			"af81",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b041",
			"",
			5,
			"",
			5,
			"",
			12
		],
		[
			"b061",
			"",
			5,
			"",
			19
		],
		[
			"b081",
			"",
			13,
			"",
			6,
			"",
			5,
			"",
			7,
			"",
			4,
			""
		],
		[
			"b141",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b161",
			"",
			6,
			"",
			5,
			"",
			11
		],
		[
			"b181",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b241",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b261",
			"",
			18,
			"",
			5,
			""
		],
		[
			"b281",
			"",
			5,
			"",
			18,
			"",
			6,
			""
		],
		[
			"b341",
			"",
			19,
			""
		],
		[
			"b361",
			"",
			5,
			"",
			5,
			"",
			5
		],
		[
			"b381",
			"",
			5,
			"",
			5,
			"",
			19,
			"",
			4,
			""
		],
		[
			"b441",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"b461",
			"",
			6,
			"",
			10,
			""
		],
		[
			"b481",
			"",
			6,
			"",
			18,
			"",
			4,
			"",
			4,
			""
		],
		[
			"b541",
			"",
			14,
			"",
			5
		],
		[
			"b561",
			"",
			5,
			"",
			5,
			"",
			4
		],
		[
			"b581",
			"",
			6,
			"",
			5,
			"",
			11,
			""
		],
		[
			"b641",
			"",
			7,
			"",
			17
		],
		[
			"b661",
			"",
			15,
			""
		],
		[
			"b681",
			"",
			5,
			"",
			6,
			"",
			5,
			""
		],
		[
			"b741",
			"",
			13,
			"",
			6,
			""
		],
		[
			"b761",
			"",
			20,
			""
		],
		[
			"b781",
			"",
			6,
			"",
			14,
			""
		],
		[
			"b841",
			"",
			7,
			"",
			17
		],
		[
			"b861",
			"",
			8,
			"",
			13
		],
		[
			"b881",
			"",
			5,
			"",
			24,
			"",
			4,
			""
		],
		[
			"b941",
			"",
			6,
			"",
			5,
			""
		],
		[
			"b961",
			"",
			14,
			"",
			6,
			""
		],
		[
			"b981",
			"",
			22,
			"",
			4,
			"",
			4,
			""
		],
		[
			"ba41",
			"",
			5,
			"",
			6,
			""
		],
		[
			"ba61",
			"",
			5,
			"",
			4,
			"",
			5
		],
		[
			"ba81",
			"",
			6,
			"",
			9,
			""
		],
		[
			"bb41",
			"",
			4,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bb61",
			"",
			6,
			"",
			5,
			""
		],
		[
			"bb81",
			"",
			31,
			""
		],
		[
			"bc41",
			"",
			17,
			""
		],
		[
			"bc61",
			"",
			5,
			"",
			6,
			""
		],
		[
			"bc81",
			"",
			4,
			"",
			6,
			"",
			5,
			"",
			5,
			"",
			4,
			""
		],
		[
			"bd41",
			"",
			7,
			"",
			7,
			""
		],
		[
			"bd61",
			"",
			5,
			"",
			13
		],
		[
			"bd81",
			"",
			5,
			"",
			25,
			""
		],
		[
			"be41",
			"",
			7,
			"",
			14
		],
		[
			"be61",
			"",
			7,
			"",
			7,
			""
		],
		[
			"be81",
			"",
			4,
			"",
			4,
			"",
			5,
			"",
			8,
			"",
			6,
			""
		],
		[
			"bf41",
			"",
			10,
			"",
			14
		],
		[
			"bf61",
			"",
			18,
			""
		],
		[
			"bf81",
			"",
			5,
			"",
			7,
			"",
			6,
			"",
			5,
			""
		],
		[
			"c041",
			"",
			5,
			"",
			6,
			"",
			5
		],
		[
			"c061",
			"",
			25
		],
		[
			"c081",
			"",
			6,
			"",
			5,
			"",
			7,
			""
		],
		[
			"c141",
			"",
			5,
			"",
			6,
			""
		],
		[
			"c161",
			"",
			19,
			""
		],
		[
			"c181",
			"",
			31,
			""
		],
		[
			"c241",
			"",
			4,
			"",
			5,
			""
		],
		[
			"c261",
			"",
			4,
			"",
			5,
			"",
			6,
			""
		],
		[
			"c281",
			"",
			5,
			"",
			7,
			"",
			9,
			""
		],
		[
			"c341",
			"",
			4
		],
		[
			"c361",
			"",
			4,
			"",
			5,
			"",
			11
		],
		[
			"c381",
			"",
			5,
			"",
			7,
			"",
			5,
			""
		],
		[
			"c441",
			"",
			7,
			"",
			7,
			""
		],
		[
			"c461",
			"",
			5,
			"",
			4
		],
		[
			"c481",
			"",
			5,
			"",
			11,
			""
		],
		[
			"c541",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c561",
			"",
			6,
			"",
			5,
			"",
			4
		],
		[
			"c581",
			"",
			6,
			"",
			5,
			""
		],
		[
			"c641",
			"",
			6,
			"",
			5
		],
		["c6a1", ""],
		["c7a1", ""],
		["c8a1", ""],
		["caa1", ""],
		["cba1", ""],
		["cca1", ""],
		["cda1", ""],
		["cea1", ""],
		["cfa1", ""],
		["d0a1", ""],
		[
			"d1a1",
			"",
			5,
			"",
			4,
			""
		],
		[
			"d2a1",
			"",
			4,
			"",
			5,
			"",
			10,
			"",
			7,
			"",
			5,
			""
		],
		["d3a1", ""],
		["d4a1", ""],
		["d5a1", ""],
		["d6a1", ""],
		["d7a1", ""],
		["d8a1", ""],
		["d9a1", ""],
		["daa1", ""],
		["dba1", ""],
		["dca1", ""],
		["dda1", ""],
		["dea1", ""],
		["dfa1", ""],
		["e0a1", ""],
		["e1a1", ""],
		["e2a1", ""],
		["e3a1", ""],
		["e4a1", ""],
		["e5a1", ""],
		["e6a1", ""],
		["e7a1", ""],
		["e8a1", ""],
		["e9a1", ""],
		["eaa1", ""],
		["eba1", ""],
		["eca1", ""],
		["eda1", ""],
		["eea1", ""],
		["efa1", ""],
		["f0a1", ""],
		["f1a1", ""],
		["f2a1", ""],
		["f3a1", ""],
		["f4a1", ""],
		["f5a1", ""],
		["f6a1", ""],
		["f7a1", ""],
		["f8a1", ""],
		["f9a1", ""],
		["faa1", ""],
		["fba1", ""],
		["fca1", ""],
		["fda1", ""]
	];
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/cp950.json": ((exports, module) => {
	module.exports = [
		[
			"0",
			"\0",
			127
		],
		["a140", ""],
		[
			"a1a1",
			"",
			4,
			""
		],
		[
			"a240",
			"",
			7,
			""
		],
		[
			"a2a1",
			"",
			9,
			"",
			9,
			"",
			8,
			"",
			25,
			"",
			21
		],
		[
			"a340",
			"",
			16,
			"",
			6,
			"",
			16,
			"",
			6,
			"",
			10
		],
		[
			"a3a1",
			"",
			25,
			""
		],
		["a3e1", ""],
		["a440", ""],
		["a4a1", ""],
		["a540", ""],
		["a5a1", ""],
		["a640", ""],
		["a6a1", ""],
		["a740", ""],
		["a7a1", ""],
		["a840", ""],
		["a8a1", ""],
		["a940", ""],
		["a9a1", ""],
		["aa40", ""],
		["aaa1", ""],
		["ab40", ""],
		["aba1", ""],
		["ac40", ""],
		["aca1", ""],
		["ad40", ""],
		["ada1", ""],
		["ae40", ""],
		["aea1", ""],
		["af40", ""],
		["afa1", ""],
		["b040", ""],
		["b0a1", ""],
		["b140", ""],
		["b1a1", ""],
		["b240", ""],
		["b2a1", ""],
		["b340", ""],
		["b3a1", ""],
		["b440", ""],
		["b4a1", ""],
		["b540", ""],
		["b5a1", ""],
		["b640", ""],
		["b6a1", ""],
		["b740", ""],
		["b7a1", ""],
		["b840", ""],
		["b8a1", ""],
		["b940", ""],
		["b9a1", ""],
		["ba40", ""],
		["baa1", ""],
		["bb40", ""],
		["bba1", ""],
		["bc40", ""],
		["bca1", ""],
		["bd40", ""],
		["bda1", ""],
		["be40", ""],
		["bea1", ""],
		["bf40", ""],
		["bfa1", ""],
		["c040", ""],
		["c0a1", ""],
		["c140", ""],
		["c1a1", ""],
		["c240", ""],
		["c2a1", ""],
		["c340", ""],
		["c3a1", ""],
		["c440", ""],
		["c4a1", ""],
		["c540", ""],
		["c5a1", ""],
		["c640", ""],
		["c940", ""],
		["c9a1", ""],
		["ca40", ""],
		["caa1", ""],
		["cb40", ""],
		["cba1", ""],
		["cc40", ""],
		["cca1", ""],
		["cd40", ""],
		["cda1", ""],
		["ce40", ""],
		["cea1", ""],
		["cf40", ""],
		["cfa1", ""],
		["d040", ""],
		["d0a1", ""],
		["d140", ""],
		["d1a1", ""],
		["d240", ""],
		["d2a1", ""],
		["d340", ""],
		["d3a1", ""],
		["d440", ""],
		["d4a1", ""],
		["d540", ""],
		["d5a1", ""],
		["d640", ""],
		["d6a1", ""],
		["d740", ""],
		["d7a1", ""],
		["d840", ""],
		["d8a1", ""],
		["d940", ""],
		["d9a1", ""],
		["da40", ""],
		["daa1", ""],
		["db40", ""],
		["dba1", ""],
		["dc40", ""],
		["dca1", ""],
		["dd40", ""],
		["dda1", ""],
		["de40", ""],
		["dea1", ""],
		["df40", ""],
		["dfa1", ""],
		["e040", ""],
		["e0a1", ""],
		["e140", ""],
		["e1a1", ""],
		["e240", ""],
		["e2a1", ""],
		["e340", ""],
		["e3a1", ""],
		["e440", ""],
		["e4a1", ""],
		["e540", ""],
		["e5a1", ""],
		["e640", ""],
		["e6a1", ""],
		["e740", ""],
		["e7a1", ""],
		["e840", ""],
		["e8a1", ""],
		["e940", ""],
		["e9a1", ""],
		["ea40", ""],
		["eaa1", ""],
		["eb40", ""],
		["eba1", ""],
		["ec40", ""],
		["eca1", ""],
		["ed40", ""],
		["eda1", ""],
		["ee40", ""],
		["eea1", ""],
		["ef40", ""],
		["efa1", ""],
		["f040", ""],
		["f0a1", ""],
		["f140", ""],
		["f1a1", ""],
		["f240", ""],
		["f2a1", ""],
		["f340", ""],
		["f3a1", ""],
		["f440", ""],
		["f4a1", ""],
		["f540", ""],
		["f5a1", ""],
		["f640", ""],
		["f6a1", ""],
		["f740", ""],
		["f7a1", ""],
		["f840", ""],
		["f8a1", ""],
		["f940", ""],
		["f9a1", ""]
	];
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/tables/big5-added.json": ((exports, module) => {
	module.exports = [
		["8740", ""],
		["8767", ""],
		["87a1", ""],
		[
			"8840",
			"",
			4,
			""
		],
		["88a1", ""],
		["8940", ""],
		["8943", ""],
		["8946", ""],
		["894c", ""],
		["89a1", ""],
		["89ab", ""],
		["89b0", ""],
		["89b5", ""],
		["89c1", ""],
		["89c5", ""],
		["8a40", ""],
		["8a43", ""],
		["8a64", ""],
		["8a76", ""],
		["8aa1", ""],
		["8aac", ""],
		["8ab2", ""],
		["8abb", ""],
		["8ac9", ""],
		["8ace", ""],
		["8adf", ""],
		["8af6", ""],
		["8b40", ""],
		["8b55", ""],
		["8ba1", ""],
		["8bde", ""],
		["8c40", ""],
		["8ca1", ""],
		["8ca7", ""],
		["8cc9", ""],
		["8cce", ""],
		["8ce6", ""],
		["8d40", ""],
		["8d42", ""],
		["8da1", ""],
		["8e40", ""],
		["8ea1", ""],
		["8f40", ""],
		["8fa1", ""],
		["9040", ""],
		["90a1", ""],
		["9140", ""],
		["91a1", ""],
		["9240", ""],
		["92a1", ""],
		["9340", ""],
		["93a1", ""],
		["9440", ""],
		["94a1", ""],
		["9540", ""],
		["95a1", ""],
		["9640", ""],
		["96a1", ""],
		["9740", ""],
		["97a1", ""],
		["9840", ""],
		["98a1", ""],
		["9940", ""],
		["99a1", ""],
		["9a40", ""],
		["9aa1", ""],
		["9b40", ""],
		["9b62", ""],
		["9ba1", ""],
		["9c40", ""],
		["9ca1", ""],
		["9d40", ""],
		["9da1", ""],
		["9e40", ""],
		["9ea1", ""],
		["9ead", ""],
		["9ec5", ""],
		["9ef5", ""],
		["9f40", ""],
		["9f4f", ""],
		["9fa1", ""],
		["9fae", ""],
		["9fb2", ""],
		["9fc1", ""],
		["9fc9", ""],
		["9fdb", ""],
		["9fe7", ""],
		["9feb", ""],
		["9ff0", ""],
		["a040", ""],
		["a055", ""],
		["a058", ""],
		["a05b", ""],
		["a063", ""],
		["a073", ""],
		["a0a1", ""],
		["a0a6", ""],
		["a0ae", ""],
		["a0b0", ""],
		["a0d4", ""],
		["a0e2", ""],
		[
			"a3c0",
			"",
			31,
			""
		],
		[
			"c6a1",
			"",
			9,
			"",
			9,
			"",
			9,
			"",
			23
		],
		[
			"c740",
			"",
			58,
			""
		],
		[
			"c7a1",
			"",
			81,
			"",
			5,
			"",
			4
		],
		[
			"c840",
			"",
			26,
			"",
			25,
			""
		],
		["c8a1", ""],
		["c8cd", ""],
		["c8f5", ""],
		["f9fe", ""],
		["fa40", ""],
		["faa1", ""],
		["fb40", ""],
		["fba1", ""],
		["fc40", ""],
		["fca1", ""],
		["fd40", ""],
		["fda1", ""],
		["fe40", ""],
		["fea1", ""]
	];
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/dbcs-data.js": ((exports, module) => {
	module.exports = {
		shiftjis: {
			type: "_dbcs",
			table: function() {
				return require_shiftjis();
			},
			encodeAdd: {
				"": 92,
				"": 126
			},
			encodeSkipVals: [{
				from: 60736,
				to: 63808
			}]
		},
		csshiftjis: "shiftjis",
		mskanji: "shiftjis",
		sjis: "shiftjis",
		windows31j: "shiftjis",
		ms31j: "shiftjis",
		xsjis: "shiftjis",
		windows932: "shiftjis",
		ms932: "shiftjis",
		932: "shiftjis",
		cp932: "shiftjis",
		eucjp: {
			type: "_dbcs",
			table: function() {
				return require_eucjp();
			},
			encodeAdd: {
				"": 92,
				"": 126
			}
		},
		gb2312: "cp936",
		gb231280: "cp936",
		gb23121980: "cp936",
		csgb2312: "cp936",
		csiso58gb231280: "cp936",
		euccn: "cp936",
		windows936: "cp936",
		ms936: "cp936",
		936: "cp936",
		cp936: {
			type: "_dbcs",
			table: function() {
				return require_cp936();
			}
		},
		gbk: {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			}
		},
		xgbk: "gbk",
		isoir58: "gbk",
		gb18030: {
			type: "_dbcs",
			table: function() {
				return require_cp936().concat(require_gbk_added());
			},
			gb18030: function() {
				return require_gb18030_ranges();
			},
			encodeSkipVals: [128],
			encodeAdd: { "": 41699 }
		},
		chinese: "gb18030",
		windows949: "cp949",
		ms949: "cp949",
		949: "cp949",
		cp949: {
			type: "_dbcs",
			table: function() {
				return require_cp949();
			}
		},
		cseuckr: "cp949",
		csksc56011987: "cp949",
		euckr: "cp949",
		isoir149: "cp949",
		korean: "cp949",
		ksc56011987: "cp949",
		ksc56011989: "cp949",
		ksc5601: "cp949",
		windows950: "cp950",
		ms950: "cp950",
		950: "cp950",
		cp950: {
			type: "_dbcs",
			table: function() {
				return require_cp950();
			}
		},
		big5: "big5hkscs",
		big5hkscs: {
			type: "_dbcs",
			table: function() {
				return require_cp950().concat(require_big5_added());
			},
			encodeSkipVals: [
				36457,
				36463,
				36478,
				36523,
				36532,
				36557,
				36560,
				36695,
				36713,
				36718,
				36811,
				36862,
				36973,
				36986,
				37060,
				37084,
				37105,
				37311,
				37551,
				37552,
				37553,
				37554,
				37585,
				37959,
				38090,
				38361,
				38652,
				39285,
				39798,
				39800,
				39803,
				39878,
				39902,
				39916,
				39926,
				40002,
				40019,
				40034,
				40040,
				40043,
				40055,
				40124,
				40125,
				40144,
				40279,
				40282,
				40388,
				40431,
				40443,
				40617,
				40687,
				40701,
				40800,
				40907,
				41079,
				41180,
				41183,
				36812,
				37576,
				38468,
				38637,
				41636,
				41637,
				41639,
				41638,
				41676,
				41678
			]
		},
		cnbig5: "big5hkscs",
		csbig5: "big5hkscs",
		xxbig5: "big5hkscs"
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/index.js
var require_encodings = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/encodings/index.js": ((exports) => {
	var mergeModules$1 = require_merge_exports();
	var modules = [
		require_internal(),
		require_utf32(),
		require_utf16(),
		require_utf7(),
		require_sbcs_codec(),
		require_sbcs_data(),
		require_sbcs_data_generated(),
		require_dbcs_codec(),
		require_dbcs_data()
	];
	for (var i = 0; i < modules.length; i++) {
		var module$1 = modules[i];
		mergeModules$1(exports, module$1);
	}
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/streams.js
var require_streams = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/streams.js": ((exports, module) => {
	var Buffer$2 = require_safer().Buffer;
	module.exports = function(streamModule$1) {
		var Transform = streamModule$1.Transform;
		function IconvLiteEncoderStream(conv, options) {
			this.conv = conv;
			options = options || {};
			options.decodeStrings = false;
			Transform.call(this, options);
		}
		IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteEncoderStream } });
		IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
			if (typeof chunk !== "string") return done(/* @__PURE__ */ new Error("Iconv encoding stream needs strings as its input."));
			try {
				var res = this.conv.write(chunk);
				if (res && res.length) this.push(res);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteEncoderStream.prototype._flush = function(done) {
			try {
				var res = this.conv.end();
				if (res && res.length) this.push(res);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteEncoderStream.prototype.collect = function(cb) {
			var chunks = [];
			this.on("error", cb);
			this.on("data", function(chunk) {
				chunks.push(chunk);
			});
			this.on("end", function() {
				cb(null, Buffer$2.concat(chunks));
			});
			return this;
		};
		function IconvLiteDecoderStream(conv, options) {
			this.conv = conv;
			options = options || {};
			options.encoding = this.encoding = "utf8";
			Transform.call(this, options);
		}
		IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, { constructor: { value: IconvLiteDecoderStream } });
		IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
			if (!Buffer$2.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(/* @__PURE__ */ new Error("Iconv decoding stream needs buffers as its input."));
			try {
				var res = this.conv.write(chunk);
				if (res && res.length) this.push(res, this.encoding);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteDecoderStream.prototype._flush = function(done) {
			try {
				var res = this.conv.end();
				if (res && res.length) this.push(res, this.encoding);
				done();
			} catch (e) {
				done(e);
			}
		};
		IconvLiteDecoderStream.prototype.collect = function(cb) {
			var res = "";
			this.on("error", cb);
			this.on("data", function(chunk) {
				res += chunk;
			});
			this.on("end", function() {
				cb(null, res);
			});
			return this;
		};
		return {
			IconvLiteEncoderStream,
			IconvLiteDecoderStream
		};
	};
}) });

//#endregion
//#region node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js
var require_lib = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/iconv-lite@0.7.0/node_modules/iconv-lite/lib/index.js": ((exports, module) => {
	var Buffer$1 = require_safer().Buffer;
	var bomHandling = require_bom_handling();
	var mergeModules = require_merge_exports();
	var iconv$1 = module.exports;
	iconv$1.encodings = null;
	iconv$1.defaultCharUnicode = "";
	iconv$1.defaultCharSingleByte = "?";
	iconv$1.encode = function encode(str, encoding, options) {
		str = "" + (str || "");
		var encoder = iconv$1.getEncoder(encoding, options);
		var res = encoder.write(str);
		var trail = encoder.end();
		return trail && trail.length > 0 ? Buffer$1.concat([res, trail]) : res;
	};
	iconv$1.decode = function decode(buf, encoding, options) {
		if (typeof buf === "string") {
			if (!iconv$1.skipDecodeWarning) {
				console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
				iconv$1.skipDecodeWarning = true;
			}
			buf = Buffer$1.from("" + (buf || ""), "binary");
		}
		var decoder = iconv$1.getDecoder(encoding, options);
		var res = decoder.write(buf);
		var trail = decoder.end();
		return trail ? res + trail : res;
	};
	iconv$1.encodingExists = function encodingExists(enc) {
		try {
			iconv$1.getCodec(enc);
			return true;
		} catch (e) {
			return false;
		}
	};
	iconv$1.toEncoding = iconv$1.encode;
	iconv$1.fromEncoding = iconv$1.decode;
	iconv$1._codecDataCache = { __proto__: null };
	iconv$1.getCodec = function getCodec(encoding) {
		if (!iconv$1.encodings) {
			var raw = require_encodings();
			iconv$1.encodings = { __proto__: null };
			mergeModules(iconv$1.encodings, raw);
		}
		var enc = iconv$1._canonicalizeEncoding(encoding);
		var codecOptions = {};
		while (true) {
			var codec = iconv$1._codecDataCache[enc];
			if (codec) return codec;
			var codecDef = iconv$1.encodings[enc];
			switch (typeof codecDef) {
				case "string":
					enc = codecDef;
					break;
				case "object":
					for (var key$1 in codecDef) codecOptions[key$1] = codecDef[key$1];
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					enc = codecDef.type;
					break;
				case "function":
					if (!codecOptions.encodingName) codecOptions.encodingName = enc;
					codec = new codecDef(codecOptions, iconv$1);
					iconv$1._codecDataCache[codecOptions.encodingName] = codec;
					return codec;
				default: throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
			}
		}
	};
	iconv$1._canonicalizeEncoding = function(encoding) {
		return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
	};
	iconv$1.getEncoder = function getEncoder(encoding, options) {
		var codec = iconv$1.getCodec(encoding);
		var encoder = new codec.encoder(options, codec);
		if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);
		return encoder;
	};
	iconv$1.getDecoder = function getDecoder$1(encoding, options) {
		var codec = iconv$1.getCodec(encoding);
		var decoder = new codec.decoder(options, codec);
		if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);
		return decoder;
	};
	iconv$1.enableStreamingAPI = function enableStreamingAPI(streamModule$1) {
		if (iconv$1.supportsStreams) return;
		var streams = require_streams()(streamModule$1);
		iconv$1.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
		iconv$1.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
		iconv$1.encodeStream = function encodeStream(encoding, options) {
			return new iconv$1.IconvLiteEncoderStream(iconv$1.getEncoder(encoding, options), options);
		};
		iconv$1.decodeStream = function decodeStream(encoding, options) {
			return new iconv$1.IconvLiteDecoderStream(iconv$1.getDecoder(encoding, options), options);
		};
		iconv$1.supportsStreams = true;
	};
	var streamModule;
	try {
		streamModule = __require("stream");
	} catch (e) {}
	if (streamModule && streamModule.Transform) iconv$1.enableStreamingAPI(streamModule);
	else iconv$1.encodeStream = iconv$1.decodeStream = function() {
		throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
	};
}) });

//#endregion
//#region node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js
var require_unpipe = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/unpipe@1.0.0/node_modules/unpipe/index.js": ((exports, module) => {
	/**
	* Module exports.
	* @public
	*/
	module.exports = unpipe$1;
	/**
	* Determine if there are Node.js pipe-like data listeners.
	* @private
	*/
	function hasPipeDataListeners(stream) {
		var listeners = stream.listeners("data");
		for (var i$3 = 0; i$3 < listeners.length; i$3++) if (listeners[i$3].name === "ondata") return true;
		return false;
	}
	/**
	* Unpipe a stream from all destinations.
	*
	* @param {object} stream
	* @public
	*/
	function unpipe$1(stream) {
		if (!stream) throw new TypeError("argument stream is required");
		if (typeof stream.unpipe === "function") {
			stream.unpipe();
			return;
		}
		if (!hasPipeDataListeners(stream)) return;
		var listener;
		var listeners = stream.listeners("close");
		for (var i$3 = 0; i$3 < listeners.length; i$3++) {
			listener = listeners[i$3];
			if (listener.name !== "cleanup" && listener.name !== "onclose") continue;
			listener.call(stream);
		}
	}
}) });

//#endregion
//#region node_modules/.pnpm/raw-body@3.0.1/node_modules/raw-body/index.js
var require_raw_body = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/raw-body@3.0.1/node_modules/raw-body/index.js": ((exports, module) => {
	/**
	* Module dependencies.
	* @private
	*/
	var asyncHooks = tryRequireAsyncHooks();
	var bytes = require_bytes();
	var createError = require_http_errors();
	var iconv = require_lib();
	var unpipe = require_unpipe();
	/**
	* Module exports.
	* @public
	*/
	module.exports = getRawBody$2;
	/**
	* Module variables.
	* @private
	*/
	var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
	/**
	* Get the decoder for a given encoding.
	*
	* @param {string} encoding
	* @private
	*/
	function getDecoder(encoding) {
		if (!encoding) return null;
		try {
			return iconv.getDecoder(encoding);
		} catch (e) {
			if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
			throw createError(415, "specified encoding unsupported", {
				encoding,
				type: "encoding.unsupported"
			});
		}
	}
	/**
	* Get the raw body of a stream (typically HTTP).
	*
	* @param {object} stream
	* @param {object|string|function} [options]
	* @param {function} [callback]
	* @public
	*/
	function getRawBody$2(stream, options, callback) {
		var done = callback;
		var opts = options || {};
		if (stream === void 0) throw new TypeError("argument stream is required");
		else if (typeof stream !== "object" || stream === null || typeof stream.on !== "function") throw new TypeError("argument stream must be a stream");
		if (options === true || typeof options === "string") opts = { encoding: options };
		if (typeof options === "function") {
			done = options;
			opts = {};
		}
		if (done !== void 0 && typeof done !== "function") throw new TypeError("argument callback must be a function");
		if (!done && !global.Promise) throw new TypeError("argument callback is required");
		var encoding = opts.encoding !== true ? opts.encoding : "utf-8";
		var limit = bytes.parse(opts.limit);
		var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
		if (done) return readStream(stream, encoding, length, limit, wrap(done));
		return new Promise(function executor(resolve$4, reject) {
			readStream(stream, encoding, length, limit, function onRead(err, buf) {
				if (err) return reject(err);
				resolve$4(buf);
			});
		});
	}
	/**
	* Halt a stream.
	*
	* @param {Object} stream
	* @private
	*/
	function halt(stream) {
		unpipe(stream);
		if (typeof stream.pause === "function") stream.pause();
	}
	/**
	* Read the data from the stream.
	*
	* @param {object} stream
	* @param {string} encoding
	* @param {number} length
	* @param {number} limit
	* @param {function} callback
	* @public
	*/
	function readStream(stream, encoding, length, limit, callback) {
		var complete = false;
		var sync = true;
		if (limit !== null && length !== null && length > limit) return done(createError(413, "request entity too large", {
			expected: length,
			length,
			limit,
			type: "entity.too.large"
		}));
		var state = stream._readableState;
		if (stream._decoder || state && (state.encoding || state.decoder)) return done(createError(500, "stream encoding should not be set", { type: "stream.encoding.set" }));
		if (typeof stream.readable !== "undefined" && !stream.readable) return done(createError(500, "stream is not readable", { type: "stream.not.readable" }));
		var received = 0;
		var decoder;
		try {
			decoder = getDecoder(encoding);
		} catch (err) {
			return done(err);
		}
		var buffer$1 = decoder ? "" : [];
		stream.on("aborted", onAborted);
		stream.on("close", cleanup);
		stream.on("data", onData);
		stream.on("end", onEnd);
		stream.on("error", onEnd);
		sync = false;
		function done() {
			var args = new Array(arguments.length);
			for (var i$3 = 0; i$3 < args.length; i$3++) args[i$3] = arguments[i$3];
			complete = true;
			if (sync) process.nextTick(invokeCallback);
			else invokeCallback();
			function invokeCallback() {
				cleanup();
				if (args[0]) halt(stream);
				callback.apply(null, args);
			}
		}
		function onAborted() {
			if (complete) return;
			done(createError(400, "request aborted", {
				code: "ECONNABORTED",
				expected: length,
				length,
				received,
				type: "request.aborted"
			}));
		}
		function onData(chunk) {
			if (complete) return;
			received += chunk.length;
			if (limit !== null && received > limit) done(createError(413, "request entity too large", {
				limit,
				received,
				type: "entity.too.large"
			}));
			else if (decoder) buffer$1 += decoder.write(chunk);
			else buffer$1.push(chunk);
		}
		function onEnd(err) {
			if (complete) return;
			if (err) return done(err);
			if (length !== null && received !== length) done(createError(400, "request size did not match content length", {
				expected: length,
				length,
				received,
				type: "request.size.invalid"
			}));
			else {
				var string = decoder ? buffer$1 + (decoder.end() || "") : Buffer.concat(buffer$1);
				done(null, string);
			}
		}
		function cleanup() {
			buffer$1 = null;
			stream.removeListener("aborted", onAborted);
			stream.removeListener("data", onData);
			stream.removeListener("end", onEnd);
			stream.removeListener("error", onEnd);
			stream.removeListener("close", cleanup);
		}
	}
	/**
	* Try to require async_hooks
	* @private
	*/
	function tryRequireAsyncHooks() {
		try {
			return __require("async_hooks");
		} catch (e) {
			return {};
		}
	}
	/**
	* Wrap function with async resource, if possible.
	* AsyncResource.bind static method backported.
	* @private
	*/
	function wrap(fn) {
		var res;
		if (asyncHooks.AsyncResource) res = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
		if (!res || !res.runInAsyncScope) return fn;
		return res.runInAsyncScope.bind(res, fn, null);
	}
}) });

//#endregion
//#region node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js
var require_content_type = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/content-type@1.0.5/node_modules/content-type/index.js": ((exports) => {
	/**
	* RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
	*
	* parameter     = token "=" ( token / quoted-string )
	* token         = 1*tchar
	* tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
	*               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
	*               / DIGIT / ALPHA
	*               ; any VCHAR, except delimiters
	* quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
	* qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
	* obs-text      = %x80-FF
	* quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
	*/
	var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
	/**
	* RegExp to match quoted-pair in RFC 7230 sec 3.2.6
	*
	* quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
	* obs-text    = %x80-FF
	*/
	var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
	/**
	* RegExp to match type in RFC 7231 sec 3.1.1.1
	*
	* media-type = type "/" subtype
	* type       = token
	* subtype    = token
	*/
	var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
	exports.parse = parse;
	/**
	* Parse media type to object.
	*
	* @param {string|object} string
	* @return {Object}
	* @public
	*/
	function parse(string) {
		if (!string) throw new TypeError("argument string is required");
		var header = typeof string === "object" ? getcontenttype(string) : string;
		if (typeof header !== "string") throw new TypeError("argument string is required to be a string");
		var index = header.indexOf(";");
		var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
		if (!TYPE_REGEXP.test(type)) throw new TypeError("invalid media type");
		var obj = new ContentType(type.toLowerCase());
		if (index !== -1) {
			var key$1;
			var match;
			var value;
			PARAM_REGEXP.lastIndex = index;
			while (match = PARAM_REGEXP.exec(header)) {
				if (match.index !== index) throw new TypeError("invalid parameter format");
				index += match[0].length;
				key$1 = match[1].toLowerCase();
				value = match[2];
				if (value.charCodeAt(0) === 34) {
					value = value.slice(1, -1);
					if (value.indexOf("\\") !== -1) value = value.replace(QESC_REGEXP, "$1");
				}
				obj.parameters[key$1] = value;
			}
			if (index !== header.length) throw new TypeError("invalid parameter format");
		}
		return obj;
	}
	/**
	* Get content-type from req/res objects.
	*
	* @param {object}
	* @return {Object}
	* @private
	*/
	function getcontenttype(obj) {
		var header;
		if (typeof obj.getHeader === "function") header = obj.getHeader("content-type");
		else if (typeof obj.headers === "object") header = obj.headers && obj.headers["content-type"];
		if (typeof header !== "string") throw new TypeError("content-type header is missing from object");
		return header;
	}
	/**
	* Class to represent a content type.
	* @private
	*/
	function ContentType(type) {
		this.parameters = Object.create(null);
		this.type = type;
	}
}) });

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.18.1/node_modules/@modelcontextprotocol/sdk/dist/esm/server/sse.js
var import_raw_body$1 = /* @__PURE__ */ __toESM(require_raw_body(), 1);
var import_content_type$1 = /* @__PURE__ */ __toESM(require_content_type(), 1);
const MAXIMUM_MESSAGE_SIZE$1 = "4mb";
/**
* Server transport for SSE: this will send messages over an SSE connection and receive messages from HTTP POST requests.
*
* This transport is only available in Node.js environments.
*/
var SSEServerTransport = class {
	/**
	* Creates a new SSE server transport, which will direct the client to POST messages to the relative or absolute URL identified by `_endpoint`.
	*/
	constructor(_endpoint, res, options) {
		this._endpoint = _endpoint;
		this.res = res;
		this._sessionId = randomUUID();
		this._options = options || { enableDnsRebindingProtection: false };
	}
	/**
	* Validates request headers for DNS rebinding protection.
	* @returns Error message if validation fails, undefined if validation passes.
	*/
	validateRequestHeaders(req) {
		if (!this._options.enableDnsRebindingProtection) return;
		if (this._options.allowedHosts && this._options.allowedHosts.length > 0) {
			const hostHeader = req.headers.host;
			if (!hostHeader || !this._options.allowedHosts.includes(hostHeader)) return `Invalid Host header: ${hostHeader}`;
		}
		if (this._options.allowedOrigins && this._options.allowedOrigins.length > 0) {
			const originHeader = req.headers.origin;
			if (!originHeader || !this._options.allowedOrigins.includes(originHeader)) return `Invalid Origin header: ${originHeader}`;
		}
	}
	/**
	* Handles the initial SSE connection request.
	*
	* This should be called when a GET request is made to establish the SSE stream.
	*/
	async start() {
		if (this._sseResponse) throw new Error("SSEServerTransport already started! If using Server class, note that connect() calls start() automatically.");
		this.res.writeHead(200, {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache, no-transform",
			Connection: "keep-alive"
		});
		const endpointUrl = new URL$1(this._endpoint, "http://localhost");
		endpointUrl.searchParams.set("sessionId", this._sessionId);
		const relativeUrlWithSession = endpointUrl.pathname + endpointUrl.search + endpointUrl.hash;
		this.res.write(`event: endpoint\ndata: ${relativeUrlWithSession}\n\n`);
		this._sseResponse = this.res;
		this.res.on("close", () => {
			var _a;
			this._sseResponse = void 0;
			(_a = this.onclose) === null || _a === void 0 || _a.call(this);
		});
	}
	/**
	* Handles incoming POST messages.
	*
	* This should be called when a POST request is made to send a message to the server.
	*/
	async handlePostMessage(req, res, parsedBody) {
		var _a, _b, _c, _d;
		if (!this._sseResponse) {
			const message = "SSE connection not established";
			res.writeHead(500).end(message);
			throw new Error(message);
		}
		const validationError = this.validateRequestHeaders(req);
		if (validationError) {
			res.writeHead(403).end(validationError);
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, new Error(validationError));
			return;
		}
		const authInfo = req.auth;
		const requestInfo = { headers: req.headers };
		let body;
		try {
			const ct = import_content_type$1.parse((_b = req.headers["content-type"]) !== null && _b !== void 0 ? _b : "");
			if (ct.type !== "application/json") throw new Error(`Unsupported content-type: ${ct.type}`);
			body = parsedBody !== null && parsedBody !== void 0 ? parsedBody : await (0, import_raw_body$1.default)(req, {
				limit: MAXIMUM_MESSAGE_SIZE$1,
				encoding: (_c = ct.parameters.charset) !== null && _c !== void 0 ? _c : "utf-8"
			});
		} catch (error) {
			res.writeHead(400).end(String(error));
			(_d = this.onerror) === null || _d === void 0 || _d.call(this, error);
			return;
		}
		try {
			await this.handleMessage(typeof body === "string" ? JSON.parse(body) : body, {
				requestInfo,
				authInfo
			});
		} catch (_e) {
			res.writeHead(400).end(`Invalid message: ${body}`);
			return;
		}
		res.writeHead(202).end("Accepted");
	}
	/**
	* Handle a client message, regardless of how it arrived. This can be used to inform the server of messages that arrive via a means different than HTTP POST.
	*/
	async handleMessage(message, extra) {
		var _a, _b;
		let parsedMessage;
		try {
			parsedMessage = JSONRPCMessageSchema.parse(message);
		} catch (error) {
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
			throw error;
		}
		(_b = this.onmessage) === null || _b === void 0 || _b.call(this, parsedMessage, extra);
	}
	async close() {
		var _a, _b;
		(_a = this._sseResponse) === null || _a === void 0 || _a.end();
		this._sseResponse = void 0;
		(_b = this.onclose) === null || _b === void 0 || _b.call(this);
	}
	async send(message) {
		if (!this._sseResponse) throw new Error("Not connected");
		this._sseResponse.write(`event: message\ndata: ${JSON.stringify(message)}\n\n`);
	}
	/**
	* Returns the session ID for this transport.
	*
	* This can be used to route incoming POST requests.
	*/
	get sessionId() {
		return this._sessionId;
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.18.1/node_modules/@modelcontextprotocol/sdk/dist/esm/server/streamableHttp.js
var import_raw_body = /* @__PURE__ */ __toESM(require_raw_body(), 1);
var import_content_type = /* @__PURE__ */ __toESM(require_content_type(), 1);
const MAXIMUM_MESSAGE_SIZE = "4mb";
/**
* Server transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.
* It supports both SSE streaming and direct HTTP responses.
*
* Usage example:
*
* ```typescript
* // Stateful mode - server sets the session ID
* const statefulTransport = new StreamableHTTPServerTransport({
*   sessionIdGenerator: () => randomUUID(),
* });
*
* // Stateless mode - explicitly set session ID to undefined
* const statelessTransport = new StreamableHTTPServerTransport({
*   sessionIdGenerator: undefined,
* });
*
* // Using with pre-parsed request body
* app.post('/mcp', (req, res) => {
*   transport.handleRequest(req, res, req.body);
* });
* ```
*
* In stateful mode:
* - Session ID is generated and included in response headers
* - Session ID is always included in initialization responses
* - Requests with invalid session IDs are rejected with 404 Not Found
* - Non-initialization requests without a session ID are rejected with 400 Bad Request
* - State is maintained in-memory (connections, message history)
*
* In stateless mode:
* - No Session ID is included in any responses
* - No session validation is performed
*/
var StreamableHTTPServerTransport = class {
	constructor(options) {
		var _a, _b;
		this._started = false;
		this._streamMapping = /* @__PURE__ */ new Map();
		this._requestToStreamMapping = /* @__PURE__ */ new Map();
		this._requestResponseMap = /* @__PURE__ */ new Map();
		this._initialized = false;
		this._enableJsonResponse = false;
		this._standaloneSseStreamId = "_GET_stream";
		this.sessionIdGenerator = options.sessionIdGenerator;
		this._enableJsonResponse = (_a = options.enableJsonResponse) !== null && _a !== void 0 ? _a : false;
		this._eventStore = options.eventStore;
		this._onsessioninitialized = options.onsessioninitialized;
		this._onsessionclosed = options.onsessionclosed;
		this._allowedHosts = options.allowedHosts;
		this._allowedOrigins = options.allowedOrigins;
		this._enableDnsRebindingProtection = (_b = options.enableDnsRebindingProtection) !== null && _b !== void 0 ? _b : false;
	}
	/**
	* Starts the transport. This is required by the Transport interface but is a no-op
	* for the Streamable HTTP transport as connections are managed per-request.
	*/
	async start() {
		if (this._started) throw new Error("Transport already started");
		this._started = true;
	}
	/**
	* Validates request headers for DNS rebinding protection.
	* @returns Error message if validation fails, undefined if validation passes.
	*/
	validateRequestHeaders(req) {
		if (!this._enableDnsRebindingProtection) return;
		if (this._allowedHosts && this._allowedHosts.length > 0) {
			const hostHeader = req.headers.host;
			if (!hostHeader || !this._allowedHosts.includes(hostHeader)) return `Invalid Host header: ${hostHeader}`;
		}
		if (this._allowedOrigins && this._allowedOrigins.length > 0) {
			const originHeader = req.headers.origin;
			if (!originHeader || !this._allowedOrigins.includes(originHeader)) return `Invalid Origin header: ${originHeader}`;
		}
	}
	/**
	* Handles an incoming HTTP request, whether GET or POST
	*/
	async handleRequest(req, res, parsedBody) {
		var _a;
		const validationError = this.validateRequestHeaders(req);
		if (validationError) {
			res.writeHead(403).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: validationError
				},
				id: null
			}));
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, new Error(validationError));
			return;
		}
		if (req.method === "POST") await this.handlePostRequest(req, res, parsedBody);
		else if (req.method === "GET") await this.handleGetRequest(req, res);
		else if (req.method === "DELETE") await this.handleDeleteRequest(req, res);
		else await this.handleUnsupportedRequest(res);
	}
	/**
	* Handles GET requests for SSE stream
	*/
	async handleGetRequest(req, res) {
		const acceptHeader = req.headers.accept;
		if (!(acceptHeader === null || acceptHeader === void 0 ? void 0 : acceptHeader.includes("text/event-stream"))) {
			res.writeHead(406).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Not Acceptable: Client must accept text/event-stream"
				},
				id: null
			}));
			return;
		}
		if (!this.validateSession(req, res)) return;
		if (!this.validateProtocolVersion(req, res)) return;
		if (this._eventStore) {
			const lastEventId = req.headers["last-event-id"];
			if (lastEventId) {
				await this.replayEvents(lastEventId, res);
				return;
			}
		}
		const headers = {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache, no-transform",
			Connection: "keep-alive"
		};
		if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
		if (this._streamMapping.get(this._standaloneSseStreamId) !== void 0) {
			res.writeHead(409).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Conflict: Only one SSE stream is allowed per session"
				},
				id: null
			}));
			return;
		}
		res.writeHead(200, headers).flushHeaders();
		this._streamMapping.set(this._standaloneSseStreamId, res);
		res.on("close", () => {
			this._streamMapping.delete(this._standaloneSseStreamId);
		});
		res.on("error", (error) => {
			var _a;
			(_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
		});
	}
	/**
	* Replays events that would have been sent after the specified event ID
	* Only used when resumability is enabled
	*/
	async replayEvents(lastEventId, res) {
		var _a, _b;
		if (!this._eventStore) return;
		try {
			const headers = {
				"Content-Type": "text/event-stream",
				"Cache-Control": "no-cache, no-transform",
				Connection: "keep-alive"
			};
			if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
			res.writeHead(200, headers).flushHeaders();
			const streamId = await ((_a = this._eventStore) === null || _a === void 0 ? void 0 : _a.replayEventsAfter(lastEventId, { send: async (eventId, message) => {
				var _a$1;
				if (!this.writeSSEEvent(res, message, eventId)) {
					(_a$1 = this.onerror) === null || _a$1 === void 0 || _a$1.call(this, /* @__PURE__ */ new Error("Failed replay events"));
					res.end();
				}
			} }));
			this._streamMapping.set(streamId, res);
			res.on("error", (error) => {
				var _a$1;
				(_a$1 = this.onerror) === null || _a$1 === void 0 || _a$1.call(this, error);
			});
		} catch (error) {
			(_b = this.onerror) === null || _b === void 0 || _b.call(this, error);
		}
	}
	/**
	* Writes an event to the SSE stream with proper formatting
	*/
	writeSSEEvent(res, message, eventId) {
		let eventData = `event: message\n`;
		if (eventId) eventData += `id: ${eventId}\n`;
		eventData += `data: ${JSON.stringify(message)}\n\n`;
		return res.write(eventData);
	}
	/**
	* Handles unsupported requests (PUT, PATCH, etc.)
	*/
	async handleUnsupportedRequest(res) {
		res.writeHead(405, { "Allow": "GET, POST, DELETE" }).end(JSON.stringify({
			jsonrpc: "2.0",
			error: {
				code: -32e3,
				message: "Method not allowed."
			},
			id: null
		}));
	}
	/**
	* Handles POST requests containing JSON-RPC messages
	*/
	async handlePostRequest(req, res, parsedBody) {
		var _a, _b, _c, _d, _e;
		try {
			const acceptHeader = req.headers.accept;
			if (!(acceptHeader === null || acceptHeader === void 0 ? void 0 : acceptHeader.includes("application/json")) || !acceptHeader.includes("text/event-stream")) {
				res.writeHead(406).end(JSON.stringify({
					jsonrpc: "2.0",
					error: {
						code: -32e3,
						message: "Not Acceptable: Client must accept both application/json and text/event-stream"
					},
					id: null
				}));
				return;
			}
			const ct = req.headers["content-type"];
			if (!ct || !ct.includes("application/json")) {
				res.writeHead(415).end(JSON.stringify({
					jsonrpc: "2.0",
					error: {
						code: -32e3,
						message: "Unsupported Media Type: Content-Type must be application/json"
					},
					id: null
				}));
				return;
			}
			const authInfo = req.auth;
			const requestInfo = { headers: req.headers };
			let rawMessage;
			if (parsedBody !== void 0) rawMessage = parsedBody;
			else {
				const parsedCt = import_content_type.parse(ct);
				const body = await (0, import_raw_body.default)(req, {
					limit: MAXIMUM_MESSAGE_SIZE,
					encoding: (_a = parsedCt.parameters.charset) !== null && _a !== void 0 ? _a : "utf-8"
				});
				rawMessage = JSON.parse(body.toString());
			}
			let messages;
			if (Array.isArray(rawMessage)) messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
			else messages = [JSONRPCMessageSchema.parse(rawMessage)];
			const isInitializationRequest = messages.some(isInitializeRequest);
			if (isInitializationRequest) {
				if (this._initialized && this.sessionId !== void 0) {
					res.writeHead(400).end(JSON.stringify({
						jsonrpc: "2.0",
						error: {
							code: -32600,
							message: "Invalid Request: Server already initialized"
						},
						id: null
					}));
					return;
				}
				if (messages.length > 1) {
					res.writeHead(400).end(JSON.stringify({
						jsonrpc: "2.0",
						error: {
							code: -32600,
							message: "Invalid Request: Only one initialization request is allowed"
						},
						id: null
					}));
					return;
				}
				this.sessionId = (_b = this.sessionIdGenerator) === null || _b === void 0 ? void 0 : _b.call(this);
				this._initialized = true;
				if (this.sessionId && this._onsessioninitialized) await Promise.resolve(this._onsessioninitialized(this.sessionId));
			}
			if (!isInitializationRequest) {
				if (!this.validateSession(req, res)) return;
				if (!this.validateProtocolVersion(req, res)) return;
			}
			const hasRequests = messages.some(isJSONRPCRequest);
			if (!hasRequests) {
				res.writeHead(202).end();
				for (const message of messages) (_c = this.onmessage) === null || _c === void 0 || _c.call(this, message, {
					authInfo,
					requestInfo
				});
			} else if (hasRequests) {
				const streamId = randomUUID();
				if (!this._enableJsonResponse) {
					const headers = {
						"Content-Type": "text/event-stream",
						"Cache-Control": "no-cache",
						Connection: "keep-alive"
					};
					if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
					res.writeHead(200, headers);
				}
				for (const message of messages) if (isJSONRPCRequest(message)) {
					this._streamMapping.set(streamId, res);
					this._requestToStreamMapping.set(message.id, streamId);
				}
				res.on("close", () => {
					this._streamMapping.delete(streamId);
				});
				res.on("error", (error) => {
					var _a$1;
					(_a$1 = this.onerror) === null || _a$1 === void 0 || _a$1.call(this, error);
				});
				for (const message of messages) (_d = this.onmessage) === null || _d === void 0 || _d.call(this, message, {
					authInfo,
					requestInfo
				});
			}
		} catch (error) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32700,
					message: "Parse error",
					data: String(error)
				},
				id: null
			}));
			(_e = this.onerror) === null || _e === void 0 || _e.call(this, error);
		}
	}
	/**
	* Handles DELETE requests to terminate sessions
	*/
	async handleDeleteRequest(req, res) {
		var _a;
		if (!this.validateSession(req, res)) return;
		if (!this.validateProtocolVersion(req, res)) return;
		await Promise.resolve((_a = this._onsessionclosed) === null || _a === void 0 ? void 0 : _a.call(this, this.sessionId));
		await this.close();
		res.writeHead(200).end();
	}
	/**
	* Validates session ID for non-initialization requests
	* Returns true if the session is valid, false otherwise
	*/
	validateSession(req, res) {
		if (this.sessionIdGenerator === void 0) return true;
		if (!this._initialized) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Bad Request: Server not initialized"
				},
				id: null
			}));
			return false;
		}
		const sessionId = req.headers["mcp-session-id"];
		if (!sessionId) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Bad Request: Mcp-Session-Id header is required"
				},
				id: null
			}));
			return false;
		} else if (Array.isArray(sessionId)) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: "Bad Request: Mcp-Session-Id header must be a single value"
				},
				id: null
			}));
			return false;
		} else if (sessionId !== this.sessionId) {
			res.writeHead(404).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32001,
					message: "Session not found"
				},
				id: null
			}));
			return false;
		}
		return true;
	}
	validateProtocolVersion(req, res) {
		var _a;
		let protocolVersion = (_a = req.headers["mcp-protocol-version"]) !== null && _a !== void 0 ? _a : DEFAULT_NEGOTIATED_PROTOCOL_VERSION;
		if (Array.isArray(protocolVersion)) protocolVersion = protocolVersion[protocolVersion.length - 1];
		if (!SUPPORTED_PROTOCOL_VERSIONS.includes(protocolVersion)) {
			res.writeHead(400).end(JSON.stringify({
				jsonrpc: "2.0",
				error: {
					code: -32e3,
					message: `Bad Request: Unsupported protocol version (supported versions: ${SUPPORTED_PROTOCOL_VERSIONS.join(", ")})`
				},
				id: null
			}));
			return false;
		}
		return true;
	}
	async close() {
		var _a;
		this._streamMapping.forEach((response) => {
			response.end();
		});
		this._streamMapping.clear();
		this._requestResponseMap.clear();
		(_a = this.onclose) === null || _a === void 0 || _a.call(this);
	}
	async send(message, options) {
		let requestId = options === null || options === void 0 ? void 0 : options.relatedRequestId;
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) requestId = message.id;
		if (requestId === void 0) {
			if (isJSONRPCResponse(message) || isJSONRPCError(message)) throw new Error("Cannot send a response on a standalone SSE stream unless resuming a previous client request");
			const standaloneSse = this._streamMapping.get(this._standaloneSseStreamId);
			if (standaloneSse === void 0) return;
			let eventId;
			if (this._eventStore) eventId = await this._eventStore.storeEvent(this._standaloneSseStreamId, message);
			this.writeSSEEvent(standaloneSse, message, eventId);
			return;
		}
		const streamId = this._requestToStreamMapping.get(requestId);
		const response = this._streamMapping.get(streamId);
		if (!streamId) throw new Error(`No connection established for request ID: ${String(requestId)}`);
		if (!this._enableJsonResponse) {
			let eventId;
			if (this._eventStore) eventId = await this._eventStore.storeEvent(streamId, message);
			if (response) this.writeSSEEvent(response, message, eventId);
		}
		if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
			this._requestResponseMap.set(requestId, message);
			const relatedIds = Array.from(this._requestToStreamMapping.entries()).filter(([_, streamId$1]) => this._streamMapping.get(streamId$1) === response).map(([id]) => id);
			if (relatedIds.every((id) => this._requestResponseMap.has(id))) {
				if (!response) throw new Error(`No connection established for request ID: ${String(requestId)}`);
				if (this._enableJsonResponse) {
					const headers = { "Content-Type": "application/json" };
					if (this.sessionId !== void 0) headers["mcp-session-id"] = this.sessionId;
					const responses = relatedIds.map((id) => this._requestResponseMap.get(id));
					response.writeHead(200, headers);
					if (responses.length === 1) response.end(JSON.stringify(responses[0]));
					else response.end(JSON.stringify(responses));
				} else response.end();
				for (const id of relatedIds) {
					this._requestResponseMap.delete(id);
					this._requestToStreamMapping.delete(id);
				}
			}
		}
	}
};

//#endregion
//#region src/startHTTPServer.ts
const getBody = (request) => {
	return new Promise((resolve$4) => {
		const bodyParts = [];
		let body;
		request.on("data", (chunk) => {
			bodyParts.push(chunk);
		}).on("end", () => {
			body = Buffer.concat(bodyParts).toString();
			try {
				resolve$4(JSON.parse(body));
			} catch (error) {
				console.error("[mcp-proxy] error parsing body", error);
				resolve$4(null);
			}
		});
	});
};
const createJsonRpcErrorResponse = (code, message) => {
	return JSON.stringify({
		error: {
			code,
			message
		},
		id: null,
		jsonrpc: "2.0"
	});
};
const getWWWAuthenticateHeader = (oauth) => {
	if (!oauth?.protectedResource?.resource) return;
	return `Bearer resource_metadata="${oauth.protectedResource.resource}/.well-known/oauth-protected-resource"`;
};
const handleResponseError = (error, res) => {
	if (error instanceof Response) {
		const fixedHeaders = {};
		error.headers.forEach((value, key$1) => {
			if (fixedHeaders[key$1]) if (Array.isArray(fixedHeaders[key$1])) fixedHeaders[key$1].push(value);
			else fixedHeaders[key$1] = [fixedHeaders[key$1], value];
			else fixedHeaders[key$1] = value;
		});
		res.writeHead(error.status, error.statusText, fixedHeaders).end(error.statusText);
		return true;
	}
	return false;
};
const cleanupServer = async (server, onClose) => {
	if (onClose) await onClose(server);
	try {
		await server.close();
	} catch (error) {
		console.error("[mcp-proxy] error closing server", error);
	}
};
const handleStreamRequest = async ({ activeTransports, authenticate, createServer, enableJsonResponse, endpoint, eventStore, oauth, onClose, onConnect, req, res, stateless }) => {
	if (req.method === "POST" && new URL(req.url, "http://localhost").pathname === endpoint) {
		try {
			const sessionId = Array.isArray(req.headers["mcp-session-id"]) ? req.headers["mcp-session-id"][0] : req.headers["mcp-session-id"];
			let transport;
			let server;
			const body = await getBody(req);
			if (stateless && authenticate) try {
				const authResult = await authenticate(req);
				if (!authResult || typeof authResult === "object" && "authenticated" in authResult && !authResult.authenticated) {
					const errorMessage = authResult && typeof authResult === "object" && "error" in authResult && typeof authResult.error === "string" ? authResult.error : "Unauthorized: Authentication failed";
					res.setHeader("Content-Type", "application/json");
					const wwwAuthHeader = getWWWAuthenticateHeader(oauth);
					if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
					res.writeHead(401).end(JSON.stringify({
						error: {
							code: -32e3,
							message: errorMessage
						},
						id: body?.id ?? null,
						jsonrpc: "2.0"
					}));
					return true;
				}
			} catch (error) {
				const errorMessage = error instanceof Error ? error.message : "Unauthorized: Authentication error";
				console.error("Authentication error:", error);
				res.setHeader("Content-Type", "application/json");
				const wwwAuthHeader = getWWWAuthenticateHeader(oauth);
				if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
				res.writeHead(401).end(JSON.stringify({
					error: {
						code: -32e3,
						message: errorMessage
					},
					id: body?.id ?? null,
					jsonrpc: "2.0"
				}));
				return true;
			}
			if (sessionId) {
				const activeTransport = activeTransports[sessionId];
				if (!activeTransport) {
					res.setHeader("Content-Type", "application/json");
					res.writeHead(404).end(createJsonRpcErrorResponse(-32001, "Session not found"));
					return true;
				}
				transport = activeTransport.transport;
				server = activeTransport.server;
			} else if (!sessionId && isInitializeRequest(body)) {
				transport = new StreamableHTTPServerTransport({
					enableJsonResponse,
					eventStore: eventStore || new InMemoryEventStore(),
					onsessioninitialized: (_sessionId) => {
						if (!stateless && _sessionId) activeTransports[_sessionId] = {
							server,
							transport
						};
					},
					sessionIdGenerator: stateless ? void 0 : randomUUID
				});
				let isCleaningUp = false;
				transport.onclose = async () => {
					const sid = transport.sessionId;
					if (isCleaningUp) return;
					isCleaningUp = true;
					if (!stateless && sid && activeTransports[sid]) {
						await cleanupServer(server, onClose);
						delete activeTransports[sid];
					} else if (stateless) await cleanupServer(server, onClose);
				};
				try {
					server = await createServer(req);
				} catch (error) {
					const errorMessage = error instanceof Error ? error.message : String(error);
					if (errorMessage.includes("Authentication") || errorMessage.includes("Invalid JWT") || errorMessage.includes("Token") || errorMessage.includes("Unauthorized")) {
						res.setHeader("Content-Type", "application/json");
						const wwwAuthHeader = getWWWAuthenticateHeader(oauth);
						if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
						res.writeHead(401).end(JSON.stringify({
							error: {
								code: -32e3,
								message: errorMessage
							},
							id: body?.id ?? null,
							jsonrpc: "2.0"
						}));
						return true;
					}
					if (handleResponseError(error, res)) return true;
					res.writeHead(500).end("Error creating server");
					return true;
				}
				server.connect(transport);
				if (onConnect) await onConnect(server);
				await transport.handleRequest(req, res, body);
				return true;
			} else if (stateless && !sessionId && !isInitializeRequest(body)) {
				transport = new StreamableHTTPServerTransport({
					enableJsonResponse,
					eventStore: eventStore || new InMemoryEventStore(),
					onsessioninitialized: () => {},
					sessionIdGenerator: void 0
				});
				try {
					server = await createServer(req);
				} catch (error) {
					const errorMessage = error instanceof Error ? error.message : String(error);
					if (errorMessage.includes("Authentication") || errorMessage.includes("Invalid JWT") || errorMessage.includes("Token") || errorMessage.includes("Unauthorized")) {
						res.setHeader("Content-Type", "application/json");
						const wwwAuthHeader = getWWWAuthenticateHeader(oauth);
						if (wwwAuthHeader) res.setHeader("WWW-Authenticate", wwwAuthHeader);
						res.writeHead(401).end(JSON.stringify({
							error: {
								code: -32e3,
								message: errorMessage
							},
							id: body?.id ?? null,
							jsonrpc: "2.0"
						}));
						return true;
					}
					if (handleResponseError(error, res)) return true;
					res.writeHead(500).end("Error creating server");
					return true;
				}
				server.connect(transport);
				if (onConnect) await onConnect(server);
				await transport.handleRequest(req, res, body);
				return true;
			} else {
				res.setHeader("Content-Type", "application/json");
				res.writeHead(400).end(createJsonRpcErrorResponse(-32e3, "Bad Request: No valid session ID provided"));
				return true;
			}
			await transport.handleRequest(req, res, body);
			return true;
		} catch (error) {
			console.error("[mcp-proxy] error handling request", error);
			res.setHeader("Content-Type", "application/json");
			res.writeHead(500).end(createJsonRpcErrorResponse(-32603, "Internal Server Error"));
		}
		return true;
	}
	if (req.method === "GET" && new URL(req.url, "http://localhost").pathname === endpoint) {
		const sessionId = req.headers["mcp-session-id"];
		const activeTransport = sessionId ? activeTransports[sessionId] : void 0;
		if (!sessionId) {
			res.writeHead(400).end("No sessionId");
			return true;
		}
		if (!activeTransport) {
			res.writeHead(400).end("No active transport");
			return true;
		}
		const lastEventId = req.headers["last-event-id"];
		if (lastEventId) console.log(`[mcp-proxy] client reconnecting with Last-Event-ID ${lastEventId} for session ID ${sessionId}`);
		else console.log(`[mcp-proxy] establishing new SSE stream for session ID ${sessionId}`);
		await activeTransport.transport.handleRequest(req, res);
		return true;
	}
	if (req.method === "DELETE" && new URL(req.url, "http://localhost").pathname === endpoint) {
		console.log("[mcp-proxy] received delete request");
		const sessionId = req.headers["mcp-session-id"];
		if (!sessionId) {
			res.writeHead(400).end("Invalid or missing sessionId");
			return true;
		}
		console.log("[mcp-proxy] received delete request for session", sessionId);
		const activeTransport = activeTransports[sessionId];
		if (!activeTransport) {
			res.writeHead(400).end("No active transport");
			return true;
		}
		try {
			await activeTransport.transport.handleRequest(req, res);
			await cleanupServer(activeTransport.server, onClose);
		} catch (error) {
			console.error("[mcp-proxy] error handling delete request", error);
			res.writeHead(500).end("Error handling delete request");
		}
		return true;
	}
	return false;
};
const handleSSERequest = async ({ activeTransports, createServer, endpoint, onClose, onConnect, req, res }) => {
	if (req.method === "GET" && new URL(req.url, "http://localhost").pathname === endpoint) {
		const transport = new SSEServerTransport("/messages", res);
		let server;
		try {
			server = await createServer(req);
		} catch (error) {
			if (handleResponseError(error, res)) return true;
			res.writeHead(500).end("Error creating server");
			return true;
		}
		activeTransports[transport.sessionId] = transport;
		let closed = false;
		let isCleaningUp = false;
		res.on("close", async () => {
			closed = true;
			if (isCleaningUp) return;
			isCleaningUp = true;
			await cleanupServer(server, onClose);
			delete activeTransports[transport.sessionId];
		});
		try {
			await server.connect(transport);
			await transport.send({
				jsonrpc: "2.0",
				method: "sse/connection",
				params: { message: "SSE Connection established" }
			});
			if (onConnect) await onConnect(server);
		} catch (error) {
			if (!closed) {
				console.error("[mcp-proxy] error connecting to server", error);
				res.writeHead(500).end("Error connecting to server");
			}
		}
		return true;
	}
	if (req.method === "POST" && req.url?.startsWith("/messages")) {
		const sessionId = new URL(req.url, "https://example.com").searchParams.get("sessionId");
		if (!sessionId) {
			res.writeHead(400).end("No sessionId");
			return true;
		}
		const activeTransport = activeTransports[sessionId];
		if (!activeTransport) {
			res.writeHead(400).end("No active transport");
			return true;
		}
		await activeTransport.handlePostMessage(req, res);
		return true;
	}
	return false;
};
const startHTTPServer = async ({ apiKey, authenticate, createServer, enableJsonResponse, eventStore, host = "::", oauth, onClose, onConnect, onUnhandledRequest, port, sseEndpoint = "/sse", stateless, streamEndpoint = "/mcp" }) => {
	const activeSSETransports = {};
	const activeStreamTransports = {};
	const authMiddleware = new AuthenticationMiddleware({
		apiKey,
		oauth
	});
	/**
	* @author https://dev.classmethod.jp/articles/mcp-sse/
	*/
	const httpServer = http.createServer(async (req, res) => {
		if (req.headers.origin) try {
			const origin = new URL(req.headers.origin);
			res.setHeader("Access-Control-Allow-Origin", origin.origin);
			res.setHeader("Access-Control-Allow-Credentials", "true");
			res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
			res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization, Accept, Mcp-Session-Id, Last-Event-Id");
			res.setHeader("Access-Control-Expose-Headers", "Mcp-Session-Id");
		} catch (error) {
			console.error("[mcp-proxy] error parsing origin", error);
		}
		if (req.method === "OPTIONS") {
			res.writeHead(204);
			res.end();
			return;
		}
		if (req.method === "GET" && req.url === `/ping`) {
			res.writeHead(200).end("pong");
			return;
		}
		if (!authMiddleware.validateRequest(req)) {
			const authResponse = authMiddleware.getUnauthorizedResponse();
			res.writeHead(401, authResponse.headers);
			res.end(authResponse.body);
			return;
		}
		if (sseEndpoint && await handleSSERequest({
			activeTransports: activeSSETransports,
			createServer,
			endpoint: sseEndpoint,
			onClose,
			onConnect,
			req,
			res
		})) return;
		if (streamEndpoint && await handleStreamRequest({
			activeTransports: activeStreamTransports,
			authenticate,
			createServer,
			enableJsonResponse,
			endpoint: streamEndpoint,
			eventStore,
			oauth,
			onClose,
			onConnect,
			req,
			res,
			stateless
		})) return;
		if (onUnhandledRequest) await onUnhandledRequest(req, res);
		else res.writeHead(404).end();
	});
	await new Promise((resolve$4) => {
		httpServer.listen(port, host, () => {
			resolve$4(void 0);
		});
	});
	return { close: async () => {
		for (const transport of Object.values(activeSSETransports)) await transport.close();
		for (const transport of Object.values(activeStreamTransports)) await transport.transport.close();
		return new Promise((resolve$4, reject) => {
			httpServer.close((error) => {
				if (error) {
					reject(error);
					return;
				}
				resolve$4();
			});
		});
	} };
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.18.1/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
/**
* The default request timeout, in miliseconds.
*/
const DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
/**
* Implements MCP protocol framing on top of a pluggable transport, including
* features like request/response linking, notifications, and progress.
*/
var Protocol = class {
	constructor(_options) {
		this._options = _options;
		this._requestMessageId = 0;
		this._requestHandlers = /* @__PURE__ */ new Map();
		this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
		this._notificationHandlers = /* @__PURE__ */ new Map();
		this._responseHandlers = /* @__PURE__ */ new Map();
		this._progressHandlers = /* @__PURE__ */ new Map();
		this._timeoutInfo = /* @__PURE__ */ new Map();
		this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
		this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
			const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
			controller === null || controller === void 0 || controller.abort(notification.params.reason);
		});
		this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
			this._onprogress(notification);
		});
		this.setRequestHandler(PingRequestSchema, (_request) => ({}));
	}
	_setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
		this._timeoutInfo.set(messageId, {
			timeoutId: setTimeout(onTimeout, timeout),
			startTime: Date.now(),
			timeout,
			maxTotalTimeout,
			resetTimeoutOnProgress,
			onTimeout
		});
	}
	_resetTimeout(messageId) {
		const info = this._timeoutInfo.get(messageId);
		if (!info) return false;
		const totalElapsed = Date.now() - info.startTime;
		if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
			this._timeoutInfo.delete(messageId);
			throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
				maxTotalTimeout: info.maxTotalTimeout,
				totalElapsed
			});
		}
		clearTimeout(info.timeoutId);
		info.timeoutId = setTimeout(info.onTimeout, info.timeout);
		return true;
	}
	_cleanupTimeout(messageId) {
		const info = this._timeoutInfo.get(messageId);
		if (info) {
			clearTimeout(info.timeoutId);
			this._timeoutInfo.delete(messageId);
		}
	}
	/**
	* Attaches to the given transport, starts it, and starts listening for messages.
	*
	* The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
	*/
	async connect(transport) {
		var _a, _b, _c;
		this._transport = transport;
		const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
		this._transport.onclose = () => {
			_onclose === null || _onclose === void 0 || _onclose();
			this._onclose();
		};
		const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
		this._transport.onerror = (error) => {
			_onerror === null || _onerror === void 0 || _onerror(error);
			this._onerror(error);
		};
		const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
		this._transport.onmessage = (message, extra) => {
			_onmessage === null || _onmessage === void 0 || _onmessage(message, extra);
			if (isJSONRPCResponse(message) || isJSONRPCError(message)) this._onresponse(message);
			else if (isJSONRPCRequest(message)) this._onrequest(message, extra);
			else if (isJSONRPCNotification(message)) this._onnotification(message);
			else this._onerror(/* @__PURE__ */ new Error(`Unknown message type: ${JSON.stringify(message)}`));
		};
		await this._transport.start();
	}
	_onclose() {
		var _a;
		const responseHandlers = this._responseHandlers;
		this._responseHandlers = /* @__PURE__ */ new Map();
		this._progressHandlers.clear();
		this._pendingDebouncedNotifications.clear();
		this._transport = void 0;
		(_a = this.onclose) === null || _a === void 0 || _a.call(this);
		const error = new McpError(ErrorCode.ConnectionClosed, "Connection closed");
		for (const handler of responseHandlers.values()) handler(error);
	}
	_onerror(error) {
		var _a;
		(_a = this.onerror) === null || _a === void 0 || _a.call(this, error);
	}
	_onnotification(notification) {
		var _a;
		const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
		if (handler === void 0) return;
		Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(/* @__PURE__ */ new Error(`Uncaught error in notification handler: ${error}`)));
	}
	_onrequest(request, extra) {
		var _a, _b;
		const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
		const capturedTransport = this._transport;
		if (handler === void 0) {
			capturedTransport === null || capturedTransport === void 0 || capturedTransport.send({
				jsonrpc: "2.0",
				id: request.id,
				error: {
					code: ErrorCode.MethodNotFound,
					message: "Method not found"
				}
			}).catch((error) => this._onerror(/* @__PURE__ */ new Error(`Failed to send an error response: ${error}`)));
			return;
		}
		const abortController = new AbortController();
		this._requestHandlerAbortControllers.set(request.id, abortController);
		const fullExtra = {
			signal: abortController.signal,
			sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
			_meta: (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta,
			sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),
			sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, {
				...options,
				relatedRequestId: request.id
			}),
			authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
			requestId: request.id,
			requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
		};
		Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {
			if (abortController.signal.aborted) return;
			return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
				result,
				jsonrpc: "2.0",
				id: request.id
			});
		}, (error) => {
			var _a$1;
			if (abortController.signal.aborted) return;
			return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
				jsonrpc: "2.0",
				id: request.id,
				error: {
					code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
					message: (_a$1 = error.message) !== null && _a$1 !== void 0 ? _a$1 : "Internal error"
				}
			});
		}).catch((error) => this._onerror(/* @__PURE__ */ new Error(`Failed to send response: ${error}`))).finally(() => {
			this._requestHandlerAbortControllers.delete(request.id);
		});
	}
	_onprogress(notification) {
		const { progressToken,...params } = notification.params;
		const messageId = Number(progressToken);
		const handler = this._progressHandlers.get(messageId);
		if (!handler) {
			this._onerror(/* @__PURE__ */ new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
			return;
		}
		const responseHandler = this._responseHandlers.get(messageId);
		const timeoutInfo = this._timeoutInfo.get(messageId);
		if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) try {
			this._resetTimeout(messageId);
		} catch (error) {
			responseHandler(error);
			return;
		}
		handler(params);
	}
	_onresponse(response) {
		const messageId = Number(response.id);
		const handler = this._responseHandlers.get(messageId);
		if (handler === void 0) {
			this._onerror(/* @__PURE__ */ new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
			return;
		}
		this._responseHandlers.delete(messageId);
		this._progressHandlers.delete(messageId);
		this._cleanupTimeout(messageId);
		if (isJSONRPCResponse(response)) handler(response);
		else {
			const error = new McpError(response.error.code, response.error.message, response.error.data);
			handler(error);
		}
	}
	get transport() {
		return this._transport;
	}
	/**
	* Closes the connection.
	*/
	async close() {
		var _a;
		await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
	}
	/**
	* Sends a request and wait for a response.
	*
	* Do not use this method to emit notifications! Use notification() instead.
	*/
	request(request, resultSchema, options) {
		const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
		return new Promise((resolve$4, reject) => {
			var _a, _b, _c, _d, _e, _f;
			if (!this._transport) {
				reject(/* @__PURE__ */ new Error("Not connected"));
				return;
			}
			if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) this.assertCapabilityForMethod(request.method);
			(_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 || _b.throwIfAborted();
			const messageId = this._requestMessageId++;
			const jsonrpcRequest = {
				...request,
				jsonrpc: "2.0",
				id: messageId
			};
			if (options === null || options === void 0 ? void 0 : options.onprogress) {
				this._progressHandlers.set(messageId, options.onprogress);
				jsonrpcRequest.params = {
					...request.params,
					_meta: {
						...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
						progressToken: messageId
					}
				};
			}
			const cancel = (reason) => {
				var _a$1;
				this._responseHandlers.delete(messageId);
				this._progressHandlers.delete(messageId);
				this._cleanupTimeout(messageId);
				(_a$1 = this._transport) === null || _a$1 === void 0 || _a$1.send({
					jsonrpc: "2.0",
					method: "notifications/cancelled",
					params: {
						requestId: messageId,
						reason: String(reason)
					}
				}, {
					relatedRequestId,
					resumptionToken,
					onresumptiontoken
				}).catch((error) => this._onerror(/* @__PURE__ */ new Error(`Failed to send cancellation: ${error}`)));
				reject(reason);
			};
			this._responseHandlers.set(messageId, (response) => {
				var _a$1;
				if ((_a$1 = options === null || options === void 0 ? void 0 : options.signal) === null || _a$1 === void 0 ? void 0 : _a$1.aborted) return;
				if (response instanceof Error) return reject(response);
				try {
					const result = resultSchema.parse(response.result);
					resolve$4(result);
				} catch (error) {
					reject(error);
				}
			});
			(_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 || _d.addEventListener("abort", () => {
				var _a$1;
				cancel((_a$1 = options === null || options === void 0 ? void 0 : options.signal) === null || _a$1 === void 0 ? void 0 : _a$1.reason);
			});
			const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : DEFAULT_REQUEST_TIMEOUT_MSEC;
			const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
			this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
			this._transport.send(jsonrpcRequest, {
				relatedRequestId,
				resumptionToken,
				onresumptiontoken
			}).catch((error) => {
				this._cleanupTimeout(messageId);
				reject(error);
			});
		});
	}
	/**
	* Emits a notification, which is a one-way message that does not expect a response.
	*/
	async notification(notification, options) {
		var _a, _b;
		if (!this._transport) throw new Error("Not connected");
		this.assertNotificationCapability(notification.method);
		if (((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : []).includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId)) {
			if (this._pendingDebouncedNotifications.has(notification.method)) return;
			this._pendingDebouncedNotifications.add(notification.method);
			Promise.resolve().then(() => {
				var _a$1;
				this._pendingDebouncedNotifications.delete(notification.method);
				if (!this._transport) return;
				const jsonrpcNotification$1 = {
					...notification,
					jsonrpc: "2.0"
				};
				(_a$1 = this._transport) === null || _a$1 === void 0 || _a$1.send(jsonrpcNotification$1, options).catch((error) => this._onerror(error));
			});
			return;
		}
		const jsonrpcNotification = {
			...notification,
			jsonrpc: "2.0"
		};
		await this._transport.send(jsonrpcNotification, options);
	}
	/**
	* Registers a handler to invoke when this protocol object receives a request with the given method.
	*
	* Note that this will replace any previous request handler for the same method.
	*/
	setRequestHandler(requestSchema, handler) {
		const method = requestSchema.shape.method.value;
		this.assertRequestHandlerCapability(method);
		this._requestHandlers.set(method, (request, extra) => {
			return Promise.resolve(handler(requestSchema.parse(request), extra));
		});
	}
	/**
	* Removes the request handler for the given method.
	*/
	removeRequestHandler(method) {
		this._requestHandlers.delete(method);
	}
	/**
	* Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
	*/
	assertCanSetRequestHandler(method) {
		if (this._requestHandlers.has(method)) throw new Error(`A request handler for ${method} already exists, which would be overridden`);
	}
	/**
	* Registers a handler to invoke when this protocol object receives a notification with the given method.
	*
	* Note that this will replace any previous notification handler for the same method.
	*/
	setNotificationHandler(notificationSchema, handler) {
		this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));
	}
	/**
	* Removes the notification handler for the given method.
	*/
	removeNotificationHandler(method) {
		this._notificationHandlers.delete(method);
	}
};
function mergeCapabilities(base, additional) {
	return Object.entries(additional).reduce((acc, [key$1, value]) => {
		if (value && typeof value === "object") acc[key$1] = acc[key$1] ? {
			...acc[key$1],
			...value
		} : value;
		else acc[key$1] = value;
		return acc;
	}, { ...base });
}

//#endregion
//#region node_modules/.pnpm/uri-js@4.4.1/node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/uri-js@4.4.1/node_modules/uri-js/dist/es5/uri.all.js": ((exports, module) => {
	/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
	(function(global$1, factory) {
		typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global$1.URI = global$1.URI || {});
	})(exports, (function(exports$1) {
		function merge() {
			for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) sets[_key] = arguments[_key];
			if (sets.length > 1) {
				sets[0] = sets[0].slice(0, -1);
				var xl = sets.length - 1;
				for (var x = 1; x < xl; ++x) sets[x] = sets[x].slice(1, -1);
				sets[xl] = sets[xl].slice(1);
				return sets.join("");
			} else return sets[0];
		}
		function subexp(str) {
			return "(?:" + str + ")";
		}
		function typeOf(o) {
			return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
		}
		function toUpperCase(str) {
			return str.toUpperCase();
		}
		function toArray(obj) {
			return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
		}
		function assign(target, source) {
			var obj = target;
			if (source) for (var key$1 in source) obj[key$1] = source[key$1];
			return obj;
		}
		function buildExps(isIRI) {
			var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$$1 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$$1 = subexp(subexp("%[EFef]" + HEXDIG$$$1 + "%" + HEXDIG$$$1 + HEXDIG$$$1 + "%" + HEXDIG$$$1 + HEXDIG$$$1) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$$1 + "%" + HEXDIG$$$1 + HEXDIG$$$1) + "|" + subexp("%" + HEXDIG$$$1 + HEXDIG$$$1)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$$1 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$$1 + "|" + merge(UNRESERVED$$$1, SUB_DELIMS$$, "[\\:]")) + "*");
			subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$);
			var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$$1 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([
				IPV6ADDRESS1$,
				IPV6ADDRESS2$,
				IPV6ADDRESS3$,
				IPV6ADDRESS4$,
				IPV6ADDRESS5$,
				IPV6ADDRESS6$,
				IPV6ADDRESS7$,
				IPV6ADDRESS8$,
				IPV6ADDRESS9$
			].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$$1 + "|" + PCT_ENCODED$$1) + "+");
			subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$);
			var IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$$1 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$$1 + "+\\." + merge(UNRESERVED$$$1, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$$1 + "|" + merge(UNRESERVED$$$1, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$$1 + "|" + merge(UNRESERVED$$$1, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$$1 + "|" + merge(UNRESERVED$$$1, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")";
			subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$);
			var QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?");
			subexp(URI$ + "|" + RELATIVE$);
			subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?");
			"" + SCHEME$ + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + subexp("\\#(" + FRAGMENT$ + ")");
			"" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + subexp("\\#(" + FRAGMENT$ + ")");
			"" + SCHEME$ + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")");
			"" + subexp("\\#(" + FRAGMENT$ + ")");
			"" + subexp("(" + USERINFO$ + ")@") + HOST$ + subexp("\\:(" + PORT$ + ")");
			return {
				NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
				NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$$1, SUB_DELIMS$$), "g"),
				NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$$1, SUB_DELIMS$$), "g"),
				NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$$1, SUB_DELIMS$$), "g"),
				NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$$1, SUB_DELIMS$$), "g"),
				NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$$1, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
				NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$$1, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
				ESCAPE: new RegExp(merge("[^]", UNRESERVED$$$1, SUB_DELIMS$$), "g"),
				UNRESERVED: new RegExp(UNRESERVED$$$1, "g"),
				OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$$1, RESERVED$$), "g"),
				PCT_ENCODED: new RegExp(PCT_ENCODED$$1, "g"),
				IPV4ADDRESS: /* @__PURE__ */ new RegExp("^(" + IPV4ADDRESS$ + ")$"),
				IPV6ADDRESS: /* @__PURE__ */ new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$$1 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
			};
		}
		var URI_PROTOCOL = buildExps(false);
		var IRI_PROTOCOL = buildExps(true);
		var slicedToArray = function() {
			function sliceIterator(arr, i$3) {
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try {
					for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
						_arr.push(_s.value);
						if (i$3 && _arr.length === i$3) break;
					}
				} catch (err) {
					_d = true;
					_e = err;
				} finally {
					try {
						if (!_n && _i["return"]) _i["return"]();
					} finally {
						if (_d) throw _e;
					}
				}
				return _arr;
			}
			return function(arr, i$3) {
				if (Array.isArray(arr)) return arr;
				else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i$3);
				else throw new TypeError("Invalid attempt to destructure non-iterable instance");
			};
		}();
		var toConsumableArray = function(arr) {
			if (Array.isArray(arr)) {
				for (var i$3 = 0, arr2 = Array(arr.length); i$3 < arr.length; i$3++) arr2[i$3] = arr[i$3];
				return arr2;
			} else return Array.from(arr);
		};
		/** Highest positive signed 32-bit float value */
		var maxInt = 2147483647;
		/** Bootstring parameters */
		var base = 36;
		var tMin = 1;
		var tMax = 26;
		var skew = 38;
		var damp = 700;
		var initialBias = 72;
		var initialN = 128;
		var delimiter = "-";
		/** Regular expressions */
		var regexPunycode = /^xn--/;
		var regexNonASCII = /[^\0-\x7E]/;
		var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
		/** Error messages */
		var errors = {
			"overflow": "Overflow: input needs wider integers to process",
			"not-basic": "Illegal input >= 0x80 (not a basic code point)",
			"invalid-input": "Invalid input"
		};
		/** Convenience shortcuts */
		var baseMinusTMin = base - tMin;
		var floor = Math.floor;
		var stringFromCharCode = String.fromCharCode;
		/**
		* A generic error utility function.
		* @private
		* @param {String} type The error type.
		* @returns {Error} Throws a `RangeError` with the applicable error message.
		*/
		function error$1(type) {
			throw new RangeError(errors[type]);
		}
		/**
		* A generic `Array#map` utility function.
		* @private
		* @param {Array} array The array to iterate over.
		* @param {Function} callback The function that gets called for every array
		* item.
		* @returns {Array} A new array of values returned by the callback function.
		*/
		function map$1(array, fn) {
			var result = [];
			var length = array.length;
			while (length--) result[length] = fn(array[length]);
			return result;
		}
		/**
		* A simple `Array#map`-like wrapper to work with domain name strings or email
		* addresses.
		* @private
		* @param {String} domain The domain name or email address.
		* @param {Function} callback The function that gets called for every
		* character.
		* @returns {Array} A new string of characters returned by the callback
		* function.
		*/
		function mapDomain(string, fn) {
			var parts = string.split("@");
			var result = "";
			if (parts.length > 1) {
				result = parts[0] + "@";
				string = parts[1];
			}
			string = string.replace(regexSeparators, ".");
			var labels = string.split(".");
			var encoded = map$1(labels, fn).join(".");
			return result + encoded;
		}
		/**
		* Creates an array containing the numeric code points of each Unicode
		* character in the string. While JavaScript uses UCS-2 internally,
		* this function will convert a pair of surrogate halves (each of which
		* UCS-2 exposes as separate characters) into a single code point,
		* matching UTF-16.
		* @see `punycode.ucs2.encode`
		* @see <https://mathiasbynens.be/notes/javascript-encoding>
		* @memberOf punycode.ucs2
		* @name decode
		* @param {String} string The Unicode input string (UCS-2).
		* @returns {Array} The new array of code points.
		*/
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			while (counter < length) {
				var value = string.charCodeAt(counter++);
				if (value >= 55296 && value <= 56319 && counter < length) {
					var extra = string.charCodeAt(counter++);
					if ((extra & 64512) == 56320) output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
					else {
						output.push(value);
						counter--;
					}
				} else output.push(value);
			}
			return output;
		}
		/**
		* Creates a string based on an array of numeric code points.
		* @see `punycode.ucs2.decode`
		* @memberOf punycode.ucs2
		* @name encode
		* @param {Array} codePoints The array of numeric code points.
		* @returns {String} The new Unicode string (UCS-2).
		*/
		var ucs2encode = function ucs2encode$1(array) {
			return String.fromCodePoint.apply(String, toConsumableArray(array));
		};
		/**
		* Converts a basic code point into a digit/integer.
		* @see `digitToBasic()`
		* @private
		* @param {Number} codePoint The basic numeric code point value.
		* @returns {Number} The numeric value of a basic code point (for use in
		* representing integers) in the range `0` to `base - 1`, or `base` if
		* the code point does not represent a value.
		*/
		var basicToDigit = function basicToDigit$1(codePoint) {
			if (codePoint - 48 < 10) return codePoint - 22;
			if (codePoint - 65 < 26) return codePoint - 65;
			if (codePoint - 97 < 26) return codePoint - 97;
			return base;
		};
		/**
		* Converts a digit/integer into a basic code point.
		* @see `basicToDigit()`
		* @private
		* @param {Number} digit The numeric value of a basic code point.
		* @returns {Number} The basic code point whose value (when used for
		* representing integers) is `digit`, which needs to be in the range
		* `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		* used; else, the lowercase form is used. The behavior is undefined
		* if `flag` is non-zero and `digit` has no uppercase form.
		*/
		var digitToBasic = function digitToBasic$1(digit, flag) {
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		};
		/**
		* Bias adaptation function as per section 3.4 of RFC 3492.
		* https://tools.ietf.org/html/rfc3492#section-3.4
		* @private
		*/
		var adapt = function adapt$1(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (; delta > baseMinusTMin * tMax >> 1; k += base) delta = floor(delta / baseMinusTMin);
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		};
		/**
		* Converts a Punycode string of ASCII-only symbols to a string of Unicode
		* symbols.
		* @memberOf punycode
		* @param {String} input The Punycode string of ASCII-only symbols.
		* @returns {String} The resulting string of Unicode symbols.
		*/
		var decode = function decode$1(input) {
			var output = [];
			var inputLength = input.length;
			var i$3 = 0;
			var n = initialN;
			var bias = initialBias;
			var basic = input.lastIndexOf(delimiter);
			if (basic < 0) basic = 0;
			for (var j = 0; j < basic; ++j) {
				if (input.charCodeAt(j) >= 128) error$1("not-basic");
				output.push(input.charCodeAt(j));
			}
			for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
				var oldi = i$3;
				for (var w = 1, k = base;; k += base) {
					if (index >= inputLength) error$1("invalid-input");
					var digit = basicToDigit(input.charCodeAt(index++));
					if (digit >= base || digit > floor((maxInt - i$3) / w)) error$1("overflow");
					i$3 += digit * w;
					var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
					if (digit < t) break;
					var baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) error$1("overflow");
					w *= baseMinusT;
				}
				var out = output.length + 1;
				bias = adapt(i$3 - oldi, out, oldi == 0);
				if (floor(i$3 / out) > maxInt - n) error$1("overflow");
				n += floor(i$3 / out);
				i$3 %= out;
				output.splice(i$3++, 0, n);
			}
			return String.fromCodePoint.apply(String, output);
		};
		/**
		* Converts a string of Unicode symbols (e.g. a domain name label) to a
		* Punycode string of ASCII-only symbols.
		* @memberOf punycode
		* @param {String} input The string of Unicode symbols.
		* @returns {String} The resulting Punycode string of ASCII-only symbols.
		*/
		var encode = function encode$1(input) {
			var output = [];
			input = ucs2decode(input);
			var inputLength = input.length;
			var n = initialN;
			var delta = 0;
			var bias = initialBias;
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = void 0;
			try {
				for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var _currentValue2 = _step.value;
					if (_currentValue2 < 128) output.push(stringFromCharCode(_currentValue2));
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) _iterator.return();
				} finally {
					if (_didIteratorError) throw _iteratorError;
				}
			}
			var basicLength = output.length;
			var handledCPCount = basicLength;
			if (basicLength) output.push(delimiter);
			while (handledCPCount < inputLength) {
				var m = maxInt;
				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = void 0;
				try {
					for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var currentValue = _step2.value;
						if (currentValue >= n && currentValue < m) m = currentValue;
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) _iterator2.return();
					} finally {
						if (_didIteratorError2) throw _iteratorError2;
					}
				}
				var handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) error$1("overflow");
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = void 0;
				try {
					for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						var _currentValue = _step3.value;
						if (_currentValue < n && ++delta > maxInt) error$1("overflow");
						if (_currentValue == n) {
							var q = delta;
							for (var k = base;; k += base) {
								var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
								if (q < t) break;
								var qMinusT = q - t;
								var baseMinusT = base - t;
								output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
								q = floor(qMinusT / baseMinusT);
							}
							output.push(stringFromCharCode(digitToBasic(q, 0)));
							bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
							delta = 0;
							++handledCPCount;
						}
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) _iterator3.return();
					} finally {
						if (_didIteratorError3) throw _iteratorError3;
					}
				}
				++delta;
				++n;
			}
			return output.join("");
		};
		/**
		* Converts a Punycode string representing a domain name or an email address
		* to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		* it doesn't matter if you call it on a string that has already been
		* converted to Unicode.
		* @memberOf punycode
		* @param {String} input The Punycoded domain name or email address to
		* convert to Unicode.
		* @returns {String} The Unicode representation of the given Punycode
		* string.
		*/
		var toUnicode = function toUnicode$1(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
			});
		};
		/**
		* Converts a Unicode string representing a domain name or an email address to
		* Punycode. Only the non-ASCII parts of the domain name will be converted,
		* i.e. it doesn't matter if you call it with a domain that's already in
		* ASCII.
		* @memberOf punycode
		* @param {String} input The domain name or email address to convert, as a
		* Unicode string.
		* @returns {String} The Punycode representation of the given domain name or
		* email address.
		*/
		var toASCII = function toASCII$1(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
			});
		};
		/** Define the public API */
		var punycode = {
			"version": "2.1.0",
			"ucs2": {
				"decode": ucs2decode,
				"encode": ucs2encode
			},
			"decode": decode,
			"encode": encode,
			"toASCII": toASCII,
			"toUnicode": toUnicode
		};
		/**
		* URI.js
		*
		* @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
		* @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
		* @see http://github.com/garycourt/uri-js
		*/
		/**
		* Copyright 2011 Gary Court. All rights reserved.
		*
		* Redistribution and use in source and binary forms, with or without modification, are
		* permitted provided that the following conditions are met:
		*
		*    1. Redistributions of source code must retain the above copyright notice, this list of
		*       conditions and the following disclaimer.
		*
		*    2. Redistributions in binary form must reproduce the above copyright notice, this list
		*       of conditions and the following disclaimer in the documentation and/or other materials
		*       provided with the distribution.
		*
		* THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
		* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
		* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
		* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
		* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
		* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
		* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
		* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		*
		* The views and conclusions contained in the software and documentation are those of the
		* authors and should not be interpreted as representing official policies, either expressed
		* or implied, of Gary Court.
		*/
		var SCHEMES = {};
		function pctEncChar(chr) {
			var c = chr.charCodeAt(0);
			var e = void 0;
			if (c < 16) e = "%0" + c.toString(16).toUpperCase();
			else if (c < 128) e = "%" + c.toString(16).toUpperCase();
			else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
			else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
			return e;
		}
		function pctDecChars(str) {
			var newStr = "";
			var i$3 = 0;
			var il = str.length;
			while (i$3 < il) {
				var c = parseInt(str.substr(i$3 + 1, 2), 16);
				if (c < 128) {
					newStr += String.fromCharCode(c);
					i$3 += 3;
				} else if (c >= 194 && c < 224) {
					if (il - i$3 >= 6) {
						var c2 = parseInt(str.substr(i$3 + 4, 2), 16);
						newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
					} else newStr += str.substr(i$3, 6);
					i$3 += 6;
				} else if (c >= 224) {
					if (il - i$3 >= 9) {
						var _c = parseInt(str.substr(i$3 + 4, 2), 16);
						var c3 = parseInt(str.substr(i$3 + 7, 2), 16);
						newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
					} else newStr += str.substr(i$3, 9);
					i$3 += 9;
				} else {
					newStr += str.substr(i$3, 3);
					i$3 += 3;
				}
			}
			return newStr;
		}
		function _normalizeComponentEncoding(components, protocol) {
			function decodeUnreserved$1(str) {
				var decStr = pctDecChars(str);
				return !decStr.match(protocol.UNRESERVED) ? str : decStr;
			}
			if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved$1).toLowerCase().replace(protocol.NOT_SCHEME, "");
			if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved$1).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
			if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved$1).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
			if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved$1).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
			if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved$1).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
			if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved$1).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
			return components;
		}
		function _stripLeadingZeros(str) {
			return str.replace(/^0*(.*)/, "$1") || "0";
		}
		function _normalizeIPv4(host, protocol) {
			var matches = host.match(protocol.IPV4ADDRESS) || [];
			var _matches = slicedToArray(matches, 2), address = _matches[1];
			if (address) return address.split(".").map(_stripLeadingZeros).join(".");
			else return host;
		}
		function _normalizeIPv6(host, protocol) {
			var matches = host.match(protocol.IPV6ADDRESS) || [];
			var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
			if (address) {
				var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
				var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
				var lastFields = last.split(":").map(_stripLeadingZeros);
				var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
				var fieldCount = isLastFieldIPv4Address ? 7 : 8;
				var lastFieldsStart = lastFields.length - fieldCount;
				var fields = Array(fieldCount);
				for (var x = 0; x < fieldCount; ++x) fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
				if (isLastFieldIPv4Address) fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
				var longestZeroFields = fields.reduce(function(acc, field, index) {
					if (!field || field === "0") {
						var lastLongest = acc[acc.length - 1];
						if (lastLongest && lastLongest.index + lastLongest.length === index) lastLongest.length++;
						else acc.push({
							index,
							length: 1
						});
					}
					return acc;
				}, []).sort(function(a, b) {
					return b.length - a.length;
				})[0];
				var newHost = void 0;
				if (longestZeroFields && longestZeroFields.length > 1) {
					var newFirst = fields.slice(0, longestZeroFields.index);
					var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
					newHost = newFirst.join(":") + "::" + newLast.join(":");
				} else newHost = fields.join(":");
				if (zone) newHost += "%" + zone;
				return newHost;
			} else return host;
		}
		var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
		var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
		function parse$2(uriString) {
			var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			var components = {};
			var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
			if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
			var matches = uriString.match(URI_PARSE);
			if (matches) {
				if (NO_MATCH_IS_UNDEFINED) {
					components.scheme = matches[1];
					components.userinfo = matches[3];
					components.host = matches[4];
					components.port = parseInt(matches[5], 10);
					components.path = matches[6] || "";
					components.query = matches[7];
					components.fragment = matches[8];
					if (isNaN(components.port)) components.port = matches[5];
				} else {
					components.scheme = matches[1] || void 0;
					components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
					components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
					components.port = parseInt(matches[5], 10);
					components.path = matches[6] || "";
					components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
					components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
					if (isNaN(components.port)) components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
				}
				if (components.host) components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
				if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) components.reference = "same-document";
				else if (components.scheme === void 0) components.reference = "relative";
				else if (components.fragment === void 0) components.reference = "absolute";
				else components.reference = "uri";
				if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) components.error = components.error || "URI is not a " + options.reference + " reference.";
				var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
				if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
					if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) try {
						components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
					} catch (e) {
						components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
					}
					_normalizeComponentEncoding(components, URI_PROTOCOL);
				} else _normalizeComponentEncoding(components, protocol);
				if (schemeHandler && schemeHandler.parse) schemeHandler.parse(components, options);
			} else components.error = components.error || "URI can not be parsed.";
			return components;
		}
		function _recomposeAuthority(components, options) {
			var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
			var uriTokens = [];
			if (components.userinfo !== void 0) {
				uriTokens.push(components.userinfo);
				uriTokens.push("@");
			}
			if (components.host !== void 0) uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
				return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
			}));
			if (typeof components.port === "number" || typeof components.port === "string") {
				uriTokens.push(":");
				uriTokens.push(String(components.port));
			}
			return uriTokens.length ? uriTokens.join("") : void 0;
		}
		var RDS1 = /^\.\.?\//;
		var RDS2 = /^\/\.(\/|$)/;
		var RDS3 = /^\/\.\.(\/|$)/;
		var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
		function removeDotSegments(input) {
			var output = [];
			while (input.length) if (input.match(RDS1)) input = input.replace(RDS1, "");
			else if (input.match(RDS2)) input = input.replace(RDS2, "/");
			else if (input.match(RDS3)) {
				input = input.replace(RDS3, "/");
				output.pop();
			} else if (input === "." || input === "..") input = "";
			else {
				var im = input.match(RDS5);
				if (im) {
					var s = im[0];
					input = input.slice(s.length);
					output.push(s);
				} else throw new Error("Unexpected dot segment condition");
			}
			return output.join("");
		}
		function serialize(components) {
			var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
			var uriTokens = [];
			var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
			if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
			if (components.host) {
				if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) try {
					components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
				} catch (e) {
					components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
				}
			}
			_normalizeComponentEncoding(components, protocol);
			if (options.reference !== "suffix" && components.scheme) {
				uriTokens.push(components.scheme);
				uriTokens.push(":");
			}
			var authority = _recomposeAuthority(components, options);
			if (authority !== void 0) {
				if (options.reference !== "suffix") uriTokens.push("//");
				uriTokens.push(authority);
				if (components.path && components.path.charAt(0) !== "/") uriTokens.push("/");
			}
			if (components.path !== void 0) {
				var s = components.path;
				if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) s = removeDotSegments(s);
				if (authority === void 0) s = s.replace(/^\/\//, "/%2F");
				uriTokens.push(s);
			}
			if (components.query !== void 0) {
				uriTokens.push("?");
				uriTokens.push(components.query);
			}
			if (components.fragment !== void 0) {
				uriTokens.push("#");
				uriTokens.push(components.fragment);
			}
			return uriTokens.join("");
		}
		function resolveComponents(base$1, relative$1) {
			var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
			var skipNormalization = arguments[3];
			var target = {};
			if (!skipNormalization) {
				base$1 = parse$2(serialize(base$1, options), options);
				relative$1 = parse$2(serialize(relative$1, options), options);
			}
			options = options || {};
			if (!options.tolerant && relative$1.scheme) {
				target.scheme = relative$1.scheme;
				target.userinfo = relative$1.userinfo;
				target.host = relative$1.host;
				target.port = relative$1.port;
				target.path = removeDotSegments(relative$1.path || "");
				target.query = relative$1.query;
			} else {
				if (relative$1.userinfo !== void 0 || relative$1.host !== void 0 || relative$1.port !== void 0) {
					target.userinfo = relative$1.userinfo;
					target.host = relative$1.host;
					target.port = relative$1.port;
					target.path = removeDotSegments(relative$1.path || "");
					target.query = relative$1.query;
				} else {
					if (!relative$1.path) {
						target.path = base$1.path;
						if (relative$1.query !== void 0) target.query = relative$1.query;
						else target.query = base$1.query;
					} else {
						if (relative$1.path.charAt(0) === "/") target.path = removeDotSegments(relative$1.path);
						else {
							if ((base$1.userinfo !== void 0 || base$1.host !== void 0 || base$1.port !== void 0) && !base$1.path) target.path = "/" + relative$1.path;
							else if (!base$1.path) target.path = relative$1.path;
							else target.path = base$1.path.slice(0, base$1.path.lastIndexOf("/") + 1) + relative$1.path;
							target.path = removeDotSegments(target.path);
						}
						target.query = relative$1.query;
					}
					target.userinfo = base$1.userinfo;
					target.host = base$1.host;
					target.port = base$1.port;
				}
				target.scheme = base$1.scheme;
			}
			target.fragment = relative$1.fragment;
			return target;
		}
		function resolve$4(baseURI, relativeURI, options) {
			var schemelessOptions = assign({ scheme: "null" }, options);
			return serialize(resolveComponents(parse$2(baseURI, schemelessOptions), parse$2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
		}
		function normalize(uri$1, options) {
			if (typeof uri$1 === "string") uri$1 = serialize(parse$2(uri$1, options), options);
			else if (typeOf(uri$1) === "object") uri$1 = parse$2(serialize(uri$1, options), options);
			return uri$1;
		}
		function equal$2(uriA, uriB, options) {
			if (typeof uriA === "string") uriA = serialize(parse$2(uriA, options), options);
			else if (typeOf(uriA) === "object") uriA = serialize(uriA, options);
			if (typeof uriB === "string") uriB = serialize(parse$2(uriB, options), options);
			else if (typeOf(uriB) === "object") uriB = serialize(uriB, options);
			return uriA === uriB;
		}
		function escapeComponent(str, options) {
			return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
		}
		function unescapeComponent(str, options) {
			return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
		}
		var handler = {
			scheme: "http",
			domainHost: true,
			parse: function parse$3(components, options) {
				if (!components.host) components.error = components.error || "HTTP URIs must have a host.";
				return components;
			},
			serialize: function serialize$1(components, options) {
				var secure = String(components.scheme).toLowerCase() === "https";
				if (components.port === (secure ? 443 : 80) || components.port === "") components.port = void 0;
				if (!components.path) components.path = "/";
				return components;
			}
		};
		var handler$1 = {
			scheme: "https",
			domainHost: handler.domainHost,
			parse: handler.parse,
			serialize: handler.serialize
		};
		function isSecure(wsComponents) {
			return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
		}
		var handler$2 = {
			scheme: "ws",
			domainHost: true,
			parse: function parse$3(components, options) {
				var wsComponents = components;
				wsComponents.secure = isSecure(wsComponents);
				wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
				wsComponents.path = void 0;
				wsComponents.query = void 0;
				return wsComponents;
			},
			serialize: function serialize$1(wsComponents, options) {
				if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") wsComponents.port = void 0;
				if (typeof wsComponents.secure === "boolean") {
					wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
					wsComponents.secure = void 0;
				}
				if (wsComponents.resourceName) {
					var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
					wsComponents.path = path && path !== "/" ? path : void 0;
					wsComponents.query = query;
					wsComponents.resourceName = void 0;
				}
				wsComponents.fragment = void 0;
				return wsComponents;
			}
		};
		var handler$3 = {
			scheme: "wss",
			domainHost: handler$2.domainHost,
			parse: handler$2.parse,
			serialize: handler$2.serialize
		};
		var O = {};
		var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
		var HEXDIG$$ = "[0-9A-Fa-f]";
		var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
		var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
		var VCHAR$$ = merge("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", "[\\\"\\\\]");
		var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
		var UNRESERVED = new RegExp(UNRESERVED$$, "g");
		var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
		var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", "[\\\"]", VCHAR$$), "g");
		var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
		var NOT_HFVALUE = NOT_HFNAME;
		function decodeUnreserved(str) {
			var decStr = pctDecChars(str);
			return !decStr.match(UNRESERVED) ? str : decStr;
		}
		var handler$4 = {
			scheme: "mailto",
			parse: function parse$$1(components, options) {
				var mailtoComponents = components;
				var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
				mailtoComponents.path = void 0;
				if (mailtoComponents.query) {
					var unknownHeaders = false;
					var headers = {};
					var hfields = mailtoComponents.query.split("&");
					for (var x = 0, xl = hfields.length; x < xl; ++x) {
						var hfield = hfields[x].split("=");
						switch (hfield[0]) {
							case "to":
								var toAddrs = hfield[1].split(",");
								for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) to.push(toAddrs[_x]);
								break;
							case "subject":
								mailtoComponents.subject = unescapeComponent(hfield[1], options);
								break;
							case "body":
								mailtoComponents.body = unescapeComponent(hfield[1], options);
								break;
							default:
								unknownHeaders = true;
								headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
								break;
						}
					}
					if (unknownHeaders) mailtoComponents.headers = headers;
				}
				mailtoComponents.query = void 0;
				for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
					var addr = to[_x2].split("@");
					addr[0] = unescapeComponent(addr[0]);
					if (!options.unicodeSupport) try {
						addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
					} catch (e) {
						mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
					}
					else addr[1] = unescapeComponent(addr[1], options).toLowerCase();
					to[_x2] = addr.join("@");
				}
				return mailtoComponents;
			},
			serialize: function serialize$$1(mailtoComponents, options) {
				var components = mailtoComponents;
				var to = toArray(mailtoComponents.to);
				if (to) {
					for (var x = 0, xl = to.length; x < xl; ++x) {
						var toAddr = String(to[x]);
						var atIdx = toAddr.lastIndexOf("@");
						var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
						var domain = toAddr.slice(atIdx + 1);
						try {
							domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
						} catch (e) {
							components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
						}
						to[x] = localPart + "@" + domain;
					}
					components.path = to.join(",");
				}
				var headers = mailtoComponents.headers = mailtoComponents.headers || {};
				if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
				if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
				var fields = [];
				for (var name in headers) if (headers[name] !== O[name]) fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
				if (fields.length) components.query = fields.join("&");
				return components;
			}
		};
		var URN_PARSE = /^([^\:]+)\:(.*)/;
		var handler$5 = {
			scheme: "urn",
			parse: function parse$$1(components, options) {
				var matches = components.path && components.path.match(URN_PARSE);
				var urnComponents = components;
				if (matches) {
					var scheme = options.scheme || urnComponents.scheme || "urn";
					var nid = matches[1].toLowerCase();
					var nss = matches[2];
					var urnScheme = scheme + ":" + (options.nid || nid);
					var schemeHandler = SCHEMES[urnScheme];
					urnComponents.nid = nid;
					urnComponents.nss = nss;
					urnComponents.path = void 0;
					if (schemeHandler) urnComponents = schemeHandler.parse(urnComponents, options);
				} else urnComponents.error = urnComponents.error || "URN can not be parsed.";
				return urnComponents;
			},
			serialize: function serialize$$1(urnComponents, options) {
				var scheme = options.scheme || urnComponents.scheme || "urn";
				var nid = urnComponents.nid;
				var urnScheme = scheme + ":" + (options.nid || nid);
				var schemeHandler = SCHEMES[urnScheme];
				if (schemeHandler) urnComponents = schemeHandler.serialize(urnComponents, options);
				var uriComponents = urnComponents;
				var nss = urnComponents.nss;
				uriComponents.path = (nid || options.nid) + ":" + nss;
				return uriComponents;
			}
		};
		var UUID$1 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
		var handler$6 = {
			scheme: "urn:uuid",
			parse: function parse$3(urnComponents, options) {
				var uuidComponents = urnComponents;
				uuidComponents.uuid = uuidComponents.nss;
				uuidComponents.nss = void 0;
				if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID$1))) uuidComponents.error = uuidComponents.error || "UUID is not valid.";
				return uuidComponents;
			},
			serialize: function serialize$1(uuidComponents, options) {
				var urnComponents = uuidComponents;
				urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
				return urnComponents;
			}
		};
		SCHEMES[handler.scheme] = handler;
		SCHEMES[handler$1.scheme] = handler$1;
		SCHEMES[handler$2.scheme] = handler$2;
		SCHEMES[handler$3.scheme] = handler$3;
		SCHEMES[handler$4.scheme] = handler$4;
		SCHEMES[handler$5.scheme] = handler$5;
		SCHEMES[handler$6.scheme] = handler$6;
		exports$1.SCHEMES = SCHEMES;
		exports$1.pctEncChar = pctEncChar;
		exports$1.pctDecChars = pctDecChars;
		exports$1.parse = parse$2;
		exports$1.removeDotSegments = removeDotSegments;
		exports$1.serialize = serialize;
		exports$1.resolveComponents = resolveComponents;
		exports$1.resolve = resolve$4;
		exports$1.normalize = normalize;
		exports$1.equal = equal$2;
		exports$1.escapeComponent = escapeComponent;
		exports$1.unescapeComponent = unescapeComponent;
		Object.defineProperty(exports$1, "__esModule", { value: true });
	}));
}) });

//#endregion
//#region node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js": ((exports, module) => {
	module.exports = function equal$2(a, b) {
		if (a === b) return true;
		if (a && b && typeof a == "object" && typeof b == "object") {
			if (a.constructor !== b.constructor) return false;
			var length, i$3, keys;
			if (Array.isArray(a)) {
				length = a.length;
				if (length != b.length) return false;
				for (i$3 = length; i$3-- !== 0;) if (!equal$2(a[i$3], b[i$3])) return false;
				return true;
			}
			if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
			if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
			if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
			keys = Object.keys(a);
			length = keys.length;
			if (length !== Object.keys(b).length) return false;
			for (i$3 = length; i$3-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i$3])) return false;
			for (i$3 = length; i$3-- !== 0;) {
				var key$1 = keys[i$3];
				if (!equal$2(a[key$1], b[key$1])) return false;
			}
			return true;
		}
		return a !== a && b !== b;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/ucs2length.js": ((exports, module) => {
	module.exports = function ucs2length$1(str) {
		var length = 0, len = str.length, pos = 0, value;
		while (pos < len) {
			length++;
			value = str.charCodeAt(pos++);
			if (value >= 55296 && value <= 56319 && pos < len) {
				value = str.charCodeAt(pos);
				if ((value & 64512) == 56320) pos++;
			}
		}
		return length;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/util.js
var require_util = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/util.js": ((exports, module) => {
	module.exports = {
		copy,
		checkDataType,
		checkDataTypes,
		coerceToTypes,
		toHash: toHash$1,
		getProperty,
		escapeQuotes,
		equal: require_fast_deep_equal(),
		ucs2length: require_ucs2length(),
		varOccurences,
		varReplace,
		schemaHasRules,
		schemaHasRulesExcept,
		schemaUnknownRules,
		toQuotedString,
		getPathExpr,
		getPath,
		getData,
		unescapeFragment,
		unescapeJsonPointer,
		escapeFragment,
		escapeJsonPointer
	};
	function copy(o, to) {
		to = to || {};
		for (var key$1 in o) to[key$1] = o[key$1];
		return to;
	}
	function checkDataType(dataType, data, strictNumbers, negate) {
		var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK$1 = negate ? "!" : "", NOT = negate ? "" : "!";
		switch (dataType) {
			case "null": return data + EQUAL + "null";
			case "array": return OK$1 + "Array.isArray(" + data + ")";
			case "object": return "(" + OK$1 + data + AND + "typeof " + data + EQUAL + "\"object\"" + AND + NOT + "Array.isArray(" + data + "))";
			case "integer": return "(typeof " + data + EQUAL + "\"number\"" + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK$1 + "isFinite(" + data + ")" : "") + ")";
			case "number": return "(typeof " + data + EQUAL + "\"" + dataType + "\"" + (strictNumbers ? AND + OK$1 + "isFinite(" + data + ")" : "") + ")";
			default: return "typeof " + data + EQUAL + "\"" + dataType + "\"";
		}
	}
	function checkDataTypes(dataTypes, data, strictNumbers) {
		switch (dataTypes.length) {
			case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
			default:
				var code = "";
				var types = toHash$1(dataTypes);
				if (types.array && types.object) {
					code = types.null ? "(" : "(!" + data + " || ";
					code += "typeof " + data + " !== \"object\")";
					delete types.null;
					delete types.array;
					delete types.object;
				}
				if (types.number) delete types.integer;
				for (var t in types) code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
				return code;
		}
	}
	var COERCE_TO_TYPES = toHash$1([
		"string",
		"number",
		"integer",
		"boolean",
		"null"
	]);
	function coerceToTypes(optionCoerceTypes, dataTypes) {
		if (Array.isArray(dataTypes)) {
			var types = [];
			for (var i$3 = 0; i$3 < dataTypes.length; i$3++) {
				var t = dataTypes[i$3];
				if (COERCE_TO_TYPES[t]) types[types.length] = t;
				else if (optionCoerceTypes === "array" && t === "array") types[types.length] = t;
			}
			if (types.length) return types;
		} else if (COERCE_TO_TYPES[dataTypes]) return [dataTypes];
		else if (optionCoerceTypes === "array" && dataTypes === "array") return ["array"];
	}
	function toHash$1(arr) {
		var hash = {};
		for (var i$3 = 0; i$3 < arr.length; i$3++) hash[arr[i$3]] = true;
		return hash;
	}
	var IDENTIFIER$1 = /^[a-z$_][a-z$_0-9]*$/i;
	var SINGLE_QUOTE = /'|\\/g;
	function getProperty(key$1) {
		return typeof key$1 == "number" ? "[" + key$1 + "]" : IDENTIFIER$1.test(key$1) ? "." + key$1 : "['" + escapeQuotes(key$1) + "']";
	}
	function escapeQuotes(str) {
		return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
	}
	function varOccurences(str, dataVar) {
		dataVar += "[^0-9]";
		var matches = str.match(new RegExp(dataVar, "g"));
		return matches ? matches.length : 0;
	}
	function varReplace(str, dataVar, expr) {
		dataVar += "([^0-9])";
		expr = expr.replace(/\$/g, "$$$$");
		return str.replace(new RegExp(dataVar, "g"), expr + "$1");
	}
	function schemaHasRules(schema, rules$1) {
		if (typeof schema == "boolean") return !schema;
		for (var key$1 in schema) if (rules$1[key$1]) return true;
	}
	function schemaHasRulesExcept(schema, rules$1, exceptKeyword) {
		if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
		for (var key$1 in schema) if (key$1 != exceptKeyword && rules$1[key$1]) return true;
	}
	function schemaUnknownRules(schema, rules$1) {
		if (typeof schema == "boolean") return;
		for (var key$1 in schema) if (!rules$1[key$1]) return key$1;
	}
	function toQuotedString(str) {
		return "'" + escapeQuotes(str) + "'";
	}
	function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
		var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
		return joinPaths(currentPath, path);
	}
	function getPath(currentPath, prop, jsonPointers) {
		var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
		return joinPaths(currentPath, path);
	}
	var JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
	var RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, lvl, paths) {
		var up, jsonPointer, data, matches;
		if ($data === "") return "rootData";
		if ($data[0] == "/") {
			if (!JSON_POINTER$1.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
			jsonPointer = $data;
			data = "rootData";
		} else {
			matches = $data.match(RELATIVE_JSON_POINTER$1);
			if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
			up = +matches[1];
			jsonPointer = matches[2];
			if (jsonPointer == "#") {
				if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
				return paths[lvl - up];
			}
			if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
			data = "data" + (lvl - up || "");
			if (!jsonPointer) return data;
		}
		var expr = data;
		var segments = jsonPointer.split("/");
		for (var i$3 = 0; i$3 < segments.length; i$3++) {
			var segment = segments[i$3];
			if (segment) {
				data += getProperty(unescapeJsonPointer(segment));
				expr += " && " + data;
			}
		}
		return expr;
	}
	function joinPaths(a, b) {
		if (a == "\"\"") return b;
		return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
	}
	function unescapeFragment(str) {
		return unescapeJsonPointer(decodeURIComponent(str));
	}
	function escapeFragment(str) {
		return encodeURIComponent(escapeJsonPointer(str));
	}
	function escapeJsonPointer(str) {
		return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	function unescapeJsonPointer(str) {
		return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/schema_obj.js": ((exports, module) => {
	var util$4 = require_util();
	module.exports = SchemaObject$2;
	function SchemaObject$2(obj) {
		util$4.copy(obj, this);
	}
}) });

//#endregion
//#region node_modules/.pnpm/json-schema-traverse@0.4.1/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/json-schema-traverse@0.4.1/node_modules/json-schema-traverse/index.js": ((exports, module) => {
	var traverse$1 = module.exports = function(schema, opts, cb) {
		if (typeof opts == "function") {
			cb = opts;
			opts = {};
		}
		cb = opts.cb || cb;
		var pre = typeof cb == "function" ? cb : cb.pre || function() {};
		var post = cb.post || function() {};
		_traverse(opts, pre, post, schema, "", schema);
	};
	traverse$1.keywords = {
		additionalItems: true,
		items: true,
		contains: true,
		additionalProperties: true,
		propertyNames: true,
		not: true
	};
	traverse$1.arrayKeywords = {
		items: true,
		allOf: true,
		anyOf: true,
		oneOf: true
	};
	traverse$1.propsKeywords = {
		definitions: true,
		properties: true,
		patternProperties: true,
		dependencies: true
	};
	traverse$1.skipKeywords = {
		default: true,
		enum: true,
		const: true,
		required: true,
		maximum: true,
		minimum: true,
		exclusiveMaximum: true,
		exclusiveMinimum: true,
		multipleOf: true,
		maxLength: true,
		minLength: true,
		pattern: true,
		format: true,
		maxItems: true,
		minItems: true,
		uniqueItems: true,
		maxProperties: true,
		minProperties: true
	};
	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
		if (schema && typeof schema == "object" && !Array.isArray(schema)) {
			pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
			for (var key$1 in schema) {
				var sch = schema[key$1];
				if (Array.isArray(sch)) {
					if (key$1 in traverse$1.arrayKeywords) for (var i$3 = 0; i$3 < sch.length; i$3++) _traverse(opts, pre, post, sch[i$3], jsonPtr + "/" + key$1 + "/" + i$3, rootSchema, jsonPtr, key$1, schema, i$3);
				} else if (key$1 in traverse$1.propsKeywords) {
					if (sch && typeof sch == "object") for (var prop in sch) _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key$1 + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key$1, schema, prop);
				} else if (key$1 in traverse$1.keywords || opts.allKeys && !(key$1 in traverse$1.skipKeywords)) _traverse(opts, pre, post, sch, jsonPtr + "/" + key$1, rootSchema, jsonPtr, key$1, schema);
			}
			post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
		}
	}
	function escapeJsonPtr(str) {
		return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/resolve.js
var require_resolve = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/resolve.js": ((exports, module) => {
	var URI$1 = require_uri_all(), equal$1 = require_fast_deep_equal(), util$3 = require_util(), SchemaObject$1 = require_schema_obj(), traverse = require_json_schema_traverse();
	module.exports = resolve$3;
	resolve$3.normalizeId = normalizeId;
	resolve$3.fullPath = getFullPath;
	resolve$3.url = resolveUrl;
	resolve$3.ids = resolveIds;
	resolve$3.inlineRef = inlineRef;
	resolve$3.schema = resolveSchema;
	/**
	* [resolve and compile the references ($ref)]
	* @this   Ajv
	* @param  {Function} compile reference to schema compilation funciton (localCompile)
	* @param  {Object} root object with information about the root schema for the current schema
	* @param  {String} ref reference to resolve
	* @return {Object|Function} schema object (if the schema can be inlined) or validation function
	*/
	function resolve$3(compile$2, root, ref) {
		var refVal = this._refs[ref];
		if (typeof refVal == "string") if (this._refs[refVal]) refVal = this._refs[refVal];
		else return resolve$3.call(this, compile$2, root, refVal);
		refVal = refVal || this._schemas[ref];
		if (refVal instanceof SchemaObject$1) return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
		var res = resolveSchema.call(this, root, ref);
		var schema, v, baseId;
		if (res) {
			schema = res.schema;
			root = res.root;
			baseId = res.baseId;
		}
		if (schema instanceof SchemaObject$1) v = schema.validate || compile$2.call(this, schema.schema, root, void 0, baseId);
		else if (schema !== void 0) v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile$2.call(this, schema, root, void 0, baseId);
		return v;
	}
	/**
	* Resolve schema, its root and baseId
	* @this Ajv
	* @param  {Object} root root object with properties schema, refVal, refs
	* @param  {String} ref  reference to resolve
	* @return {Object} object with properties schema, root, baseId
	*/
	function resolveSchema(root, ref) {
		var p = URI$1.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
		if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
			var id = normalizeId(refPath);
			var refVal = this._refs[id];
			if (typeof refVal == "string") return resolveRecursive.call(this, root, refVal, p);
			else if (refVal instanceof SchemaObject$1) {
				if (!refVal.validate) this._compile(refVal);
				root = refVal;
			} else {
				refVal = this._schemas[id];
				if (refVal instanceof SchemaObject$1) {
					if (!refVal.validate) this._compile(refVal);
					if (id == normalizeId(ref)) return {
						schema: refVal,
						root,
						baseId
					};
					root = refVal;
				} else return;
			}
			if (!root.schema) return;
			baseId = getFullPath(this._getId(root.schema));
		}
		return getJsonPointer.call(this, p, baseId, root.schema, root);
	}
	function resolveRecursive(root, ref, parsedRef) {
		var res = resolveSchema.call(this, root, ref);
		if (res) {
			var schema = res.schema;
			var baseId = res.baseId;
			root = res.root;
			var id = this._getId(schema);
			if (id) baseId = resolveUrl(baseId, id);
			return getJsonPointer.call(this, parsedRef, baseId, schema, root);
		}
	}
	var PREVENT_SCOPE_CHANGE = util$3.toHash([
		"properties",
		"patternProperties",
		"enum",
		"dependencies",
		"definitions"
	]);
	function getJsonPointer(parsedRef, baseId, schema, root) {
		parsedRef.fragment = parsedRef.fragment || "";
		if (parsedRef.fragment.slice(0, 1) != "/") return;
		var parts = parsedRef.fragment.split("/");
		for (var i$3 = 1; i$3 < parts.length; i$3++) {
			var part = parts[i$3];
			if (part) {
				part = util$3.unescapeFragment(part);
				schema = schema[part];
				if (schema === void 0) break;
				var id;
				if (!PREVENT_SCOPE_CHANGE[part]) {
					id = this._getId(schema);
					if (id) baseId = resolveUrl(baseId, id);
					if (schema.$ref) {
						var $ref = resolveUrl(baseId, schema.$ref);
						var res = resolveSchema.call(this, root, $ref);
						if (res) {
							schema = res.schema;
							root = res.root;
							baseId = res.baseId;
						}
					}
				}
			}
		}
		if (schema !== void 0 && schema !== root.schema) return {
			schema,
			root,
			baseId
		};
	}
	var SIMPLE_INLINED = util$3.toHash([
		"type",
		"format",
		"pattern",
		"maxLength",
		"minLength",
		"maxProperties",
		"minProperties",
		"maxItems",
		"minItems",
		"maximum",
		"minimum",
		"uniqueItems",
		"multipleOf",
		"required",
		"enum"
	]);
	function inlineRef(schema, limit) {
		if (limit === false) return false;
		if (limit === void 0 || limit === true) return checkNoRef(schema);
		else if (limit) return countKeys(schema) <= limit;
	}
	function checkNoRef(schema) {
		var item;
		if (Array.isArray(schema)) for (var i$3 = 0; i$3 < schema.length; i$3++) {
			item = schema[i$3];
			if (typeof item == "object" && !checkNoRef(item)) return false;
		}
		else for (var key$1 in schema) {
			if (key$1 == "$ref") return false;
			item = schema[key$1];
			if (typeof item == "object" && !checkNoRef(item)) return false;
		}
		return true;
	}
	function countKeys(schema) {
		var count = 0, item;
		if (Array.isArray(schema)) for (var i$3 = 0; i$3 < schema.length; i$3++) {
			item = schema[i$3];
			if (typeof item == "object") count += countKeys(item);
			if (count == Infinity) return Infinity;
		}
		else for (var key$1 in schema) {
			if (key$1 == "$ref") return Infinity;
			if (SIMPLE_INLINED[key$1]) count++;
			else {
				item = schema[key$1];
				if (typeof item == "object") count += countKeys(item) + 1;
				if (count == Infinity) return Infinity;
			}
		}
		return count;
	}
	function getFullPath(id, normalize) {
		if (normalize !== false) id = normalizeId(id);
		var p = URI$1.parse(id);
		return _getFullPath(p);
	}
	function _getFullPath(p) {
		return URI$1.serialize(p).split("#")[0] + "#";
	}
	var TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
		return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	function resolveUrl(baseId, id) {
		id = normalizeId(id);
		return URI$1.resolve(baseId, id);
	}
	function resolveIds(schema) {
		var schemaId = normalizeId(this._getId(schema));
		var baseIds = { "": schemaId };
		var fullPaths = { "": getFullPath(schemaId, false) };
		var localRefs = {};
		var self = this;
		traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
			if (jsonPtr === "") return;
			var id = self._getId(sch);
			var baseId = baseIds[parentJsonPtr];
			var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
			if (keyIndex !== void 0) fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util$3.escapeFragment(keyIndex));
			if (typeof id == "string") {
				id = baseId = normalizeId(baseId ? URI$1.resolve(baseId, id) : id);
				var refVal = self._refs[id];
				if (typeof refVal == "string") refVal = self._refs[refVal];
				if (refVal && refVal.schema) {
					if (!equal$1(sch, refVal.schema)) throw new Error("id \"" + id + "\" resolves to more than one schema");
				} else if (id != normalizeId(fullPath)) if (id[0] == "#") {
					if (localRefs[id] && !equal$1(sch, localRefs[id])) throw new Error("id \"" + id + "\" resolves to more than one schema");
					localRefs[id] = sch;
				} else self._refs[id] = fullPath;
			}
			baseIds[jsonPtr] = baseId;
			fullPaths[jsonPtr] = fullPath;
		});
		return localRefs;
	}
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/error_classes.js": ((exports, module) => {
	var resolve$2 = require_resolve();
	module.exports = {
		Validation: errorSubclass(ValidationError$1),
		MissingRef: errorSubclass(MissingRefError$1)
	};
	function ValidationError$1(errors) {
		this.message = "validation failed";
		this.errors = errors;
		this.ajv = this.validation = true;
	}
	MissingRefError$1.message = function(baseId, ref) {
		return "can't resolve reference " + ref + " from id " + baseId;
	};
	function MissingRefError$1(baseId, ref, message) {
		this.message = message || MissingRefError$1.message(baseId, ref);
		this.missingRef = resolve$2.url(baseId, ref);
		this.missingSchema = resolve$2.normalizeId(resolve$2.fullPath(this.missingRef));
	}
	function errorSubclass(Subclass) {
		Subclass.prototype = Object.create(Error.prototype);
		Subclass.prototype.constructor = Subclass;
		return Subclass;
	}
}) });

//#endregion
//#region node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/fast-json-stable-stringify@2.1.0/node_modules/fast-json-stable-stringify/index.js": ((exports, module) => {
	module.exports = function(data, opts) {
		if (!opts) opts = {};
		if (typeof opts === "function") opts = { cmp: opts };
		var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
		var cmp = opts.cmp && (function(f) {
			return function(node) {
				return function(a, b) {
					var aobj = {
						key: a,
						value: node[a]
					};
					var bobj = {
						key: b,
						value: node[b]
					};
					return f(aobj, bobj);
				};
			};
		})(opts.cmp);
		var seen = [];
		return (function stringify(node) {
			if (node && node.toJSON && typeof node.toJSON === "function") node = node.toJSON();
			if (node === void 0) return;
			if (typeof node == "number") return isFinite(node) ? "" + node : "null";
			if (typeof node !== "object") return JSON.stringify(node);
			var i$3, out;
			if (Array.isArray(node)) {
				out = "[";
				for (i$3 = 0; i$3 < node.length; i$3++) {
					if (i$3) out += ",";
					out += stringify(node[i$3]) || "null";
				}
				return out + "]";
			}
			if (node === null) return "null";
			if (seen.indexOf(node) !== -1) {
				if (cycles) return JSON.stringify("__cycle__");
				throw new TypeError("Converting circular structure to JSON");
			}
			var seenIndex = seen.push(node) - 1;
			var keys = Object.keys(node).sort(cmp && cmp(node));
			out = "";
			for (i$3 = 0; i$3 < keys.length; i$3++) {
				var key$1 = keys[i$3];
				var value = stringify(node[key$1]);
				if (!value) continue;
				if (out) out += ",";
				out += JSON.stringify(key$1) + ":" + value;
			}
			seen.splice(seenIndex, 1);
			return "{" + out + "}";
		})(data);
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/validate.js
var require_validate = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/validate.js": ((exports, module) => {
	module.exports = function generate_validate(it, $keyword, $ruleType) {
		var out = "";
		var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
		if (it.opts.strictKeywords) {
			var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
			if ($unknownKwd) {
				var $keywordsMsg = "unknown keyword: " + $unknownKwd;
				if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
				else throw new Error($keywordsMsg);
			}
		}
		if (it.isTop) {
			out += " var validate = ";
			if ($async) {
				it.async = true;
				out += "async ";
			}
			out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
			if ($id && (it.opts.sourceCode || it.opts.processCode)) out += " " + ("/*# sourceURL=" + $id + " */") + " ";
		}
		if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
			var $keyword = "false schema";
			var $lvl = it.level;
			var $dataLvl = it.dataLevel;
			var $schema = it.schema[$keyword];
			var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
			var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
			var $breakOnError = !it.opts.allErrors;
			var $errorKeyword;
			var $data = "data" + ($dataLvl || "");
			var $valid = "valid" + $lvl;
			if (it.schema === false) {
				if (it.isTop) $breakOnError = true;
				else out += " var " + $valid + " = false; ";
				var $$outStack = $$outStack || [];
				$$outStack.push(out);
				out = "";
				if (it.createErrors !== false) {
					out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
					if (it.opts.messages !== false) out += " , message: 'boolean schema is false' ";
					if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
					out += " } ";
				} else out += " {} ";
				var __err = out;
				out = $$outStack.pop();
				if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
				if (it.async) out += " throw new ValidationError([" + __err + "]); ";
				else out += " validate.errors = [" + __err + "]; return false; ";
				else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			} else if (it.isTop) if ($async) out += " return data; ";
			else out += " validate.errors = null; return true; ";
			else out += " var " + $valid + " = true; ";
			if (it.isTop) out += " }; return validate; ";
			return out;
		}
		if (it.isTop) {
			var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
			it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
			it.baseId = it.baseId || it.rootId;
			delete it.isTop;
			it.dataPathArr = [""];
			if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
				var $defaultMsg = "default is ignored in the schema root";
				if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
				else throw new Error($defaultMsg);
			}
			out += " var vErrors = null; ";
			out += " var errors = 0;     ";
			out += " if (rootData === undefined) rootData = data; ";
		} else {
			var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
			if ($id) it.baseId = it.resolve.url(it.baseId, $id);
			if ($async && !it.async) throw new Error("async schema in sync schema");
			out += " var errs_" + $lvl + " = errors;";
		}
		var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
		var $errorKeyword;
		var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
		if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
			if ($typeIsArray) {
				if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
			} else if ($typeSchema != "null") {
				$typeSchema = [$typeSchema, "null"];
				$typeIsArray = true;
			}
		}
		if ($typeIsArray && $typeSchema.length == 1) {
			$typeSchema = $typeSchema[0];
			$typeIsArray = false;
		}
		if (it.schema.$ref && $refKeywords) {
			if (it.opts.extendRefs == "fail") throw new Error("$ref: validation keywords used in schema at path \"" + it.errSchemaPath + "\" (see option extendRefs)");
			else if (it.opts.extendRefs !== true) {
				$refKeywords = false;
				it.logger.warn("$ref: keywords ignored in schema at path \"" + it.errSchemaPath + "\"");
			}
		}
		if (it.schema.$comment && it.opts.$comment) out += " " + it.RULES.all.$comment.code(it, "$comment");
		if ($typeSchema) {
			if (it.opts.coerceTypes) var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
			var $rulesGroup = it.RULES.types[$typeSchema];
			if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
				var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
				var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
				out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
				if ($coerceToTypes) {
					var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
					out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
					if (it.opts.coerceTypes == "array") out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
					out += " if (" + $coerced + " !== undefined) ; ";
					var arr1 = $coerceToTypes;
					if (arr1) {
						var $type, $i = -1, l1 = arr1.length - 1;
						while ($i < l1) {
							$type = arr1[$i += 1];
							if ($type == "string") out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
							else if ($type == "number" || $type == "integer") {
								out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
								if ($type == "integer") out += " && !(" + $data + " % 1)";
								out += ")) " + $coerced + " = +" + $data + "; ";
							} else if ($type == "boolean") out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
							else if ($type == "null") out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
							else if (it.opts.coerceTypes == "array" && $type == "array") out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
						}
					}
					out += " else {   ";
					var $$outStack = $$outStack || [];
					$$outStack.push(out);
					out = "";
					if (it.createErrors !== false) {
						out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
						if ($typeIsArray) out += "" + $typeSchema.join(",");
						else out += "" + $typeSchema;
						out += "' } ";
						if (it.opts.messages !== false) {
							out += " , message: 'should be ";
							if ($typeIsArray) out += "" + $typeSchema.join(",");
							else out += "" + $typeSchema;
							out += "' ";
						}
						if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					var __err = out;
					out = $$outStack.pop();
					if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
					if (it.async) out += " throw new ValidationError([" + __err + "]); ";
					else out += " validate.errors = [" + __err + "]; return false; ";
					else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
					out += " } if (" + $coerced + " !== undefined) {  ";
					var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
					out += " " + $data + " = " + $coerced + "; ";
					if (!$dataLvl) out += "if (" + $parentData + " !== undefined)";
					out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
				} else {
					var $$outStack = $$outStack || [];
					$$outStack.push(out);
					out = "";
					if (it.createErrors !== false) {
						out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
						if ($typeIsArray) out += "" + $typeSchema.join(",");
						else out += "" + $typeSchema;
						out += "' } ";
						if (it.opts.messages !== false) {
							out += " , message: 'should be ";
							if ($typeIsArray) out += "" + $typeSchema.join(",");
							else out += "" + $typeSchema;
							out += "' ";
						}
						if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					var __err = out;
					out = $$outStack.pop();
					if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
					if (it.async) out += " throw new ValidationError([" + __err + "]); ";
					else out += " validate.errors = [" + __err + "]; return false; ";
					else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
				}
				out += " } ";
			}
		}
		if (it.schema.$ref && !$refKeywords) {
			out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
			if ($breakOnError) {
				out += " } if (errors === ";
				if ($top) out += "0";
				else out += "errs_" + $lvl;
				out += ") { ";
				$closingBraces2 += "}";
			}
		} else {
			var arr2 = it.RULES;
			if (arr2) {
				var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
				while (i2 < l2) {
					$rulesGroup = arr2[i2 += 1];
					if ($shouldUseGroup($rulesGroup)) {
						if ($rulesGroup.type) out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
						if (it.opts.useDefaults) {
							if ($rulesGroup.type == "object" && it.schema.properties) {
								var $schema = it.schema.properties;
								var arr3 = Object.keys($schema);
								if (arr3) {
									var $propertyKey, i3 = -1, l3 = arr3.length - 1;
									while (i3 < l3) {
										$propertyKey = arr3[i3 += 1];
										var $sch = $schema[$propertyKey];
										if ($sch.default !== void 0) {
											var $passData = $data + it.util.getProperty($propertyKey);
											if (it.compositeRule) {
												if (it.opts.strictDefaults) {
													var $defaultMsg = "default is ignored for: " + $passData;
													if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
													else throw new Error($defaultMsg);
												}
											} else {
												out += " if (" + $passData + " === undefined ";
												if (it.opts.useDefaults == "empty") out += " || " + $passData + " === null || " + $passData + " === '' ";
												out += " ) " + $passData + " = ";
												if (it.opts.useDefaults == "shared") out += " " + it.useDefault($sch.default) + " ";
												else out += " " + JSON.stringify($sch.default) + " ";
												out += "; ";
											}
										}
									}
								}
							} else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
								var arr4 = it.schema.items;
								if (arr4) {
									var $sch, $i = -1, l4 = arr4.length - 1;
									while ($i < l4) {
										$sch = arr4[$i += 1];
										if ($sch.default !== void 0) {
											var $passData = $data + "[" + $i + "]";
											if (it.compositeRule) {
												if (it.opts.strictDefaults) {
													var $defaultMsg = "default is ignored for: " + $passData;
													if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
													else throw new Error($defaultMsg);
												}
											} else {
												out += " if (" + $passData + " === undefined ";
												if (it.opts.useDefaults == "empty") out += " || " + $passData + " === null || " + $passData + " === '' ";
												out += " ) " + $passData + " = ";
												if (it.opts.useDefaults == "shared") out += " " + it.useDefault($sch.default) + " ";
												else out += " " + JSON.stringify($sch.default) + " ";
												out += "; ";
											}
										}
									}
								}
							}
						}
						var arr5 = $rulesGroup.rules;
						if (arr5) {
							var $rule, i5 = -1, l5 = arr5.length - 1;
							while (i5 < l5) {
								$rule = arr5[i5 += 1];
								if ($shouldUseRule($rule)) {
									var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
									if ($code) {
										out += " " + $code + " ";
										if ($breakOnError) $closingBraces1 += "}";
									}
								}
							}
						}
						if ($breakOnError) {
							out += " " + $closingBraces1 + " ";
							$closingBraces1 = "";
						}
						if ($rulesGroup.type) {
							out += " } ";
							if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
								out += " else { ";
								var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
								var $$outStack = $$outStack || [];
								$$outStack.push(out);
								out = "";
								if (it.createErrors !== false) {
									out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
									if ($typeIsArray) out += "" + $typeSchema.join(",");
									else out += "" + $typeSchema;
									out += "' } ";
									if (it.opts.messages !== false) {
										out += " , message: 'should be ";
										if ($typeIsArray) out += "" + $typeSchema.join(",");
										else out += "" + $typeSchema;
										out += "' ";
									}
									if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
									out += " } ";
								} else out += " {} ";
								var __err = out;
								out = $$outStack.pop();
								if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
								if (it.async) out += " throw new ValidationError([" + __err + "]); ";
								else out += " validate.errors = [" + __err + "]; return false; ";
								else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
								out += " } ";
							}
						}
						if ($breakOnError) {
							out += " if (errors === ";
							if ($top) out += "0";
							else out += "errs_" + $lvl;
							out += ") { ";
							$closingBraces2 += "}";
						}
					}
				}
			}
		}
		if ($breakOnError) out += " " + $closingBraces2 + " ";
		if ($top) {
			if ($async) {
				out += " if (errors === 0) return data;           ";
				out += " else throw new ValidationError(vErrors); ";
			} else {
				out += " validate.errors = vErrors; ";
				out += " return errors === 0;       ";
			}
			out += " }; return validate;";
		} else out += " var " + $valid + " = errors === errs_" + $lvl + ";";
		function $shouldUseGroup($rulesGroup$1) {
			var rules$1 = $rulesGroup$1.rules;
			for (var i$3 = 0; i$3 < rules$1.length; i$3++) if ($shouldUseRule(rules$1[i$3])) return true;
		}
		function $shouldUseRule($rule$1) {
			return it.schema[$rule$1.keyword] !== void 0 || $rule$1.implements && $ruleImplementsSomeKeyword($rule$1);
		}
		function $ruleImplementsSomeKeyword($rule$1) {
			var impl = $rule$1.implements;
			for (var i$3 = 0; i$3 < impl.length; i$3++) if (it.schema[impl[i$3]] !== void 0) return true;
		}
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/index.js
var require_compile = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/index.js": ((exports, module) => {
	var resolve$1 = require_resolve(), util$2 = require_util(), errorClasses$1 = require_error_classes(), stableStringify$1 = require_fast_json_stable_stringify();
	var validateGenerator = require_validate();
	/**
	* Functions below are used inside compiled validations function
	*/
	var ucs2length = util$2.ucs2length;
	var equal = require_fast_deep_equal();
	var ValidationError = errorClasses$1.Validation;
	module.exports = compile$1;
	/**
	* Compiles schema to validation function
	* @this   Ajv
	* @param  {Object} schema schema object
	* @param  {Object} root object with information about the root schema for this schema
	* @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
	* @param  {String} baseId base ID for IDs in the schema
	* @return {Function} validation function
	*/
	function compile$1(schema, root, localRefs, baseId) {
		var self = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
		root = root || {
			schema,
			refVal,
			refs
		};
		var c = checkCompiling.call(this, schema, root, baseId);
		var compilation = this._compilations[c.index];
		if (c.compiling) return compilation.callValidate = callValidate;
		var formats$2 = this._formats;
		var RULES = this.RULES;
		try {
			var v = localCompile(schema, root, localRefs, baseId);
			compilation.validate = v;
			var cv = compilation.callValidate;
			if (cv) {
				cv.schema = v.schema;
				cv.errors = null;
				cv.refs = v.refs;
				cv.refVal = v.refVal;
				cv.root = v.root;
				cv.$async = v.$async;
				if (opts.sourceCode) cv.source = v.source;
			}
			return v;
		} finally {
			endCompiling.call(this, schema, root, baseId);
		}
		function callValidate() {
			var validate$1 = compilation.validate;
			var result = validate$1.apply(this, arguments);
			callValidate.errors = validate$1.errors;
			return result;
		}
		function localCompile(_schema, _root, localRefs$1, baseId$1) {
			var isRoot = !_root || _root && _root.schema == _schema;
			if (_root.schema != root.schema) return compile$1.call(self, _schema, _root, localRefs$1, baseId$1);
			var $async = _schema.$async === true;
			var sourceCode = validateGenerator({
				isTop: true,
				schema: _schema,
				isRoot,
				baseId: baseId$1,
				root: _root,
				schemaPath: "",
				errSchemaPath: "#",
				errorPath: "\"\"",
				MissingRefError: errorClasses$1.MissingRef,
				RULES,
				validate: validateGenerator,
				util: util$2,
				resolve: resolve$1,
				resolveRef,
				usePattern,
				useDefault,
				useCustomRule,
				opts,
				formats: formats$2,
				logger: self.logger,
				self
			});
			sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode$1) + sourceCode;
			if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
			var validate$1;
			try {
				validate$1 = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode)(self, RULES, formats$2, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
				refVal[0] = validate$1;
			} catch (e) {
				self.logger.error("Error compiling schema, function code:", sourceCode);
				throw e;
			}
			validate$1.schema = _schema;
			validate$1.errors = null;
			validate$1.refs = refs;
			validate$1.refVal = refVal;
			validate$1.root = isRoot ? validate$1 : _root;
			if ($async) validate$1.$async = true;
			if (opts.sourceCode === true) validate$1.source = {
				code: sourceCode,
				patterns,
				defaults
			};
			return validate$1;
		}
		function resolveRef(baseId$1, ref, isRoot) {
			ref = resolve$1.url(baseId$1, ref);
			var refIndex = refs[ref];
			var _refVal, refCode;
			if (refIndex !== void 0) {
				_refVal = refVal[refIndex];
				refCode = "refVal[" + refIndex + "]";
				return resolvedRef(_refVal, refCode);
			}
			if (!isRoot && root.refs) {
				var rootRefId = root.refs[ref];
				if (rootRefId !== void 0) {
					_refVal = root.refVal[rootRefId];
					refCode = addLocalRef(ref, _refVal);
					return resolvedRef(_refVal, refCode);
				}
			}
			refCode = addLocalRef(ref);
			var v$1 = resolve$1.call(self, localCompile, root, ref);
			if (v$1 === void 0) {
				var localSchema = localRefs && localRefs[ref];
				if (localSchema) v$1 = resolve$1.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile$1.call(self, localSchema, root, localRefs, baseId$1);
			}
			if (v$1 === void 0) removeLocalRef(ref);
			else {
				replaceLocalRef(ref, v$1);
				return resolvedRef(v$1, refCode);
			}
		}
		function addLocalRef(ref, v$1) {
			var refId = refVal.length;
			refVal[refId] = v$1;
			refs[ref] = refId;
			return "refVal" + refId;
		}
		function removeLocalRef(ref) {
			delete refs[ref];
		}
		function replaceLocalRef(ref, v$1) {
			var refId = refs[ref];
			refVal[refId] = v$1;
		}
		function resolvedRef(refVal$1, code) {
			return typeof refVal$1 == "object" || typeof refVal$1 == "boolean" ? {
				code,
				schema: refVal$1,
				inline: true
			} : {
				code,
				$async: refVal$1 && !!refVal$1.$async
			};
		}
		function usePattern(regexStr) {
			var index = patternsHash[regexStr];
			if (index === void 0) {
				index = patternsHash[regexStr] = patterns.length;
				patterns[index] = regexStr;
			}
			return "pattern" + index;
		}
		function useDefault(value) {
			switch (typeof value) {
				case "boolean":
				case "number": return "" + value;
				case "string": return util$2.toQuotedString(value);
				case "object":
					if (value === null) return "null";
					var valueStr = stableStringify$1(value);
					var index = defaultsHash[valueStr];
					if (index === void 0) {
						index = defaultsHash[valueStr] = defaults.length;
						defaults[index] = value;
					}
					return "default" + index;
			}
		}
		function useCustomRule(rule, schema$1, parentSchema, it) {
			if (self._opts.validateSchema !== false) {
				var deps = rule.definition.dependencies;
				if (deps && !deps.every(function(keyword) {
					return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
				})) throw new Error("parent schema must have all required keywords: " + deps.join(","));
				var validateSchema$1 = rule.definition.validateSchema;
				if (validateSchema$1) {
					if (!validateSchema$1(schema$1)) {
						var message = "keyword schema is invalid: " + self.errorsText(validateSchema$1.errors);
						if (self._opts.validateSchema == "log") self.logger.error(message);
						else throw new Error(message);
					}
				}
			}
			var compile$2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
			var validate$1;
			if (compile$2) validate$1 = compile$2.call(self, schema$1, parentSchema, it);
			else if (macro) {
				validate$1 = macro.call(self, schema$1, parentSchema, it);
				if (opts.validateSchema !== false) self.validateSchema(validate$1, true);
			} else if (inline) validate$1 = inline.call(self, it, rule.keyword, schema$1, parentSchema);
			else {
				validate$1 = rule.definition.validate;
				if (!validate$1) return;
			}
			if (validate$1 === void 0) throw new Error("custom keyword \"" + rule.keyword + "\"failed to compile");
			var index = customRules.length;
			customRules[index] = validate$1;
			return {
				code: "customRule" + index,
				validate: validate$1
			};
		}
	}
	/**
	* Checks if the schema is currently compiled
	* @this   Ajv
	* @param  {Object} schema schema to compile
	* @param  {Object} root root object
	* @param  {String} baseId base schema ID
	* @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
	*/
	function checkCompiling(schema, root, baseId) {
		var index = compIndex.call(this, schema, root, baseId);
		if (index >= 0) return {
			index,
			compiling: true
		};
		index = this._compilations.length;
		this._compilations[index] = {
			schema,
			root,
			baseId
		};
		return {
			index,
			compiling: false
		};
	}
	/**
	* Removes the schema from the currently compiled list
	* @this   Ajv
	* @param  {Object} schema schema to compile
	* @param  {Object} root root object
	* @param  {String} baseId base schema ID
	*/
	function endCompiling(schema, root, baseId) {
		var i$3 = compIndex.call(this, schema, root, baseId);
		if (i$3 >= 0) this._compilations.splice(i$3, 1);
	}
	/**
	* Index of schema compilation in the currently compiled list
	* @this   Ajv
	* @param  {Object} schema schema to compile
	* @param  {Object} root root object
	* @param  {String} baseId base schema ID
	* @return {Integer} compilation index
	*/
	function compIndex(schema, root, baseId) {
		for (var i$3 = 0; i$3 < this._compilations.length; i$3++) {
			var c = this._compilations[i$3];
			if (c.schema == schema && c.root == root && c.baseId == baseId) return i$3;
		}
		return -1;
	}
	function patternCode(i$3, patterns) {
		return "var pattern" + i$3 + " = new RegExp(" + util$2.toQuotedString(patterns[i$3]) + ");";
	}
	function defaultCode(i$3) {
		return "var default" + i$3 + " = defaults[" + i$3 + "];";
	}
	function refValCode(i$3, refVal) {
		return refVal[i$3] === void 0 ? "" : "var refVal" + i$3 + " = refVal[" + i$3 + "];";
	}
	function customRuleCode$1(i$3) {
		return "var customRule" + i$3 + " = customRules[" + i$3 + "];";
	}
	function vars(arr, statement) {
		if (!arr.length) return "";
		var code = "";
		for (var i$3 = 0; i$3 < arr.length; i$3++) code += statement(i$3, arr);
		return code;
	}
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/cache.js
var require_cache = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/cache.js": ((exports, module) => {
	var Cache$1 = module.exports = function Cache$2() {
		this._cache = {};
	};
	Cache$1.prototype.put = function Cache_put(key$1, value) {
		this._cache[key$1] = value;
	};
	Cache$1.prototype.get = function Cache_get(key$1) {
		return this._cache[key$1];
	};
	Cache$1.prototype.del = function Cache_del(key$1) {
		delete this._cache[key$1];
	};
	Cache$1.prototype.clear = function Cache_clear() {
		this._cache = {};
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/formats.js
var require_formats = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/formats.js": ((exports, module) => {
	var util$1 = require_util();
	var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	var DAYS = [
		0,
		31,
		28,
		31,
		30,
		31,
		30,
		31,
		31,
		30,
		31,
		30,
		31
	];
	var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
	var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
	var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
	var URL$2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
	var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
	var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
	var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
	var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
	module.exports = formats$1;
	function formats$1(mode) {
		mode = mode == "full" ? "full" : "fast";
		return util$1.copy(formats$1[mode]);
	}
	formats$1.fast = {
		date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
		time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
		"date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
		uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
		"uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
		"uri-template": URITEMPLATE,
		url: URL$2,
		email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
		hostname: HOSTNAME,
		ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
		ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
		regex,
		uuid: UUID,
		"json-pointer": JSON_POINTER,
		"json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
		"relative-json-pointer": RELATIVE_JSON_POINTER
	};
	formats$1.full = {
		date,
		time,
		"date-time": date_time,
		uri,
		"uri-reference": URIREF,
		"uri-template": URITEMPLATE,
		url: URL$2,
		email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
		hostname: HOSTNAME,
		ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
		ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
		regex,
		uuid: UUID,
		"json-pointer": JSON_POINTER,
		"json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
		"relative-json-pointer": RELATIVE_JSON_POINTER
	};
	function isLeapYear(year) {
		return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
	}
	function date(str) {
		var matches = str.match(DATE);
		if (!matches) return false;
		var year = +matches[1];
		var month = +matches[2];
		var day = +matches[3];
		return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
	}
	function time(str, full) {
		var matches = str.match(TIME);
		if (!matches) return false;
		var hour = matches[1];
		var minute = matches[2];
		var second = matches[3];
		var timeZone = matches[5];
		return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
	}
	var DATE_TIME_SEPARATOR = /t|\s/i;
	function date_time(str) {
		var dateTime = str.split(DATE_TIME_SEPARATOR);
		return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
	}
	var NOT_URI_FRAGMENT = /\/|:/;
	function uri(str) {
		return NOT_URI_FRAGMENT.test(str) && URI.test(str);
	}
	var Z_ANCHOR = /[^\\]\\Z/;
	function regex(str) {
		if (Z_ANCHOR.test(str)) return false;
		try {
			new RegExp(str);
			return true;
		} catch (e) {
			return false;
		}
	}
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/ref.js
var require_ref = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/ref.js": ((exports, module) => {
	module.exports = function generate_ref(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $async, $refCode;
		if ($schema == "#" || $schema == "#/") if (it.isRoot) {
			$async = it.async;
			$refCode = "validate";
		} else {
			$async = it.root.schema.$async === true;
			$refCode = "root.refVal[0]";
		}
		else {
			var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
			if ($refVal === void 0) {
				var $message = it.MissingRefError.message(it.baseId, $schema);
				if (it.opts.missingRefs == "fail") {
					it.logger.error($message);
					var $$outStack = $$outStack || [];
					$$outStack.push(out);
					out = "";
					if (it.createErrors !== false) {
						out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
						if (it.opts.messages !== false) out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
						if (it.opts.verbose) out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					var __err = out;
					out = $$outStack.pop();
					if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
					if (it.async) out += " throw new ValidationError([" + __err + "]); ";
					else out += " validate.errors = [" + __err + "]; return false; ";
					else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
					if ($breakOnError) out += " if (false) { ";
				} else if (it.opts.missingRefs == "ignore") {
					it.logger.warn($message);
					if ($breakOnError) out += " if (true) { ";
				} else throw new it.MissingRefError(it.baseId, $schema, $message);
			} else if ($refVal.inline) {
				var $it = it.util.copy(it);
				$it.level++;
				var $nextValid = "valid" + $it.level;
				$it.schema = $refVal.schema;
				$it.schemaPath = "";
				$it.errSchemaPath = $schema;
				var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
				out += " " + $code + " ";
				if ($breakOnError) out += " if (" + $nextValid + ") { ";
			} else {
				$async = $refVal.$async === true || it.async && $refVal.$async !== false;
				$refCode = $refVal.code;
			}
		}
		if ($refCode) {
			var $$outStack = $$outStack || [];
			$$outStack.push(out);
			out = "";
			if (it.opts.passContext) out += " " + $refCode + ".call(this, ";
			else out += " " + $refCode + "( ";
			out += " " + $data + ", (dataPath || '')";
			if (it.errorPath != "\"\"") out += " + " + it.errorPath;
			var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
			out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
			var __callValidate = out;
			out = $$outStack.pop();
			if ($async) {
				if (!it.async) throw new Error("async schema referenced by sync schema");
				if ($breakOnError) out += " var " + $valid + "; ";
				out += " try { await " + __callValidate + "; ";
				if ($breakOnError) out += " " + $valid + " = true; ";
				out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
				if ($breakOnError) out += " " + $valid + " = false; ";
				out += " } ";
				if ($breakOnError) out += " if (" + $valid + ") { ";
			} else {
				out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
				if ($breakOnError) out += " else { ";
			}
		}
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/allOf.js": ((exports, module) => {
	module.exports = function generate_allOf(it, $keyword, $ruleType) {
		var out = " ";
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
		var arr1 = $schema;
		if (arr1) {
			var $sch, $i = -1, l1 = arr1.length - 1;
			while ($i < l1) {
				$sch = arr1[$i += 1];
				if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
					$allSchemasEmpty = false;
					$it.schema = $sch;
					$it.schemaPath = $schemaPath + "[" + $i + "]";
					$it.errSchemaPath = $errSchemaPath + "/" + $i;
					out += "  " + it.validate($it) + " ";
					$it.baseId = $currentBaseId;
					if ($breakOnError) {
						out += " if (" + $nextValid + ") { ";
						$closingBraces += "}";
					}
				}
			}
		}
		if ($breakOnError) if ($allSchemasEmpty) out += " if (true) { ";
		else out += " " + $closingBraces.slice(0, -1) + " ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/anyOf.js": ((exports, module) => {
	module.exports = function generate_anyOf(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		if ($schema.every(function($sch$1) {
			return it.opts.strictKeywords ? typeof $sch$1 == "object" && Object.keys($sch$1).length > 0 || $sch$1 === false : it.util.schemaHasRules($sch$1, it.RULES.all);
		})) {
			var $currentBaseId = $it.baseId;
			out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = true;
			var arr1 = $schema;
			if (arr1) {
				var $sch, $i = -1, l1 = arr1.length - 1;
				while ($i < l1) {
					$sch = arr1[$i += 1];
					$it.schema = $sch;
					$it.schemaPath = $schemaPath + "[" + $i + "]";
					$it.errSchemaPath = $errSchemaPath + "/" + $i;
					out += "  " + it.validate($it) + " ";
					$it.baseId = $currentBaseId;
					out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
					$closingBraces += "}";
				}
			}
			it.compositeRule = $it.compositeRule = $wasComposite;
			out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
			if (it.createErrors !== false) {
				out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
				if (it.opts.messages !== false) out += " , message: 'should match some schema in anyOf' ";
				if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				out += " } ";
			} else out += " {} ";
			out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
			if (it.async) out += " throw new ValidationError(vErrors); ";
			else out += " validate.errors = vErrors; return false; ";
			out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
			if (it.opts.allErrors) out += " } ";
		} else if ($breakOnError) out += " if (true) { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/comment.js
var require_comment = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/comment.js": ((exports, module) => {
	module.exports = function generate_comment(it, $keyword, $ruleType) {
		var out = " ";
		var $schema = it.schema[$keyword];
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		it.opts.allErrors;
		var $comment = it.util.toQuotedString($schema);
		if (it.opts.$comment === true) out += " console.log(" + $comment + ");";
		else if (typeof it.opts.$comment == "function") out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/const.js
var require_const = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/const.js": ((exports, module) => {
	module.exports = function generate_const(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl, $isData = it.opts.$data && $schema && $schema.$data;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			"" + $lvl;
		}
		if (!$isData) out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
		out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
			if (it.opts.messages !== false) out += " , message: 'should be equal to constant' ";
			if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += " }";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/contains.js
var require_contains = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/contains.js": ((exports, module) => {
	module.exports = function generate_contains(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
		out += "var " + $errs + " = errors;var " + $valid + ";";
		if ($nonEmptySchema) {
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = true;
			$it.schema = $schema;
			$it.schemaPath = $schemaPath;
			$it.errSchemaPath = $errSchemaPath;
			out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
			$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
			var $passData = $data + "[" + $idx + "]";
			$it.dataPathArr[$dataNxt] = $idx;
			var $code = it.validate($it);
			$it.baseId = $currentBaseId;
			if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
			else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
			out += " if (" + $nextValid + ") break; }  ";
			it.compositeRule = $it.compositeRule = $wasComposite;
			out += " " + $closingBraces + " if (!" + $nextValid + ") {";
		} else out += " if (" + $data + ".length == 0) {";
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
			if (it.opts.messages !== false) out += " , message: 'should contain a valid item' ";
			if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += " } else { ";
		if ($nonEmptySchema) out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
		if (it.opts.allErrors) out += " } ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/dependencies.js": ((exports, module) => {
	module.exports = function generate_dependencies(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
		for ($property in $schema) {
			if ($property == "__proto__") continue;
			var $sch = $schema[$property];
			var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
			$deps[$property] = $sch;
		}
		out += "var " + $errs + " = errors;";
		var $currentErrorPath = it.errorPath;
		out += "var missing" + $lvl + ";";
		for (var $property in $propertyDeps) {
			$deps = $propertyDeps[$property];
			if ($deps.length) {
				out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
				if ($ownProperties) out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
				if ($breakOnError) {
					out += " && ( ";
					var arr1 = $deps;
					if (arr1) {
						var $propertyKey, $i = -1, l1 = arr1.length - 1;
						while ($i < l1) {
							$propertyKey = arr1[$i += 1];
							if ($i) out += " || ";
							var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
							out += " ( ( " + $useData + " === undefined ";
							if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
							out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
						}
					}
					out += ")) {  ";
					var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
					if (it.opts._errorDataPathProperty) it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
					var $$outStack = $$outStack || [];
					$$outStack.push(out);
					out = "";
					if (it.createErrors !== false) {
						out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
						if (it.opts.messages !== false) {
							out += " , message: 'should have ";
							if ($deps.length == 1) out += "property " + it.util.escapeQuotes($deps[0]);
							else out += "properties " + it.util.escapeQuotes($deps.join(", "));
							out += " when property " + it.util.escapeQuotes($property) + " is present' ";
						}
						if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					var __err = out;
					out = $$outStack.pop();
					if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
					if (it.async) out += " throw new ValidationError([" + __err + "]); ";
					else out += " validate.errors = [" + __err + "]; return false; ";
					else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
				} else {
					out += " ) { ";
					var arr2 = $deps;
					if (arr2) {
						var $propertyKey, i2 = -1, l2 = arr2.length - 1;
						while (i2 < l2) {
							$propertyKey = arr2[i2 += 1];
							var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
							if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
							out += " if ( " + $useData + " === undefined ";
							if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
							out += ") {  var err =   ";
							if (it.createErrors !== false) {
								out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
								if (it.opts.messages !== false) {
									out += " , message: 'should have ";
									if ($deps.length == 1) out += "property " + it.util.escapeQuotes($deps[0]);
									else out += "properties " + it.util.escapeQuotes($deps.join(", "));
									out += " when property " + it.util.escapeQuotes($property) + " is present' ";
								}
								if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
								out += " } ";
							} else out += " {} ";
							out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
						}
					}
				}
				out += " }   ";
				if ($breakOnError) {
					$closingBraces += "}";
					out += " else { ";
				}
			}
		}
		it.errorPath = $currentErrorPath;
		var $currentBaseId = $it.baseId;
		for (var $property in $schemaDeps) {
			var $sch = $schemaDeps[$property];
			if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
				out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
				if ($ownProperties) out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
				out += ") { ";
				$it.schema = $sch;
				$it.schemaPath = $schemaPath + it.util.getProperty($property);
				$it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
				out += "  " + it.validate($it) + " ";
				$it.baseId = $currentBaseId;
				out += " }  ";
				if ($breakOnError) {
					out += " if (" + $nextValid + ") { ";
					$closingBraces += "}";
				}
			}
		}
		if ($breakOnError) out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/enum.js
var require_enum = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/enum.js": ((exports, module) => {
	module.exports = function generate_enum(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl, $isData = it.opts.$data && $schema && $schema.$data;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			"" + $lvl;
		}
		var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
		if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
		out += "var " + $valid + ";";
		if ($isData) out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
		out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
		if ($isData) out += "  }  ";
		out += " if (!" + $valid + ") {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
			if (it.opts.messages !== false) out += " , message: 'should be equal to one of the allowed values' ";
			if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += " }";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/format.js
var require_format = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/format.js": ((exports, module) => {
	module.exports = function generate_format(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		if (it.opts.format === false) {
			if ($breakOnError) out += " if (true) { ";
			return out;
		}
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
		if ($isData) {
			var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
			out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
			if (it.async) out += " var async" + $lvl + " = " + $format + ".async; ";
			out += " " + $format + " = " + $format + ".validate; } if (  ";
			if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
			out += " (";
			if ($unknownFormats != "ignore") {
				out += " (" + $schemaValue + " && !" + $format + " ";
				if ($allowUnknown) out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
				out += ") || ";
			}
			out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
			if (it.async) out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
			else out += " " + $format + "(" + $data + ") ";
			out += " : " + $format + ".test(" + $data + "))))) {";
		} else {
			var $format = it.formats[$schema];
			if (!$format) if ($unknownFormats == "ignore") {
				it.logger.warn("unknown format \"" + $schema + "\" ignored in schema at path \"" + it.errSchemaPath + "\"");
				if ($breakOnError) out += " if (true) { ";
				return out;
			} else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
				if ($breakOnError) out += " if (true) { ";
				return out;
			} else throw new Error("unknown format \"" + $schema + "\" is used in schema at path \"" + it.errSchemaPath + "\"");
			var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
			var $formatType = $isObject && $format.type || "string";
			if ($isObject) {
				var $async = $format.async === true;
				$format = $format.validate;
			}
			if ($formatType != $ruleType) {
				if ($breakOnError) out += " if (true) { ";
				return out;
			}
			if ($async) {
				if (!it.async) throw new Error("async format in sync schema");
				var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
				out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
			} else {
				out += " if (! ";
				var $formatRef = "formats" + it.util.getProperty($schema);
				if ($isObject) $formatRef += ".validate";
				if (typeof $format == "function") out += " " + $formatRef + "(" + $data + ") ";
				else out += " " + $formatRef + ".test(" + $data + ") ";
				out += ") { ";
			}
		}
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
			if ($isData) out += "" + $schemaValue;
			else out += "" + it.util.toQuotedString($schema);
			out += "  } ";
			if (it.opts.messages !== false) {
				out += " , message: 'should match format \"";
				if ($isData) out += "' + " + $schemaValue + " + '";
				else out += "" + it.util.escapeQuotes($schema);
				out += "\"' ";
			}
			if (it.opts.verbose) {
				out += " , schema:  ";
				if ($isData) out += "validate.schema" + $schemaPath;
				else out += "" + it.util.toQuotedString($schema);
				out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			}
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += " } ";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/if.js
var require_if = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/if.js": ((exports, module) => {
	module.exports = function generate_if(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		$it.level++;
		var $nextValid = "valid" + $it.level;
		var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
		if ($thenPresent || $elsePresent) {
			var $ifClause;
			$it.createErrors = false;
			$it.schema = $schema;
			$it.schemaPath = $schemaPath;
			$it.errSchemaPath = $errSchemaPath;
			out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = true;
			out += "  " + it.validate($it) + " ";
			$it.baseId = $currentBaseId;
			$it.createErrors = true;
			out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
			it.compositeRule = $it.compositeRule = $wasComposite;
			if ($thenPresent) {
				out += " if (" + $nextValid + ") {  ";
				$it.schema = it.schema["then"];
				$it.schemaPath = it.schemaPath + ".then";
				$it.errSchemaPath = it.errSchemaPath + "/then";
				out += "  " + it.validate($it) + " ";
				$it.baseId = $currentBaseId;
				out += " " + $valid + " = " + $nextValid + "; ";
				if ($thenPresent && $elsePresent) {
					$ifClause = "ifClause" + $lvl;
					out += " var " + $ifClause + " = 'then'; ";
				} else $ifClause = "'then'";
				out += " } ";
				if ($elsePresent) out += " else { ";
			} else out += " if (!" + $nextValid + ") { ";
			if ($elsePresent) {
				$it.schema = it.schema["else"];
				$it.schemaPath = it.schemaPath + ".else";
				$it.errSchemaPath = it.errSchemaPath + "/else";
				out += "  " + it.validate($it) + " ";
				$it.baseId = $currentBaseId;
				out += " " + $valid + " = " + $nextValid + "; ";
				if ($thenPresent && $elsePresent) {
					$ifClause = "ifClause" + $lvl;
					out += " var " + $ifClause + " = 'else'; ";
				} else $ifClause = "'else'";
				out += " } ";
			}
			out += " if (!" + $valid + ") {   var err =   ";
			if (it.createErrors !== false) {
				out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
				if (it.opts.messages !== false) out += " , message: 'should match \"' + " + $ifClause + " + '\" schema' ";
				if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				out += " } ";
			} else out += " {} ";
			out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
			if (it.async) out += " throw new ValidationError(vErrors); ";
			else out += " validate.errors = vErrors; return false; ";
			out += " }   ";
			if ($breakOnError) out += " else { ";
		} else if ($breakOnError) out += " if (true) { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/items.js
var require_items = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/items.js": ((exports, module) => {
	module.exports = function generate_items(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
		out += "var " + $errs + " = errors;var " + $valid + ";";
		if (Array.isArray($schema)) {
			var $additionalItems = it.schema.additionalItems;
			if ($additionalItems === false) {
				out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
				var $currErrSchemaPath = $errSchemaPath;
				$errSchemaPath = it.errSchemaPath + "/additionalItems";
				out += "  if (!" + $valid + ") {   ";
				var $$outStack = $$outStack || [];
				$$outStack.push(out);
				out = "";
				if (it.createErrors !== false) {
					out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
					if (it.opts.messages !== false) out += " , message: 'should NOT have more than " + $schema.length + " items' ";
					if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
					out += " } ";
				} else out += " {} ";
				var __err = out;
				out = $$outStack.pop();
				if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
				if (it.async) out += " throw new ValidationError([" + __err + "]); ";
				else out += " validate.errors = [" + __err + "]; return false; ";
				else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
				out += " } ";
				$errSchemaPath = $currErrSchemaPath;
				if ($breakOnError) {
					$closingBraces += "}";
					out += " else { ";
				}
			}
			var arr1 = $schema;
			if (arr1) {
				var $sch, $i = -1, l1 = arr1.length - 1;
				while ($i < l1) {
					$sch = arr1[$i += 1];
					if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
						out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
						var $passData = $data + "[" + $i + "]";
						$it.schema = $sch;
						$it.schemaPath = $schemaPath + "[" + $i + "]";
						$it.errSchemaPath = $errSchemaPath + "/" + $i;
						$it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
						$it.dataPathArr[$dataNxt] = $i;
						var $code = it.validate($it);
						$it.baseId = $currentBaseId;
						if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
						else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
						out += " }  ";
						if ($breakOnError) {
							out += " if (" + $nextValid + ") { ";
							$closingBraces += "}";
						}
					}
				}
			}
			if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
				$it.schema = $additionalItems;
				$it.schemaPath = it.schemaPath + ".additionalItems";
				$it.errSchemaPath = it.errSchemaPath + "/additionalItems";
				out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
				$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
				var $passData = $data + "[" + $idx + "]";
				$it.dataPathArr[$dataNxt] = $idx;
				var $code = it.validate($it);
				$it.baseId = $currentBaseId;
				if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
				else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
				if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
				out += " } }  ";
				if ($breakOnError) {
					out += " if (" + $nextValid + ") { ";
					$closingBraces += "}";
				}
			}
		} else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
			$it.schema = $schema;
			$it.schemaPath = $schemaPath;
			$it.errSchemaPath = $errSchemaPath;
			out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
			$it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
			var $passData = $data + "[" + $idx + "]";
			$it.dataPathArr[$dataNxt] = $idx;
			var $code = it.validate($it);
			$it.baseId = $currentBaseId;
			if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
			else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
			if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
			out += " }";
		}
		if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limit.js
var require__limit = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limit.js": ((exports, module) => {
	module.exports = function generate__limit(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $errorKeyword;
		var $data = "data" + ($dataLvl || "");
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
		if (!($isData || typeof $schema == "number" || $schema === void 0)) throw new Error($keyword + " must be number");
		if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) throw new Error($exclusiveKeyword + " must be number or boolean");
		if ($isDataExcl) {
			var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
			out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
			$schemaValueExcl = "schemaExcl" + $lvl;
			out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
			var $errorKeyword = $exclusiveKeyword;
			var $$outStack = $$outStack || [];
			$$outStack.push(out);
			out = "";
			if (it.createErrors !== false) {
				out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
				if (it.opts.messages !== false) out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
				if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				out += " } ";
			} else out += " {} ";
			var __err = out;
			out = $$outStack.pop();
			if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
			if (it.async) out += " throw new ValidationError([" + __err + "]); ";
			else out += " validate.errors = [" + __err + "]; return false; ";
			else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			out += " } else if ( ";
			if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
			out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
			if ($schema === void 0) {
				$errorKeyword = $exclusiveKeyword;
				$errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
				$schemaValue = $schemaValueExcl;
				$isData = $isDataExcl;
			}
		} else {
			var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
			if ($exclIsNumber && $isData) {
				var $opExpr = "'" + $opStr + "'";
				out += " if ( ";
				if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
				out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
			} else {
				if ($exclIsNumber && $schema === void 0) {
					$exclusive = true;
					$errorKeyword = $exclusiveKeyword;
					$errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
					$schemaValue = $schemaExcl;
					$notOp += "=";
				} else {
					if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
					if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
						$exclusive = true;
						$errorKeyword = $exclusiveKeyword;
						$errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
						$notOp += "=";
					} else {
						$exclusive = false;
						$opStr += "=";
					}
				}
				var $opExpr = "'" + $opStr + "'";
				out += " if ( ";
				if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
				out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
			}
		}
		$errorKeyword = $errorKeyword || $keyword;
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
			if (it.opts.messages !== false) {
				out += " , message: 'should be " + $opStr + " ";
				if ($isData) out += "' + " + $schemaValue;
				else out += "" + $schemaValue + "'";
			}
			if (it.opts.verbose) {
				out += " , schema:  ";
				if ($isData) out += "validate.schema" + $schemaPath;
				else out += "" + $schema;
				out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			}
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += " } ";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitItems.js
var require__limitItems = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitItems.js": ((exports, module) => {
	module.exports = function generate__limitItems(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $errorKeyword;
		var $data = "data" + ($dataLvl || "");
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
		var $op = $keyword == "maxItems" ? ">" : "<";
		out += "if ( ";
		if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
		out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
		var $errorKeyword = $keyword;
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
			if (it.opts.messages !== false) {
				out += " , message: 'should NOT have ";
				if ($keyword == "maxItems") out += "more";
				else out += "fewer";
				out += " than ";
				if ($isData) out += "' + " + $schemaValue + " + '";
				else out += "" + $schema;
				out += " items' ";
			}
			if (it.opts.verbose) {
				out += " , schema:  ";
				if ($isData) out += "validate.schema" + $schemaPath;
				else out += "" + $schema;
				out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			}
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += "} ";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitLength.js
var require__limitLength = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitLength.js": ((exports, module) => {
	module.exports = function generate__limitLength(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $errorKeyword;
		var $data = "data" + ($dataLvl || "");
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
		var $op = $keyword == "maxLength" ? ">" : "<";
		out += "if ( ";
		if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
		if (it.opts.unicode === false) out += " " + $data + ".length ";
		else out += " ucs2length(" + $data + ") ";
		out += " " + $op + " " + $schemaValue + ") { ";
		var $errorKeyword = $keyword;
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
			if (it.opts.messages !== false) {
				out += " , message: 'should NOT be ";
				if ($keyword == "maxLength") out += "longer";
				else out += "shorter";
				out += " than ";
				if ($isData) out += "' + " + $schemaValue + " + '";
				else out += "" + $schema;
				out += " characters' ";
			}
			if (it.opts.verbose) {
				out += " , schema:  ";
				if ($isData) out += "validate.schema" + $schemaPath;
				else out += "" + $schema;
				out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			}
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += "} ";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitProperties.js
var require__limitProperties = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/_limitProperties.js": ((exports, module) => {
	module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $errorKeyword;
		var $data = "data" + ($dataLvl || "");
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
		var $op = $keyword == "maxProperties" ? ">" : "<";
		out += "if ( ";
		if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
		out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
		var $errorKeyword = $keyword;
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
			if (it.opts.messages !== false) {
				out += " , message: 'should NOT have ";
				if ($keyword == "maxProperties") out += "more";
				else out += "fewer";
				out += " than ";
				if ($isData) out += "' + " + $schemaValue + " + '";
				else out += "" + $schema;
				out += " properties' ";
			}
			if (it.opts.verbose) {
				out += " , schema:  ";
				if ($isData) out += "validate.schema" + $schemaPath;
				else out += "" + $schema;
				out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			}
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += "} ";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/multipleOf.js": ((exports, module) => {
	module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		if (!($isData || typeof $schema == "number")) throw new Error($keyword + " must be number");
		out += "var division" + $lvl + ";if (";
		if ($isData) out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
		out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
		if (it.opts.multipleOfPrecision) out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
		else out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
		out += " ) ";
		if ($isData) out += "  )  ";
		out += " ) {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
			if (it.opts.messages !== false) {
				out += " , message: 'should be multiple of ";
				if ($isData) out += "' + " + $schemaValue;
				else out += "" + $schemaValue + "'";
			}
			if (it.opts.verbose) {
				out += " , schema:  ";
				if ($isData) out += "validate.schema" + $schemaPath;
				else out += "" + $schema;
				out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			}
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += "} ";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/not.js
var require_not = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/not.js": ((exports, module) => {
	module.exports = function generate_not(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		$it.level++;
		var $nextValid = "valid" + $it.level;
		if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
			$it.schema = $schema;
			$it.schemaPath = $schemaPath;
			$it.errSchemaPath = $errSchemaPath;
			out += " var " + $errs + " = errors;  ";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = true;
			$it.createErrors = false;
			var $allErrorsOption;
			if ($it.opts.allErrors) {
				$allErrorsOption = $it.opts.allErrors;
				$it.opts.allErrors = false;
			}
			out += " " + it.validate($it) + " ";
			$it.createErrors = true;
			if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
			it.compositeRule = $it.compositeRule = $wasComposite;
			out += " if (" + $nextValid + ") {   ";
			var $$outStack = $$outStack || [];
			$$outStack.push(out);
			out = "";
			if (it.createErrors !== false) {
				out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
				if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";
				if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				out += " } ";
			} else out += " {} ";
			var __err = out;
			out = $$outStack.pop();
			if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
			if (it.async) out += " throw new ValidationError([" + __err + "]); ";
			else out += " validate.errors = [" + __err + "]; return false; ";
			else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
			if (it.opts.allErrors) out += " } ";
		} else {
			out += "  var err =   ";
			if (it.createErrors !== false) {
				out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
				if (it.opts.messages !== false) out += " , message: 'should NOT be valid' ";
				if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				out += " } ";
			} else out += " {} ";
			out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			if ($breakOnError) out += " if (false) { ";
		}
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/oneOf.js": ((exports, module) => {
	module.exports = function generate_oneOf(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
		out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
		var $wasComposite = it.compositeRule;
		it.compositeRule = $it.compositeRule = true;
		var arr1 = $schema;
		if (arr1) {
			var $sch, $i = -1, l1 = arr1.length - 1;
			while ($i < l1) {
				$sch = arr1[$i += 1];
				if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
					$it.schema = $sch;
					$it.schemaPath = $schemaPath + "[" + $i + "]";
					$it.errSchemaPath = $errSchemaPath + "/" + $i;
					out += "  " + it.validate($it) + " ";
					$it.baseId = $currentBaseId;
				} else out += " var " + $nextValid + " = true; ";
				if ($i) {
					out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
					$closingBraces += "}";
				}
				out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
			}
		}
		it.compositeRule = $it.compositeRule = $wasComposite;
		out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
		if (it.createErrors !== false) {
			out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
			if (it.opts.messages !== false) out += " , message: 'should match exactly one schema in oneOf' ";
			if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			out += " } ";
		} else out += " {} ";
		out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError(vErrors); ";
		else out += " validate.errors = vErrors; return false; ";
		out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
		if (it.opts.allErrors) out += " } ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/pattern.js": ((exports, module) => {
	module.exports = function generate_pattern(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
		out += "if ( ";
		if ($isData) out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
		out += " !" + $regexp + ".test(" + $data + ") ) {   ";
		var $$outStack = $$outStack || [];
		$$outStack.push(out);
		out = "";
		if (it.createErrors !== false) {
			out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
			if ($isData) out += "" + $schemaValue;
			else out += "" + it.util.toQuotedString($schema);
			out += "  } ";
			if (it.opts.messages !== false) {
				out += " , message: 'should match pattern \"";
				if ($isData) out += "' + " + $schemaValue + " + '";
				else out += "" + it.util.escapeQuotes($schema);
				out += "\"' ";
			}
			if (it.opts.verbose) {
				out += " , schema:  ";
				if ($isData) out += "validate.schema" + $schemaPath;
				else out += "" + it.util.toQuotedString($schema);
				out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
			}
			out += " } ";
		} else out += " {} ";
		var __err = out;
		out = $$outStack.pop();
		if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
		if (it.async) out += " throw new ValidationError([" + __err + "]); ";
		else out += " validate.errors = [" + __err + "]; return false; ";
		else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
		out += "} ";
		if ($breakOnError) out += " else { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/properties.js
var require_properties = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/properties.js": ((exports, module) => {
	module.exports = function generate_properties(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
		var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
		var $required = it.schema.required;
		if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
		function notProto(p) {
			return p !== "__proto__";
		}
		out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
		if ($ownProperties) out += " var " + $dataProperties + " = undefined;";
		if ($checkAdditional) {
			if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
			else out += " for (var " + $key + " in " + $data + ") { ";
			if ($someProperties) {
				out += " var isAdditional" + $lvl + " = !(false ";
				if ($schemaKeys.length) if ($schemaKeys.length > 8) out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
				else {
					var arr1 = $schemaKeys;
					if (arr1) {
						var $propertyKey, i1 = -1, l1 = arr1.length - 1;
						while (i1 < l1) {
							$propertyKey = arr1[i1 += 1];
							out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
						}
					}
				}
				if ($pPropertyKeys.length) {
					var arr2 = $pPropertyKeys;
					if (arr2) {
						var $pProperty, $i = -1, l2 = arr2.length - 1;
						while ($i < l2) {
							$pProperty = arr2[$i += 1];
							out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
						}
					}
				}
				out += " ); if (isAdditional" + $lvl + ") { ";
			}
			if ($removeAdditional == "all") out += " delete " + $data + "[" + $key + "]; ";
			else {
				var $currentErrorPath = it.errorPath;
				var $additionalProperty = "' + " + $key + " + '";
				if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
				if ($noAdditional) if ($removeAdditional) out += " delete " + $data + "[" + $key + "]; ";
				else {
					out += " " + $nextValid + " = false; ";
					var $currErrSchemaPath = $errSchemaPath;
					$errSchemaPath = it.errSchemaPath + "/additionalProperties";
					var $$outStack = $$outStack || [];
					$$outStack.push(out);
					out = "";
					if (it.createErrors !== false) {
						out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
						if (it.opts.messages !== false) {
							out += " , message: '";
							if (it.opts._errorDataPathProperty) out += "is an invalid additional property";
							else out += "should NOT have additional properties";
							out += "' ";
						}
						if (it.opts.verbose) out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					var __err = out;
					out = $$outStack.pop();
					if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
					if (it.async) out += " throw new ValidationError([" + __err + "]); ";
					else out += " validate.errors = [" + __err + "]; return false; ";
					else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
					$errSchemaPath = $currErrSchemaPath;
					if ($breakOnError) out += " break; ";
				}
				else if ($additionalIsSchema) if ($removeAdditional == "failing") {
					out += " var " + $errs + " = errors;  ";
					var $wasComposite = it.compositeRule;
					it.compositeRule = $it.compositeRule = true;
					$it.schema = $aProperties;
					$it.schemaPath = it.schemaPath + ".additionalProperties";
					$it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
					$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
					var $passData = $data + "[" + $key + "]";
					$it.dataPathArr[$dataNxt] = $key;
					var $code = it.validate($it);
					$it.baseId = $currentBaseId;
					if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
					else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
					out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
					it.compositeRule = $it.compositeRule = $wasComposite;
				} else {
					$it.schema = $aProperties;
					$it.schemaPath = it.schemaPath + ".additionalProperties";
					$it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
					$it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
					var $passData = $data + "[" + $key + "]";
					$it.dataPathArr[$dataNxt] = $key;
					var $code = it.validate($it);
					$it.baseId = $currentBaseId;
					if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
					else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
					if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
				}
				it.errorPath = $currentErrorPath;
			}
			if ($someProperties) out += " } ";
			out += " }  ";
			if ($breakOnError) {
				out += " if (" + $nextValid + ") { ";
				$closingBraces += "}";
			}
		}
		var $useDefaults = it.opts.useDefaults && !it.compositeRule;
		if ($schemaKeys.length) {
			var arr3 = $schemaKeys;
			if (arr3) {
				var $propertyKey, i3 = -1, l3 = arr3.length - 1;
				while (i3 < l3) {
					$propertyKey = arr3[i3 += 1];
					var $sch = $schema[$propertyKey];
					if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
						var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
						$it.schema = $sch;
						$it.schemaPath = $schemaPath + $prop;
						$it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
						$it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
						$it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
						var $code = it.validate($it);
						$it.baseId = $currentBaseId;
						if (it.util.varOccurences($code, $nextData) < 2) {
							$code = it.util.varReplace($code, $nextData, $passData);
							var $useData = $passData;
						} else {
							var $useData = $nextData;
							out += " var " + $nextData + " = " + $passData + "; ";
						}
						if ($hasDefault) out += " " + $code + " ";
						else {
							if ($requiredHash && $requiredHash[$propertyKey]) {
								out += " if ( " + $useData + " === undefined ";
								if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
								out += ") { " + $nextValid + " = false; ";
								var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
								if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
								$errSchemaPath = it.errSchemaPath + "/required";
								var $$outStack = $$outStack || [];
								$$outStack.push(out);
								out = "";
								if (it.createErrors !== false) {
									out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
									if (it.opts.messages !== false) {
										out += " , message: '";
										if (it.opts._errorDataPathProperty) out += "is a required property";
										else out += "should have required property \\'" + $missingProperty + "\\'";
										out += "' ";
									}
									if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
									out += " } ";
								} else out += " {} ";
								var __err = out;
								out = $$outStack.pop();
								if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
								if (it.async) out += " throw new ValidationError([" + __err + "]); ";
								else out += " validate.errors = [" + __err + "]; return false; ";
								else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
								$errSchemaPath = $currErrSchemaPath;
								it.errorPath = $currentErrorPath;
								out += " } else { ";
							} else if ($breakOnError) {
								out += " if ( " + $useData + " === undefined ";
								if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
								out += ") { " + $nextValid + " = true; } else { ";
							} else {
								out += " if (" + $useData + " !== undefined ";
								if ($ownProperties) out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
								out += " ) { ";
							}
							out += " " + $code + " } ";
						}
					}
					if ($breakOnError) {
						out += " if (" + $nextValid + ") { ";
						$closingBraces += "}";
					}
				}
			}
		}
		if ($pPropertyKeys.length) {
			var arr4 = $pPropertyKeys;
			if (arr4) {
				var $pProperty, i4 = -1, l4 = arr4.length - 1;
				while (i4 < l4) {
					$pProperty = arr4[i4 += 1];
					var $sch = $pProperties[$pProperty];
					if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
						$it.schema = $sch;
						$it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
						$it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
						if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
						else out += " for (var " + $key + " in " + $data + ") { ";
						out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
						$it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
						var $passData = $data + "[" + $key + "]";
						$it.dataPathArr[$dataNxt] = $key;
						var $code = it.validate($it);
						$it.baseId = $currentBaseId;
						if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
						else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
						if ($breakOnError) out += " if (!" + $nextValid + ") break; ";
						out += " } ";
						if ($breakOnError) out += " else " + $nextValid + " = true; ";
						out += " }  ";
						if ($breakOnError) {
							out += " if (" + $nextValid + ") { ";
							$closingBraces += "}";
						}
					}
				}
			}
		}
		if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/propertyNames.js": ((exports, module) => {
	module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $errs = "errs__" + $lvl;
		var $it = it.util.copy(it);
		var $closingBraces = "";
		$it.level++;
		var $nextValid = "valid" + $it.level;
		out += "var " + $errs + " = errors;";
		if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
			$it.schema = $schema;
			$it.schemaPath = $schemaPath;
			$it.errSchemaPath = $errSchemaPath;
			var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
			if ($ownProperties) out += " var " + $dataProperties + " = undefined; ";
			if ($ownProperties) out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
			else out += " for (var " + $key + " in " + $data + ") { ";
			out += " var startErrs" + $lvl + " = errors; ";
			var $passData = $key;
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = true;
			var $code = it.validate($it);
			$it.baseId = $currentBaseId;
			if (it.util.varOccurences($code, $nextData) < 2) out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
			else out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
			it.compositeRule = $it.compositeRule = $wasComposite;
			out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
			if (it.createErrors !== false) {
				out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
				if (it.opts.messages !== false) out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
				if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				out += " } ";
			} else out += " {} ";
			out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
			if (it.async) out += " throw new ValidationError(vErrors); ";
			else out += " validate.errors = vErrors; return false; ";
			if ($breakOnError) out += " break; ";
			out += " } }";
		}
		if ($breakOnError) out += " " + $closingBraces + " if (" + $errs + " == errors) {";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/required.js
var require_required = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/required.js": ((exports, module) => {
	module.exports = function generate_required(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl, $isData = it.opts.$data && $schema && $schema.$data;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			"" + $lvl;
		}
		var $vSchema = "schema" + $lvl;
		if (!$isData) if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
			var $required = [];
			var arr1 = $schema;
			if (arr1) {
				var $property, i1 = -1, l1 = arr1.length - 1;
				while (i1 < l1) {
					$property = arr1[i1 += 1];
					var $propertySch = it.schema.properties[$property];
					if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) $required[$required.length] = $property;
				}
			}
		} else var $required = $schema;
		if ($isData || $required.length) {
			var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
			if ($breakOnError) {
				out += " var missing" + $lvl + "; ";
				if ($loopRequired) {
					if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
					var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
					if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
					out += " var " + $valid + " = true; ";
					if ($isData) out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
					out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
					if ($ownProperties) out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
					out += "; if (!" + $valid + ") break; } ";
					if ($isData) out += "  }  ";
					out += "  if (!" + $valid + ") {   ";
					var $$outStack = $$outStack || [];
					$$outStack.push(out);
					out = "";
					if (it.createErrors !== false) {
						out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
						if (it.opts.messages !== false) {
							out += " , message: '";
							if (it.opts._errorDataPathProperty) out += "is a required property";
							else out += "should have required property \\'" + $missingProperty + "\\'";
							out += "' ";
						}
						if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					var __err = out;
					out = $$outStack.pop();
					if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
					if (it.async) out += " throw new ValidationError([" + __err + "]); ";
					else out += " validate.errors = [" + __err + "]; return false; ";
					else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
					out += " } else { ";
				} else {
					out += " if ( ";
					var arr2 = $required;
					if (arr2) {
						var $propertyKey, $i = -1, l2 = arr2.length - 1;
						while ($i < l2) {
							$propertyKey = arr2[$i += 1];
							if ($i) out += " || ";
							var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
							out += " ( ( " + $useData + " === undefined ";
							if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
							out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
						}
					}
					out += ") {  ";
					var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
					if (it.opts._errorDataPathProperty) it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
					var $$outStack = $$outStack || [];
					$$outStack.push(out);
					out = "";
					if (it.createErrors !== false) {
						out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
						if (it.opts.messages !== false) {
							out += " , message: '";
							if (it.opts._errorDataPathProperty) out += "is a required property";
							else out += "should have required property \\'" + $missingProperty + "\\'";
							out += "' ";
						}
						if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					var __err = out;
					out = $$outStack.pop();
					if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
					if (it.async) out += " throw new ValidationError([" + __err + "]); ";
					else out += " validate.errors = [" + __err + "]; return false; ";
					else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
					out += " } else { ";
				}
			} else if ($loopRequired) {
				if (!$isData) out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
				var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
				if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
				if ($isData) {
					out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
					if (it.createErrors !== false) {
						out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
						if (it.opts.messages !== false) {
							out += " , message: '";
							if (it.opts._errorDataPathProperty) out += "is a required property";
							else out += "should have required property \\'" + $missingProperty + "\\'";
							out += "' ";
						}
						if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
						out += " } ";
					} else out += " {} ";
					out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
				}
				out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
				if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
				out += ") {  var err =   ";
				if (it.createErrors !== false) {
					out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
					if (it.opts.messages !== false) {
						out += " , message: '";
						if (it.opts._errorDataPathProperty) out += "is a required property";
						else out += "should have required property \\'" + $missingProperty + "\\'";
						out += "' ";
					}
					if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
					out += " } ";
				} else out += " {} ";
				out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
				if ($isData) out += "  }  ";
			} else {
				var arr3 = $required;
				if (arr3) {
					var $propertyKey, i3 = -1, l3 = arr3.length - 1;
					while (i3 < l3) {
						$propertyKey = arr3[i3 += 1];
						var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
						if (it.opts._errorDataPathProperty) it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
						out += " if ( " + $useData + " === undefined ";
						if ($ownProperties) out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
						out += ") {  var err =   ";
						if (it.createErrors !== false) {
							out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
							if (it.opts.messages !== false) {
								out += " , message: '";
								if (it.opts._errorDataPathProperty) out += "is a required property";
								else out += "should have required property \\'" + $missingProperty + "\\'";
								out += "' ";
							}
							if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
							out += " } ";
						} else out += " {} ";
						out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
					}
				}
			}
			it.errorPath = $currentErrorPath;
		} else if ($breakOnError) out += " if (true) {";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/uniqueItems.js": ((exports, module) => {
	module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		if (($schema || $isData) && it.opts.uniqueItems !== false) {
			if ($isData) out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
			out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
			var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
			if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
			else {
				out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
				var $method = "checkDataType" + ($typeIsArray ? "s" : "");
				out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
				if ($typeIsArray) out += " if (typeof item == 'string') item = '\"' + item; ";
				out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
			}
			out += " } ";
			if ($isData) out += "  }  ";
			out += " if (!" + $valid + ") {   ";
			var $$outStack = $$outStack || [];
			$$outStack.push(out);
			out = "";
			if (it.createErrors !== false) {
				out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
				if (it.opts.messages !== false) out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
				if (it.opts.verbose) {
					out += " , schema:  ";
					if ($isData) out += "validate.schema" + $schemaPath;
					else out += "" + $schema;
					out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				}
				out += " } ";
			} else out += " {} ";
			var __err = out;
			out = $$outStack.pop();
			if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
			if (it.async) out += " throw new ValidationError([" + __err + "]); ";
			else out += " validate.errors = [" + __err + "]; return false; ";
			else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			out += " } ";
			if ($breakOnError) out += " else { ";
		} else if ($breakOnError) out += " if (true) { ";
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/index.js
var require_dotjs = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/index.js": ((exports, module) => {
	module.exports = {
		"$ref": require_ref(),
		allOf: require_allOf(),
		anyOf: require_anyOf(),
		"$comment": require_comment(),
		const: require_const(),
		contains: require_contains(),
		dependencies: require_dependencies(),
		"enum": require_enum(),
		format: require_format(),
		"if": require_if(),
		items: require_items(),
		maximum: require__limit(),
		minimum: require__limit(),
		maxItems: require__limitItems(),
		minItems: require__limitItems(),
		maxLength: require__limitLength(),
		minLength: require__limitLength(),
		maxProperties: require__limitProperties(),
		minProperties: require__limitProperties(),
		multipleOf: require_multipleOf(),
		not: require_not(),
		oneOf: require_oneOf(),
		pattern: require_pattern(),
		properties: require_properties(),
		propertyNames: require_propertyNames(),
		required: require_required(),
		uniqueItems: require_uniqueItems(),
		validate: require_validate()
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/rules.js
var require_rules = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/rules.js": ((exports, module) => {
	var ruleModules = require_dotjs(), toHash = require_util().toHash;
	module.exports = function rules$1() {
		var RULES = [
			{
				type: "number",
				rules: [
					{ "maximum": ["exclusiveMaximum"] },
					{ "minimum": ["exclusiveMinimum"] },
					"multipleOf",
					"format"
				]
			},
			{
				type: "string",
				rules: [
					"maxLength",
					"minLength",
					"pattern",
					"format"
				]
			},
			{
				type: "array",
				rules: [
					"maxItems",
					"minItems",
					"items",
					"contains",
					"uniqueItems"
				]
			},
			{
				type: "object",
				rules: [
					"maxProperties",
					"minProperties",
					"required",
					"dependencies",
					"propertyNames",
					{ "properties": ["additionalProperties", "patternProperties"] }
				]
			},
			{ rules: [
				"$ref",
				"const",
				"enum",
				"not",
				"anyOf",
				"oneOf",
				"allOf",
				"if"
			] }
		];
		var ALL = ["type", "$comment"];
		var KEYWORDS$1 = [
			"$schema",
			"$id",
			"id",
			"$data",
			"$async",
			"title",
			"description",
			"default",
			"definitions",
			"examples",
			"readOnly",
			"writeOnly",
			"contentMediaType",
			"contentEncoding",
			"additionalItems",
			"then",
			"else"
		];
		var TYPES = [
			"number",
			"integer",
			"string",
			"array",
			"object",
			"boolean",
			"null"
		];
		RULES.all = toHash(ALL);
		RULES.types = toHash(TYPES);
		RULES.forEach(function(group) {
			group.rules = group.rules.map(function(keyword) {
				var implKeywords;
				if (typeof keyword == "object") {
					var key$1 = Object.keys(keyword)[0];
					implKeywords = keyword[key$1];
					keyword = key$1;
					implKeywords.forEach(function(k) {
						ALL.push(k);
						RULES.all[k] = true;
					});
				}
				ALL.push(keyword);
				return RULES.all[keyword] = {
					keyword,
					code: ruleModules[keyword],
					implements: implKeywords
				};
			});
			RULES.all.$comment = {
				keyword: "$comment",
				code: ruleModules.$comment
			};
			if (group.type) RULES.types[group.type] = group;
		});
		RULES.keywords = toHash(ALL.concat(KEYWORDS$1));
		RULES.custom = {};
		return RULES;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/data.js
var require_data$1 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/data.js": ((exports, module) => {
	var KEYWORDS = [
		"multipleOf",
		"maximum",
		"exclusiveMaximum",
		"minimum",
		"exclusiveMinimum",
		"maxLength",
		"minLength",
		"pattern",
		"additionalItems",
		"maxItems",
		"minItems",
		"uniqueItems",
		"maxProperties",
		"minProperties",
		"required",
		"additionalProperties",
		"enum",
		"format",
		"const"
	];
	module.exports = function(metaSchema$1, keywordsJsonPointers) {
		for (var i$3 = 0; i$3 < keywordsJsonPointers.length; i$3++) {
			metaSchema$1 = JSON.parse(JSON.stringify(metaSchema$1));
			var segments = keywordsJsonPointers[i$3].split("/");
			var keywords = metaSchema$1;
			var j;
			for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];
			for (j = 0; j < KEYWORDS.length; j++) {
				var key$1 = KEYWORDS[j];
				var schema = keywords[key$1];
				if (schema) keywords[key$1] = { anyOf: [schema, { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] };
			}
		}
		return metaSchema$1;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/async.js
var require_async = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/compile/async.js": ((exports, module) => {
	var MissingRefError = require_error_classes().MissingRef;
	module.exports = compileAsync;
	/**
	* Creates validating function for passed schema with asynchronous loading of missing schemas.
	* `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
	* @this  Ajv
	* @param {Object}   schema schema object
	* @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
	* @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
	* @return {Promise} promise that resolves with a validating function.
	*/
	function compileAsync(schema, meta, callback) {
		var self = this;
		if (typeof this._opts.loadSchema != "function") throw new Error("options.loadSchema should be a function");
		if (typeof meta == "function") {
			callback = meta;
			meta = void 0;
		}
		var p = loadMetaSchemaOf(schema).then(function() {
			var schemaObj = self._addSchema(schema, void 0, meta);
			return schemaObj.validate || _compileAsync(schemaObj);
		});
		if (callback) p.then(function(v) {
			callback(null, v);
		}, callback);
		return p;
		function loadMetaSchemaOf(sch) {
			var $schema = sch.$schema;
			return $schema && !self.getSchema($schema) ? compileAsync.call(self, { $ref: $schema }, true) : Promise.resolve();
		}
		function _compileAsync(schemaObj) {
			try {
				return self._compile(schemaObj);
			} catch (e) {
				if (e instanceof MissingRefError) return loadMissingSchema(e);
				throw e;
			}
			function loadMissingSchema(e) {
				var ref = e.missingSchema;
				if (added(ref)) throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
				var schemaPromise = self._loadingSchemas[ref];
				if (!schemaPromise) {
					schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
					schemaPromise.then(removePromise, removePromise);
				}
				return schemaPromise.then(function(sch) {
					if (!added(ref)) return loadMetaSchemaOf(sch).then(function() {
						if (!added(ref)) self.addSchema(sch, ref, void 0, meta);
					});
				}).then(function() {
					return _compileAsync(schemaObj);
				});
				function removePromise() {
					delete self._loadingSchemas[ref];
				}
				function added(ref$1) {
					return self._refs[ref$1] || self._schemas[ref$1];
				}
			}
		}
	}
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/custom.js
var require_custom = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/dotjs/custom.js": ((exports, module) => {
	module.exports = function generate_custom(it, $keyword, $ruleType) {
		var out = " ";
		var $lvl = it.level;
		var $dataLvl = it.dataLevel;
		var $schema = it.schema[$keyword];
		var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
		var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
		var $breakOnError = !it.opts.allErrors;
		var $errorKeyword;
		var $data = "data" + ($dataLvl || "");
		var $valid = "valid" + $lvl;
		var $errs = "errs__" + $lvl;
		var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
		if ($isData) {
			out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
			$schemaValue = "schema" + $lvl;
		} else $schemaValue = $schema;
		var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
		var $compile, $inline, $macro, $ruleValidate, $validateCode;
		if ($isData && $rDef.$data) {
			$validateCode = "keywordValidate" + $lvl;
			var $validateSchema = $rDef.validateSchema;
			out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
		} else {
			$ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
			if (!$ruleValidate) return;
			$schemaValue = "validate.schema" + $schemaPath;
			$validateCode = $ruleValidate.code;
			$compile = $rDef.compile;
			$inline = $rDef.inline;
			$macro = $rDef.macro;
		}
		var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
		if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
		if (!($inline || $macro)) out += "" + $ruleErrs + " = null;";
		out += "var " + $errs + " = errors;var " + $valid + ";";
		if ($isData && $rDef.$data) {
			$closingBraces += "}";
			out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
			if ($validateSchema) {
				$closingBraces += "}";
				out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
			}
		}
		if ($inline) if ($rDef.statements) out += " " + $ruleValidate.validate + " ";
		else out += " " + $valid + " = " + $ruleValidate.validate + "; ";
		else if ($macro) {
			var $it = it.util.copy(it);
			var $closingBraces = "";
			$it.level++;
			var $nextValid = "valid" + $it.level;
			$it.schema = $ruleValidate.validate;
			$it.schemaPath = "";
			var $wasComposite = it.compositeRule;
			it.compositeRule = $it.compositeRule = true;
			var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
			it.compositeRule = $it.compositeRule = $wasComposite;
			out += " " + $code;
		} else {
			var $$outStack = $$outStack || [];
			$$outStack.push(out);
			out = "";
			out += "  " + $validateCode + ".call( ";
			if (it.opts.passContext) out += "this";
			else out += "self";
			if ($compile || $rDef.schema === false) out += " , " + $data + " ";
			else out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
			out += " , (dataPath || '')";
			if (it.errorPath != "\"\"") out += " + " + it.errorPath;
			var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
			out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
			var def_callRuleValidate = out;
			out = $$outStack.pop();
			if ($rDef.errors === false) {
				out += " " + $valid + " = ";
				if ($asyncKeyword) out += "await ";
				out += "" + def_callRuleValidate + "; ";
			} else if ($asyncKeyword) {
				$ruleErrs = "customErrors" + $lvl;
				out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
			} else out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
		}
		if ($rDef.modifying) out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
		out += "" + $closingBraces;
		if ($rDef.valid) {
			if ($breakOnError) out += " if (true) { ";
		} else {
			out += " if ( ";
			if ($rDef.valid === void 0) {
				out += " !";
				if ($macro) out += "" + $nextValid;
				else out += "" + $valid;
			} else out += " " + !$rDef.valid + " ";
			out += ") { ";
			$errorKeyword = $rule.keyword;
			var $$outStack = $$outStack || [];
			$$outStack.push(out);
			out = "";
			var $$outStack = $$outStack || [];
			$$outStack.push(out);
			out = "";
			if (it.createErrors !== false) {
				out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
				if (it.opts.messages !== false) out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' ";
				if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
				out += " } ";
			} else out += " {} ";
			var __err = out;
			out = $$outStack.pop();
			if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
			if (it.async) out += " throw new ValidationError([" + __err + "]); ";
			else out += " validate.errors = [" + __err + "]; return false; ";
			else out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
			var def_customError = out;
			out = $$outStack.pop();
			if ($inline) if ($rDef.errors) {
				if ($rDef.errors != "full") {
					out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + ".schemaPath = \"" + $errSchemaPath + "\"; } ";
					if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
					out += " } ";
				}
			} else if ($rDef.errors === false) out += " " + def_customError + " ";
			else {
				out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + ".schemaPath = \"" + $errSchemaPath + "\"; } ";
				if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
				out += " } } ";
			}
			else if ($macro) {
				out += "   var err =   ";
				if (it.createErrors !== false) {
					out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
					if (it.opts.messages !== false) out += " , message: 'should pass \"" + $rule.keyword + "\" keyword validation' ";
					if (it.opts.verbose) out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
					out += " } ";
				} else out += " {} ";
				out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
				if (!it.compositeRule && $breakOnError)
 /* istanbul ignore if */
				if (it.async) out += " throw new ValidationError(vErrors); ";
				else out += " validate.errors = vErrors; return false; ";
			} else if ($rDef.errors === false) out += " " + def_customError + " ";
			else {
				out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + ".schemaPath = \"" + $errSchemaPath + "\";  ";
				if (it.opts.verbose) out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
				out += " } } else { " + def_customError + " } ";
			}
			out += " } ";
			if ($breakOnError) out += " else { ";
		}
		return out;
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/json-schema-draft-07.json": ((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "http://json-schema.org/draft-07/schema#",
		"title": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": { "$ref": "#" }
			},
			"nonNegativeInteger": {
				"type": "integer",
				"minimum": 0
			},
			"nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] },
			"simpleTypes": { "enum": [
				"array",
				"boolean",
				"integer",
				"null",
				"number",
				"object",
				"string"
			] },
			"stringArray": {
				"type": "array",
				"items": { "type": "string" },
				"uniqueItems": true,
				"default": []
			}
		},
		"type": ["object", "boolean"],
		"properties": {
			"$id": {
				"type": "string",
				"format": "uri-reference"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"$ref": {
				"type": "string",
				"format": "uri-reference"
			},
			"$comment": { "type": "string" },
			"title": { "type": "string" },
			"description": { "type": "string" },
			"default": true,
			"readOnly": {
				"type": "boolean",
				"default": false
			},
			"examples": {
				"type": "array",
				"items": true
			},
			"multipleOf": {
				"type": "number",
				"exclusiveMinimum": 0
			},
			"maximum": { "type": "number" },
			"exclusiveMaximum": { "type": "number" },
			"minimum": { "type": "number" },
			"exclusiveMinimum": { "type": "number" },
			"maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
			"minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": { "$ref": "#" },
			"items": {
				"anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
				"default": true
			},
			"maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
			"minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"contains": { "$ref": "#" },
			"maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
			"minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
			"required": { "$ref": "#/definitions/stringArray" },
			"additionalProperties": { "$ref": "#" },
			"definitions": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": { "$ref": "#" },
				"propertyNames": { "format": "regex" },
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] }
			},
			"propertyNames": { "$ref": "#" },
			"const": true,
			"enum": {
				"type": "array",
				"items": true,
				"minItems": 1,
				"uniqueItems": true
			},
			"type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
				"type": "array",
				"items": { "$ref": "#/definitions/simpleTypes" },
				"minItems": 1,
				"uniqueItems": true
			}] },
			"format": { "type": "string" },
			"contentMediaType": { "type": "string" },
			"contentEncoding": { "type": "string" },
			"if": { "$ref": "#" },
			"then": { "$ref": "#" },
			"else": { "$ref": "#" },
			"allOf": { "$ref": "#/definitions/schemaArray" },
			"anyOf": { "$ref": "#/definitions/schemaArray" },
			"oneOf": { "$ref": "#/definitions/schemaArray" },
			"not": { "$ref": "#" }
		},
		"default": true
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/definition_schema.js
var require_definition_schema = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/definition_schema.js": ((exports, module) => {
	var metaSchema = require_json_schema_draft_07();
	module.exports = {
		$id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
		definitions: { simpleTypes: metaSchema.definitions.simpleTypes },
		type: "object",
		dependencies: {
			schema: ["validate"],
			$data: ["validate"],
			statements: ["inline"],
			valid: { not: { required: ["macro"] } }
		},
		properties: {
			type: metaSchema.properties.type,
			schema: { type: "boolean" },
			statements: { type: "boolean" },
			dependencies: {
				type: "array",
				items: { type: "string" }
			},
			metaSchema: { type: "object" },
			modifying: { type: "boolean" },
			valid: { type: "boolean" },
			$data: { type: "boolean" },
			async: { type: "boolean" },
			errors: { anyOf: [{ type: "boolean" }, { const: "full" }] }
		}
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/keyword.js
var require_keyword = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/keyword.js": ((exports, module) => {
	var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
	var customRuleCode = require_custom();
	var definitionSchema = require_definition_schema();
	module.exports = {
		add: addKeyword,
		get: getKeyword,
		remove: removeKeyword,
		validate: validateKeyword
	};
	/**
	* Define custom keyword
	* @this  Ajv
	* @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
	* @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
	* @return {Ajv} this for method chaining
	*/
	function addKeyword(keyword, definition) {
		var RULES = this.RULES;
		if (RULES.keywords[keyword]) throw new Error("Keyword " + keyword + " is already defined");
		if (!IDENTIFIER.test(keyword)) throw new Error("Keyword " + keyword + " is not a valid identifier");
		if (definition) {
			this.validateKeyword(definition, true);
			var dataType = definition.type;
			if (Array.isArray(dataType)) for (var i$3 = 0; i$3 < dataType.length; i$3++) _addRule(keyword, dataType[i$3], definition);
			else _addRule(keyword, dataType, definition);
			var metaSchema$1 = definition.metaSchema;
			if (metaSchema$1) {
				if (definition.$data && this._opts.$data) metaSchema$1 = { anyOf: [metaSchema$1, { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }] };
				definition.validateSchema = this.compile(metaSchema$1, true);
			}
		}
		RULES.keywords[keyword] = RULES.all[keyword] = true;
		function _addRule(keyword$1, dataType$1, definition$1) {
			var ruleGroup;
			for (var i$4 = 0; i$4 < RULES.length; i$4++) {
				var rg = RULES[i$4];
				if (rg.type == dataType$1) {
					ruleGroup = rg;
					break;
				}
			}
			if (!ruleGroup) {
				ruleGroup = {
					type: dataType$1,
					rules: []
				};
				RULES.push(ruleGroup);
			}
			var rule = {
				keyword: keyword$1,
				definition: definition$1,
				custom: true,
				code: customRuleCode,
				implements: definition$1.implements
			};
			ruleGroup.rules.push(rule);
			RULES.custom[keyword$1] = rule;
		}
		return this;
	}
	/**
	* Get keyword
	* @this  Ajv
	* @param {String} keyword pre-defined or custom keyword.
	* @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
	*/
	function getKeyword(keyword) {
		var rule = this.RULES.custom[keyword];
		return rule ? rule.definition : this.RULES.keywords[keyword] || false;
	}
	/**
	* Remove keyword
	* @this  Ajv
	* @param {String} keyword pre-defined or custom keyword.
	* @return {Ajv} this for method chaining
	*/
	function removeKeyword(keyword) {
		var RULES = this.RULES;
		delete RULES.keywords[keyword];
		delete RULES.all[keyword];
		delete RULES.custom[keyword];
		for (var i$3 = 0; i$3 < RULES.length; i$3++) {
			var rules$1 = RULES[i$3].rules;
			for (var j = 0; j < rules$1.length; j++) if (rules$1[j].keyword == keyword) {
				rules$1.splice(j, 1);
				break;
			}
		}
		return this;
	}
	/**
	* Validate keyword definition
	* @this  Ajv
	* @param {Object} definition keyword definition object.
	* @param {Boolean} throwError true to throw exception if definition is invalid
	* @return {boolean} validation result
	*/
	function validateKeyword(definition, throwError) {
		validateKeyword.errors = null;
		var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
		if (v(definition)) return true;
		validateKeyword.errors = v.errors;
		if (throwError) throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
		else return false;
	}
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/data.json
var require_data = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/refs/data.json": ((exports, module) => {
	module.exports = {
		"$schema": "http://json-schema.org/draft-07/schema#",
		"$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		"description": "Meta-schema for $data reference (JSON Schema extension proposal)",
		"type": "object",
		"required": ["$data"],
		"properties": { "$data": {
			"type": "string",
			"anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
		} },
		"additionalProperties": false
	};
}) });

//#endregion
//#region node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/ajv.js
var require_ajv = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/ajv@6.12.6/node_modules/ajv/lib/ajv.js": ((exports, module) => {
	var compileSchema = require_compile(), resolve = require_resolve(), Cache = require_cache(), SchemaObject = require_schema_obj(), stableStringify = require_fast_json_stable_stringify(), formats = require_formats(), rules = require_rules(), $dataMetaSchema = require_data$1(), util = require_util();
	module.exports = Ajv$2;
	Ajv$2.prototype.validate = validate;
	Ajv$2.prototype.compile = compile;
	Ajv$2.prototype.addSchema = addSchema;
	Ajv$2.prototype.addMetaSchema = addMetaSchema;
	Ajv$2.prototype.validateSchema = validateSchema;
	Ajv$2.prototype.getSchema = getSchema;
	Ajv$2.prototype.removeSchema = removeSchema;
	Ajv$2.prototype.addFormat = addFormat;
	Ajv$2.prototype.errorsText = errorsText;
	Ajv$2.prototype._addSchema = _addSchema;
	Ajv$2.prototype._compile = _compile;
	Ajv$2.prototype.compileAsync = require_async();
	var customKeyword = require_keyword();
	Ajv$2.prototype.addKeyword = customKeyword.add;
	Ajv$2.prototype.getKeyword = customKeyword.get;
	Ajv$2.prototype.removeKeyword = customKeyword.remove;
	Ajv$2.prototype.validateKeyword = customKeyword.validate;
	var errorClasses = require_error_classes();
	Ajv$2.ValidationError = errorClasses.Validation;
	Ajv$2.MissingRefError = errorClasses.MissingRef;
	Ajv$2.$dataMetaSchema = $dataMetaSchema;
	var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	var META_IGNORE_OPTIONS = [
		"removeAdditional",
		"useDefaults",
		"coerceTypes",
		"strictDefaults"
	];
	var META_SUPPORT_DATA = ["/properties"];
	/**
	* Creates validator instance.
	* Usage: `Ajv(opts)`
	* @param {Object} opts optional options
	* @return {Object} ajv instance
	*/
	function Ajv$2(opts) {
		if (!(this instanceof Ajv$2)) return new Ajv$2(opts);
		opts = this._opts = util.copy(opts) || {};
		setLogger(this);
		this._schemas = {};
		this._refs = {};
		this._fragments = {};
		this._formats = formats(opts.format);
		this._cache = opts.cache || new Cache();
		this._loadingSchemas = {};
		this._compilations = [];
		this.RULES = rules();
		this._getId = chooseGetId(opts);
		opts.loopRequired = opts.loopRequired || Infinity;
		if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
		if (opts.serialize === void 0) opts.serialize = stableStringify;
		this._metaOpts = getMetaSchemaOptions(this);
		if (opts.formats) addInitialFormats(this);
		if (opts.keywords) addInitialKeywords(this);
		addDefaultMetaSchema(this);
		if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
		if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
		addInitialSchemas(this);
	}
	/**
	* Validate data using schema
	* Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
	* @this   Ajv
	* @param  {String|Object} schemaKeyRef key, ref or schema object
	* @param  {Any} data to be validated
	* @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
	*/
	function validate(schemaKeyRef, data) {
		var v;
		if (typeof schemaKeyRef == "string") {
			v = this.getSchema(schemaKeyRef);
			if (!v) throw new Error("no schema with key or ref \"" + schemaKeyRef + "\"");
		} else {
			var schemaObj = this._addSchema(schemaKeyRef);
			v = schemaObj.validate || this._compile(schemaObj);
		}
		var valid = v(data);
		if (v.$async !== true) this.errors = v.errors;
		return valid;
	}
	/**
	* Create validating function for passed schema.
	* @this   Ajv
	* @param  {Object} schema schema object
	* @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
	* @return {Function} validating function
	*/
	function compile(schema, _meta) {
		var schemaObj = this._addSchema(schema, void 0, _meta);
		return schemaObj.validate || this._compile(schemaObj);
	}
	/**
	* Adds schema to the instance.
	* @this   Ajv
	* @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
	* @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
	* @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
	* @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
	* @return {Ajv} this for method chaining
	*/
	function addSchema(schema, key$1, _skipValidation, _meta) {
		if (Array.isArray(schema)) {
			for (var i$3 = 0; i$3 < schema.length; i$3++) this.addSchema(schema[i$3], void 0, _skipValidation, _meta);
			return this;
		}
		var id = this._getId(schema);
		if (id !== void 0 && typeof id != "string") throw new Error("schema id must be string");
		key$1 = resolve.normalizeId(key$1 || id);
		checkUnique(this, key$1);
		this._schemas[key$1] = this._addSchema(schema, _skipValidation, _meta, true);
		return this;
	}
	/**
	* Add schema that will be used to validate other schemas
	* options in META_IGNORE_OPTIONS are alway set to false
	* @this   Ajv
	* @param {Object} schema schema object
	* @param {String} key optional schema key
	* @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
	* @return {Ajv} this for method chaining
	*/
	function addMetaSchema(schema, key$1, skipValidation) {
		this.addSchema(schema, key$1, skipValidation, true);
		return this;
	}
	/**
	* Validate schema
	* @this   Ajv
	* @param {Object} schema schema to validate
	* @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
	* @return {Boolean} true if schema is valid
	*/
	function validateSchema(schema, throwOrLogError) {
		var $schema = schema.$schema;
		if ($schema !== void 0 && typeof $schema != "string") throw new Error("$schema must be a string");
		$schema = $schema || this._opts.defaultMeta || defaultMeta(this);
		if (!$schema) {
			this.logger.warn("meta-schema not available");
			this.errors = null;
			return true;
		}
		var valid = this.validate($schema, schema);
		if (!valid && throwOrLogError) {
			var message = "schema is invalid: " + this.errorsText();
			if (this._opts.validateSchema == "log") this.logger.error(message);
			else throw new Error(message);
		}
		return valid;
	}
	function defaultMeta(self) {
		var meta = self._opts.meta;
		self._opts.defaultMeta = typeof meta == "object" ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
		return self._opts.defaultMeta;
	}
	/**
	* Get compiled schema from the instance by `key` or `ref`.
	* @this   Ajv
	* @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
	* @return {Function} schema validating function (with property `schema`).
	*/
	function getSchema(keyRef) {
		var schemaObj = _getSchemaObj(this, keyRef);
		switch (typeof schemaObj) {
			case "object": return schemaObj.validate || this._compile(schemaObj);
			case "string": return this.getSchema(schemaObj);
			case "undefined": return _getSchemaFragment(this, keyRef);
		}
	}
	function _getSchemaFragment(self, ref) {
		var res = resolve.schema.call(self, { schema: {} }, ref);
		if (res) {
			var schema = res.schema, root = res.root, baseId = res.baseId;
			var v = compileSchema.call(self, schema, root, void 0, baseId);
			self._fragments[ref] = new SchemaObject({
				ref,
				fragment: true,
				schema,
				root,
				baseId,
				validate: v
			});
			return v;
		}
	}
	function _getSchemaObj(self, keyRef) {
		keyRef = resolve.normalizeId(keyRef);
		return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
	}
	/**
	* Remove cached schema(s).
	* If no parameter is passed all schemas but meta-schemas are removed.
	* If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
	* Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
	* @this   Ajv
	* @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
	* @return {Ajv} this for method chaining
	*/
	function removeSchema(schemaKeyRef) {
		if (schemaKeyRef instanceof RegExp) {
			_removeAllSchemas(this, this._schemas, schemaKeyRef);
			_removeAllSchemas(this, this._refs, schemaKeyRef);
			return this;
		}
		switch (typeof schemaKeyRef) {
			case "undefined":
				_removeAllSchemas(this, this._schemas);
				_removeAllSchemas(this, this._refs);
				this._cache.clear();
				return this;
			case "string":
				var schemaObj = _getSchemaObj(this, schemaKeyRef);
				if (schemaObj) this._cache.del(schemaObj.cacheKey);
				delete this._schemas[schemaKeyRef];
				delete this._refs[schemaKeyRef];
				return this;
			case "object":
				var serialize = this._opts.serialize;
				var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
				this._cache.del(cacheKey);
				var id = this._getId(schemaKeyRef);
				if (id) {
					id = resolve.normalizeId(id);
					delete this._schemas[id];
					delete this._refs[id];
				}
		}
		return this;
	}
	function _removeAllSchemas(self, schemas, regex$1) {
		for (var keyRef in schemas) {
			var schemaObj = schemas[keyRef];
			if (!schemaObj.meta && (!regex$1 || regex$1.test(keyRef))) {
				self._cache.del(schemaObj.cacheKey);
				delete schemas[keyRef];
			}
		}
	}
	function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
		if (typeof schema != "object" && typeof schema != "boolean") throw new Error("schema should be object or boolean");
		var serialize = this._opts.serialize;
		var cacheKey = serialize ? serialize(schema) : schema;
		var cached = this._cache.get(cacheKey);
		if (cached) return cached;
		shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
		var id = resolve.normalizeId(this._getId(schema));
		if (id && shouldAddSchema) checkUnique(this, id);
		var willValidate = this._opts.validateSchema !== false && !skipValidation;
		var recursiveMeta;
		if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))) this.validateSchema(schema, true);
		var localRefs = resolve.ids.call(this, schema);
		var schemaObj = new SchemaObject({
			id,
			schema,
			localRefs,
			cacheKey,
			meta
		});
		if (id[0] != "#" && shouldAddSchema) this._refs[id] = schemaObj;
		this._cache.put(cacheKey, schemaObj);
		if (willValidate && recursiveMeta) this.validateSchema(schema, true);
		return schemaObj;
	}
	function _compile(schemaObj, root) {
		if (schemaObj.compiling) {
			schemaObj.validate = callValidate;
			callValidate.schema = schemaObj.schema;
			callValidate.errors = null;
			callValidate.root = root ? root : callValidate;
			if (schemaObj.schema.$async === true) callValidate.$async = true;
			return callValidate;
		}
		schemaObj.compiling = true;
		var currentOpts;
		if (schemaObj.meta) {
			currentOpts = this._opts;
			this._opts = this._metaOpts;
		}
		var v;
		try {
			v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
		} catch (e) {
			delete schemaObj.validate;
			throw e;
		} finally {
			schemaObj.compiling = false;
			if (schemaObj.meta) this._opts = currentOpts;
		}
		schemaObj.validate = v;
		schemaObj.refs = v.refs;
		schemaObj.refVal = v.refVal;
		schemaObj.root = v.root;
		return v;
		function callValidate() {
			var _validate = schemaObj.validate;
			var result = _validate.apply(this, arguments);
			callValidate.errors = _validate.errors;
			return result;
		}
	}
	function chooseGetId(opts) {
		switch (opts.schemaId) {
			case "auto": return _get$IdOrId;
			case "id": return _getId;
			default: return _get$Id;
		}
	}
	function _getId(schema) {
		if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
		return schema.id;
	}
	function _get$Id(schema) {
		if (schema.id) this.logger.warn("schema id ignored", schema.id);
		return schema.$id;
	}
	function _get$IdOrId(schema) {
		if (schema.$id && schema.id && schema.$id != schema.id) throw new Error("schema $id is different from id");
		return schema.$id || schema.id;
	}
	/**
	* Convert array of error message objects to string
	* @this   Ajv
	* @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
	* @param  {Object} options optional options with properties `separator` and `dataVar`.
	* @return {String} human readable string with all errors descriptions
	*/
	function errorsText(errors, options) {
		errors = errors || this.errors;
		if (!errors) return "No errors";
		options = options || {};
		var separator = options.separator === void 0 ? ", " : options.separator;
		var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
		var text = "";
		for (var i$3 = 0; i$3 < errors.length; i$3++) {
			var e = errors[i$3];
			if (e) text += dataVar + e.dataPath + " " + e.message + separator;
		}
		return text.slice(0, -separator.length);
	}
	/**
	* Add custom format
	* @this   Ajv
	* @param {String} name format name
	* @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
	* @return {Ajv} this for method chaining
	*/
	function addFormat(name, format$1) {
		if (typeof format$1 == "string") format$1 = new RegExp(format$1);
		this._formats[name] = format$1;
		return this;
	}
	function addDefaultMetaSchema(self) {
		var $dataSchema;
		if (self._opts.$data) {
			$dataSchema = require_data();
			self.addMetaSchema($dataSchema, $dataSchema.$id, true);
		}
		if (self._opts.meta === false) return;
		var metaSchema$1 = require_json_schema_draft_07();
		if (self._opts.$data) metaSchema$1 = $dataMetaSchema(metaSchema$1, META_SUPPORT_DATA);
		self.addMetaSchema(metaSchema$1, META_SCHEMA_ID, true);
		self._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
	}
	function addInitialSchemas(self) {
		var optsSchemas = self._opts.schemas;
		if (!optsSchemas) return;
		if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
		else for (var key$1 in optsSchemas) self.addSchema(optsSchemas[key$1], key$1);
	}
	function addInitialFormats(self) {
		for (var name in self._opts.formats) {
			var format$1 = self._opts.formats[name];
			self.addFormat(name, format$1);
		}
	}
	function addInitialKeywords(self) {
		for (var name in self._opts.keywords) {
			var keyword = self._opts.keywords[name];
			self.addKeyword(name, keyword);
		}
	}
	function checkUnique(self, id) {
		if (self._schemas[id] || self._refs[id]) throw new Error("schema with key or id \"" + id + "\" already exists");
	}
	function getMetaSchemaOptions(self) {
		var metaOpts = util.copy(self._opts);
		for (var i$3 = 0; i$3 < META_IGNORE_OPTIONS.length; i$3++) delete metaOpts[META_IGNORE_OPTIONS[i$3]];
		return metaOpts;
	}
	function setLogger(self) {
		var logger = self._opts.logger;
		if (logger === false) self.logger = {
			log: noop,
			warn: noop,
			error: noop
		};
		else {
			if (logger === void 0) logger = console;
			if (!(typeof logger == "object" && logger.log && logger.warn && logger.error)) throw new Error("logger must implement log, warn and error methods");
			self.logger = logger;
		}
	}
	function noop() {}
}) });

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.18.1/node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
var import_ajv$1 = /* @__PURE__ */ __toESM(require_ajv(), 1);
/**
* An MCP client on top of a pluggable transport.
*
* The client will automatically begin the initialization flow with the server when connect() is called.
*
* To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
*
* ```typescript
* // Custom schemas
* const CustomRequestSchema = RequestSchema.extend({...})
* const CustomNotificationSchema = NotificationSchema.extend({...})
* const CustomResultSchema = ResultSchema.extend({...})
*
* // Type aliases
* type CustomRequest = z.infer<typeof CustomRequestSchema>
* type CustomNotification = z.infer<typeof CustomNotificationSchema>
* type CustomResult = z.infer<typeof CustomResultSchema>
*
* // Create typed client
* const client = new Client<CustomRequest, CustomNotification, CustomResult>({
*   name: "CustomClient",
*   version: "1.0.0"
* })
* ```
*/
var Client = class extends Protocol {
	/**
	* Initializes this client with the given name and version information.
	*/
	constructor(_clientInfo, options) {
		var _a;
		super(options);
		this._clientInfo = _clientInfo;
		this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
		this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
		this._ajv = new import_ajv$1.default();
	}
	/**
	* Registers new capabilities. This can only be called before connecting to a transport.
	*
	* The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
	*/
	registerCapabilities(capabilities) {
		if (this.transport) throw new Error("Cannot register capabilities after connecting to transport");
		this._capabilities = mergeCapabilities(this._capabilities, capabilities);
	}
	assertCapability(capability, method) {
		var _a;
		if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a[capability])) throw new Error(`Server does not support ${capability} (required for ${method})`);
	}
	async connect(transport, options) {
		await super.connect(transport);
		if (transport.sessionId !== void 0) return;
		try {
			const result = await this.request({
				method: "initialize",
				params: {
					protocolVersion: LATEST_PROTOCOL_VERSION,
					capabilities: this._capabilities,
					clientInfo: this._clientInfo
				}
			}, InitializeResultSchema, options);
			if (result === void 0) throw new Error(`Server sent invalid initialize result: ${result}`);
			if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
			this._serverCapabilities = result.capabilities;
			this._serverVersion = result.serverInfo;
			if (transport.setProtocolVersion) transport.setProtocolVersion(result.protocolVersion);
			this._instructions = result.instructions;
			await this.notification({ method: "notifications/initialized" });
		} catch (error) {
			this.close();
			throw error;
		}
	}
	/**
	* After initialization has completed, this will be populated with the server's reported capabilities.
	*/
	getServerCapabilities() {
		return this._serverCapabilities;
	}
	/**
	* After initialization has completed, this will be populated with information about the server's name and version.
	*/
	getServerVersion() {
		return this._serverVersion;
	}
	/**
	* After initialization has completed, this may be populated with information about the server's instructions.
	*/
	getInstructions() {
		return this._instructions;
	}
	assertCapabilityForMethod(method) {
		var _a, _b, _c, _d, _e;
		switch (method) {
			case "logging/setLevel":
				if (!((_a = this._serverCapabilities) === null || _a === void 0 ? void 0 : _a.logging)) throw new Error(`Server does not support logging (required for ${method})`);
				break;
			case "prompts/get":
			case "prompts/list":
				if (!((_b = this._serverCapabilities) === null || _b === void 0 ? void 0 : _b.prompts)) throw new Error(`Server does not support prompts (required for ${method})`);
				break;
			case "resources/list":
			case "resources/templates/list":
			case "resources/read":
			case "resources/subscribe":
			case "resources/unsubscribe":
				if (!((_c = this._serverCapabilities) === null || _c === void 0 ? void 0 : _c.resources)) throw new Error(`Server does not support resources (required for ${method})`);
				if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) throw new Error(`Server does not support resource subscriptions (required for ${method})`);
				break;
			case "tools/call":
			case "tools/list":
				if (!((_d = this._serverCapabilities) === null || _d === void 0 ? void 0 : _d.tools)) throw new Error(`Server does not support tools (required for ${method})`);
				break;
			case "completion/complete":
				if (!((_e = this._serverCapabilities) === null || _e === void 0 ? void 0 : _e.completions)) throw new Error(`Server does not support completions (required for ${method})`);
				break;
			case "initialize": break;
			case "ping": break;
		}
	}
	assertNotificationCapability(method) {
		var _a;
		switch (method) {
			case "notifications/roots/list_changed":
				if (!((_a = this._capabilities.roots) === null || _a === void 0 ? void 0 : _a.listChanged)) throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
				break;
			case "notifications/initialized": break;
			case "notifications/cancelled": break;
			case "notifications/progress": break;
		}
	}
	assertRequestHandlerCapability(method) {
		switch (method) {
			case "sampling/createMessage":
				if (!this._capabilities.sampling) throw new Error(`Client does not support sampling capability (required for ${method})`);
				break;
			case "elicitation/create":
				if (!this._capabilities.elicitation) throw new Error(`Client does not support elicitation capability (required for ${method})`);
				break;
			case "roots/list":
				if (!this._capabilities.roots) throw new Error(`Client does not support roots capability (required for ${method})`);
				break;
			case "ping": break;
		}
	}
	async ping(options) {
		return this.request({ method: "ping" }, EmptyResultSchema, options);
	}
	async complete(params, options) {
		return this.request({
			method: "completion/complete",
			params
		}, CompleteResultSchema, options);
	}
	async setLoggingLevel(level, options) {
		return this.request({
			method: "logging/setLevel",
			params: { level }
		}, EmptyResultSchema, options);
	}
	async getPrompt(params, options) {
		return this.request({
			method: "prompts/get",
			params
		}, GetPromptResultSchema, options);
	}
	async listPrompts(params, options) {
		return this.request({
			method: "prompts/list",
			params
		}, ListPromptsResultSchema, options);
	}
	async listResources(params, options) {
		return this.request({
			method: "resources/list",
			params
		}, ListResourcesResultSchema, options);
	}
	async listResourceTemplates(params, options) {
		return this.request({
			method: "resources/templates/list",
			params
		}, ListResourceTemplatesResultSchema, options);
	}
	async readResource(params, options) {
		return this.request({
			method: "resources/read",
			params
		}, ReadResourceResultSchema, options);
	}
	async subscribeResource(params, options) {
		return this.request({
			method: "resources/subscribe",
			params
		}, EmptyResultSchema, options);
	}
	async unsubscribeResource(params, options) {
		return this.request({
			method: "resources/unsubscribe",
			params
		}, EmptyResultSchema, options);
	}
	async callTool(params, resultSchema = CallToolResultSchema, options) {
		const result = await this.request({
			method: "tools/call",
			params
		}, resultSchema, options);
		const validator = this.getToolOutputValidator(params.name);
		if (validator) {
			if (!result.structuredContent && !result.isError) throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
			if (result.structuredContent) try {
				if (!validator(result.structuredContent)) throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${this._ajv.errorsText(validator.errors)}`);
			} catch (error) {
				if (error instanceof McpError) throw error;
				throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
			}
		}
		return result;
	}
	cacheToolOutputSchemas(tools) {
		this._cachedToolOutputValidators.clear();
		for (const tool of tools) if (tool.outputSchema) try {
			const validator = this._ajv.compile(tool.outputSchema);
			this._cachedToolOutputValidators.set(tool.name, validator);
		} catch (_a) {}
	}
	getToolOutputValidator(toolName) {
		return this._cachedToolOutputValidators.get(toolName);
	}
	async listTools(params, options) {
		const result = await this.request({
			method: "tools/list",
			params
		}, ListToolsResultSchema, options);
		this.cacheToolOutputSchemas(result.tools);
		return result;
	}
	async sendRootsListChanged() {
		return this.notification({ method: "notifications/roots/list_changed" });
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.18.1/node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var import_ajv = /* @__PURE__ */ __toESM(require_ajv(), 1);
/**
* An MCP server on top of a pluggable transport.
*
* This server will automatically respond to the initialization flow as initiated from the client.
*
* To use with custom types, extend the base Request/Notification/Result types and pass them as type parameters:
*
* ```typescript
* // Custom schemas
* const CustomRequestSchema = RequestSchema.extend({...})
* const CustomNotificationSchema = NotificationSchema.extend({...})
* const CustomResultSchema = ResultSchema.extend({...})
*
* // Type aliases
* type CustomRequest = z.infer<typeof CustomRequestSchema>
* type CustomNotification = z.infer<typeof CustomNotificationSchema>
* type CustomResult = z.infer<typeof CustomResultSchema>
*
* // Create typed server
* const server = new Server<CustomRequest, CustomNotification, CustomResult>({
*   name: "CustomServer",
*   version: "1.0.0"
* })
* ```
*/
var Server = class extends Protocol {
	/**
	* Initializes this server with the given name and version information.
	*/
	constructor(_serverInfo, options) {
		var _a;
		super(options);
		this._serverInfo = _serverInfo;
		this._loggingLevels = /* @__PURE__ */ new Map();
		this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index]));
		this.isMessageIgnored = (level, sessionId) => {
			const currentLevel = this._loggingLevels.get(sessionId);
			return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : false;
		};
		this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
		this._instructions = options === null || options === void 0 ? void 0 : options.instructions;
		this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
		this.setNotificationHandler(InitializedNotificationSchema, () => {
			var _a$1;
			return (_a$1 = this.oninitialized) === null || _a$1 === void 0 ? void 0 : _a$1.call(this);
		});
		if (this._capabilities.logging) this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
			var _a$1;
			const transportSessionId = extra.sessionId || ((_a$1 = extra.requestInfo) === null || _a$1 === void 0 ? void 0 : _a$1.headers["mcp-session-id"]) || void 0;
			const { level } = request.params;
			const parseResult = LoggingLevelSchema.safeParse(level);
			if (parseResult.success) this._loggingLevels.set(transportSessionId, parseResult.data);
			return {};
		});
	}
	/**
	* Registers new capabilities. This can only be called before connecting to a transport.
	*
	* The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
	*/
	registerCapabilities(capabilities) {
		if (this.transport) throw new Error("Cannot register capabilities after connecting to transport");
		this._capabilities = mergeCapabilities(this._capabilities, capabilities);
	}
	assertCapabilityForMethod(method) {
		var _a, _b, _c;
		switch (method) {
			case "sampling/createMessage":
				if (!((_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling)) throw new Error(`Client does not support sampling (required for ${method})`);
				break;
			case "elicitation/create":
				if (!((_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation)) throw new Error(`Client does not support elicitation (required for ${method})`);
				break;
			case "roots/list":
				if (!((_c = this._clientCapabilities) === null || _c === void 0 ? void 0 : _c.roots)) throw new Error(`Client does not support listing roots (required for ${method})`);
				break;
			case "ping": break;
		}
	}
	assertNotificationCapability(method) {
		switch (method) {
			case "notifications/message":
				if (!this._capabilities.logging) throw new Error(`Server does not support logging (required for ${method})`);
				break;
			case "notifications/resources/updated":
			case "notifications/resources/list_changed":
				if (!this._capabilities.resources) throw new Error(`Server does not support notifying about resources (required for ${method})`);
				break;
			case "notifications/tools/list_changed":
				if (!this._capabilities.tools) throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
				break;
			case "notifications/prompts/list_changed":
				if (!this._capabilities.prompts) throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
				break;
			case "notifications/cancelled": break;
			case "notifications/progress": break;
		}
	}
	assertRequestHandlerCapability(method) {
		switch (method) {
			case "sampling/createMessage":
				if (!this._capabilities.sampling) throw new Error(`Server does not support sampling (required for ${method})`);
				break;
			case "logging/setLevel":
				if (!this._capabilities.logging) throw new Error(`Server does not support logging (required for ${method})`);
				break;
			case "prompts/get":
			case "prompts/list":
				if (!this._capabilities.prompts) throw new Error(`Server does not support prompts (required for ${method})`);
				break;
			case "resources/list":
			case "resources/templates/list":
			case "resources/read":
				if (!this._capabilities.resources) throw new Error(`Server does not support resources (required for ${method})`);
				break;
			case "tools/call":
			case "tools/list":
				if (!this._capabilities.tools) throw new Error(`Server does not support tools (required for ${method})`);
				break;
			case "ping":
			case "initialize": break;
		}
	}
	async _oninitialize(request) {
		const requestedVersion = request.params.protocolVersion;
		this._clientCapabilities = request.params.capabilities;
		this._clientVersion = request.params.clientInfo;
		return {
			protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
			capabilities: this.getCapabilities(),
			serverInfo: this._serverInfo,
			...this._instructions && { instructions: this._instructions }
		};
	}
	/**
	* After initialization has completed, this will be populated with the client's reported capabilities.
	*/
	getClientCapabilities() {
		return this._clientCapabilities;
	}
	/**
	* After initialization has completed, this will be populated with information about the client's name and version.
	*/
	getClientVersion() {
		return this._clientVersion;
	}
	getCapabilities() {
		return this._capabilities;
	}
	async ping() {
		return this.request({ method: "ping" }, EmptyResultSchema);
	}
	async createMessage(params, options) {
		return this.request({
			method: "sampling/createMessage",
			params
		}, CreateMessageResultSchema, options);
	}
	async elicitInput(params, options) {
		const result = await this.request({
			method: "elicitation/create",
			params
		}, ElicitResultSchema, options);
		if (result.action === "accept" && result.content) try {
			const ajv = new import_ajv.default();
			const validate$1 = ajv.compile(params.requestedSchema);
			if (!validate$1(result.content)) throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${ajv.errorsText(validate$1.errors)}`);
		} catch (error) {
			if (error instanceof McpError) throw error;
			throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error}`);
		}
		return result;
	}
	async listRoots(params, options) {
		return this.request({
			method: "roots/list",
			params
		}, ListRootsResultSchema, options);
	}
	/**
	* Sends a logging message to the client, if connected.
	* Note: You only need to send the parameters object, not the entire JSON RPC message
	* @see LoggingMessageNotification
	* @param params
	* @param sessionId optional for stateless and backward compatibility
	*/
	async sendLoggingMessage(params, sessionId) {
		if (this._capabilities.logging) {
			if (!this.isMessageIgnored(params.level, sessionId)) return this.notification({
				method: "notifications/message",
				params
			});
		}
	}
	async sendResourceUpdated(params) {
		return this.notification({
			method: "notifications/resources/updated",
			params
		});
	}
	async sendResourceListChanged() {
		return this.notification({ method: "notifications/resources/list_changed" });
	}
	async sendToolListChanged() {
		return this.notification({ method: "notifications/tools/list_changed" });
	}
	async sendPromptListChanged() {
		return this.notification({ method: "notifications/prompts/list_changed" });
	}
};

//#endregion
//#region node_modules/.pnpm/@modelcontextprotocol+sdk@1.18.1/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
/**
* Buffers a continuous stdio stream into discrete JSON-RPC messages.
*/
var ReadBuffer = class {
	append(chunk) {
		this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
	}
	readMessage() {
		if (!this._buffer) return null;
		const index = this._buffer.indexOf("\n");
		if (index === -1) return null;
		const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
		this._buffer = this._buffer.subarray(index + 1);
		return deserializeMessage(line);
	}
	clear() {
		this._buffer = void 0;
	}
};
function deserializeMessage(line) {
	return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
	return JSON.stringify(message) + "\n";
}

//#endregion
export { AuthenticationMiddleware, Client, InMemoryEventStore, JSONRPCMessageSchema, LATEST_PROTOCOL_VERSION, NEVER, ReadBuffer, Server, ZodIssueCode, __commonJS, __toESM, anyType, arrayType, booleanType, isInitializedNotification, isJSONRPCRequest, isJSONRPCResponse, numberType, objectType, proxyServer, serializeMessage, startHTTPServer, stringType };
//# sourceMappingURL=stdio-CsjPjeWC.js.map